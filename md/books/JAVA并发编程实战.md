

JAVA并发编程实战

> 目录

```
译者序
前　言
第1章　简介
1.1　并发简史
1.2　线程的优势
1.2.1　发挥多处理器的强大能力
1.2.2　建模的简单性
1.2.3　异步事件的简化处理
1.2.4　响应更灵敏的用户界面
1.3　线程带来的风险
1.3.1　安全性问题
1.3.2　活跃性问题
1.3.3　性能问题
1.4　线程无处不在
第一部分　基础知识
第2章　线程安全性
2.1　什么是线程安全性
2.2　原子性
2.2.1　竞态条件
2.2.2　示例：延迟初始化中的竞态条件
2.2.3　复合操作
2.3　加锁机制
2.3.1　内置锁
2.3.2　重入
2.4　用锁来保护状态
2.5　活跃性与性能
第3章　对象的共享
3.1　可见性
3.1.1　失效数据
3.1.2　非原子的64位操作
3.1.3　加锁与可见性
3.1.4　Volatile变量
3.2　发布与逸出
3.3　线程封闭
3.3.1　Ad-hoc线程封闭
3.3.2　栈封闭
3.3.3　ThreadLocal类
3.4　不变性
3.4.1　Final域
3.4.2　示例：使用Volatile类型来发布不可变对象
3.5　安全发布
3.5.1　不正确的发布：正确的对象被破坏
3.5.2 　不可变对象与初始化安全性
3.5.3　安全发布的常用模式
3.5.4　事实不可变对象
3.5.5　可变对象
3.5.6　安全地共享对象
第4章　对象的组合
4.1　设计线程安全的类
4.1.1　收集同步需求
4.1.2　依赖状态的操作
4.1.3　状态的所有权
4.2　实例封闭
4.2.1　Java监视器模式
4.2.2　示例：车辆追踪
4.3　线程安全性的委托
4.3.1　示例：基于委托的车辆追踪器
4.3.2　独立的状态变量
4.3.3　当委托失效时
4.3.4　发布底层的状态变量
4.3.5　示例：发布状态的车辆追踪器
4.4　在现有的线程安全类中添加功能
4.4.1　客户端加锁机制
4.4.2　组合
4.5　将同步策略文档化
第5章　基础构建模块
5.1　同步容器类
5.1.1　同步容器类的问题
5.1.2　迭代器与Concurrent-ModificationException
5.1.3　隐藏迭代器
5.2　并发容器
5.2.1　ConcurrentHashMap
5.2.2　额外的原子Map操作
5.2.3　CopyOnWriteArrayList
5.3　阻塞队列和生产者-消费者模式
5.3.1　示例：桌面搜索
5.3.2　串行线程封闭
5.3.3　双端队列与工作密取
5.4　阻塞方法与中断方法
5.5　同步工具类
5.5.1　闭锁
5.5.2　FutureTask
5.5.3　信号量
5.5.4　栅栏
5.6　构建高效且可伸缩的结果缓存
第二部分　结构化并发应用程序
第6章　任务执行
6.1　在线程中执行任务
6.1.1　串行地执行任务
6.1.2　显式地为任务创建线程
6.1.3　无限制创建线程的不足
6.2　Executor框架
6.2.1　示例：基于Executor的Web服务器
6.2.2　执行策略
6.2.3　线程池
6.2.4　Executor的生命周期
6.2.5　延迟任务与周期任务
6.3　找出可利用的并行性
6.3.1　示例：串行的页面渲染器
6.3.2　携带结果的任务Callable与Future
6.3.3　示例：使用Future实现页面渲染器
6.3.4　在异构任务并行化中存在的局限
6.3.5　CompletionService:Executor与BlockingQueue
6.3.6　示例：使用CompletionService实现页面渲染器
6.3.7　为任务设置时限
6.3.8　示例：旅行预定门户网站
第7章　取消与关闭
第8章　线程池的使用
第9章　图形用户界面应用程序
第三部分　活跃性、性能与测试
第10章　避免活跃性危险
第11章　性能与可伸缩性
第12章　并发程序的测试
第四部分　高级主题
第13章　显式锁
第14章　构建自定义的同步工具
第15章　原子变量与非阻塞同步机制
第16章　Java内存模型
附录A　并发性标注

```
