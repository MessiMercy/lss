
<!-- TOC -->

- [036、糟糕！运行着的线上系统突然卡死无法访问，万恶的JVM GC！](#036糟糕运行着的线上系统突然卡死无法访问万恶的jvm-gc)
    - [1、前文回顾](#1前文回顾)
    - [2、基于JVM运行的系统最怕什么？](#2基于jvm运行的系统最怕什么)
    - [3、年轻代gc到底多久一次对系统影响不大？](#3年轻代gc到底多久一次对系统影响不大)
    - [4、什么时候新生代gc对系统影响很大？](#4什么时候新生代gc对系统影响很大)
    - [5、如何解决大内存机器的新生代GC过慢的问题？](#5如何解决大内存机器的新生代gc过慢的问题)
    - [6、要命的频繁老年代gc问题](#6要命的频繁老年代gc问题)
    - [7、JVM性能优化到底在优化什么？](#7jvm性能优化到底在优化什么)
- [037、大厂面试题：解释一下什么是Young GC和Full GC？](#037大厂面试题解释一下什么是young-gc和full-gc)
    - [（1）Minor GC / Young GC](#1minor-gc--young-gc)
    - [（2）Full GC？Old GC？傻傻分不清楚](#2full-gcold-gc傻傻分不清楚)
    - [（3）Full GC](#3full-gc)
    - [（4）Major GC[尽量不用]](#4major-gc尽量不用)
    - [（5）Mixed GC](#5mixed-gc)
- [038、大厂面试题：Young GC和Full GC分别在什么情况下会发生？](#038大厂面试题young-gc和full-gc分别在什么情况下会发生)
    - [1、前文回顾](#1前文回顾-1)
    - [2、Young GC的触发时机](#2young-gc的触发时机)
    - [3、Old GC和Full GC的触发时机](#3old-gc和full-gc的触发时机)
    - [4、永久代满了之后怎么办？](#4永久代满了之后怎么办)
- [039、案例实战：每秒10万并发的BI系统是如何频繁发生Young GC的？](#039案例实战每秒10万并发的bi系统是如何频繁发生young-gc的)
    - [2、服务于百万级商家的BI系统是什么？](#2服务于百万级商家的bi系统是什么)
    - [3、刚开始上线系统时候的部署架构](#3刚开始上线系统时候的部署架构)
    - [4、技术痛点：实时自动刷新报表 + 大数据量报表](#4技术痛点实时自动刷新报表--大数据量报表)
    - [5、没什么大影响的频繁Young GC](#5没什么大影响的频繁young-gc)
    - [6、提升机器配置：运用大内存机器](#6提升机器配置运用大内存机器)
    - [7、用G1来优化大内存机器的Young GC性能](#7用g1来优化大内存机器的young-gc性能)
    - [8、本文总结](#8本文总结)
    - [9、小小思考题](#9小小思考题)
- [040、案例实战：每日百亿数据量的实时分析引擎，为啥频繁发生Full GC ？](#040案例实战每日百亿数据量的实时分析引擎为啥频繁发生full-gc-)
    - [2、一个日处理上亿数据的计算系统](#2一个日处理上亿数据的计算系统)
    - [3、这个系统到底多块会塞满新生代？](#3这个系统到底多块会塞满新生代)
    - [4、触发Minor GC的时候会有多少对象进入老年代？](#4触发minor-gc的时候会有多少对象进入老年代)
    - [5、系统运行多久，老年代大概就会填满？](#5系统运行多久老年代大概就会填满)
    - [6、这个系统运行多久，老年代会触发1次Full GC？](#6这个系统运行多久老年代会触发1次full-gc)
    - [7、该案例应该如何进行JVM优化？](#7该案例应该如何进行jvm优化)
    - [8、如果该系统的工作负载再次扩大10倍呢？](#8如果该系统的工作负载再次扩大10倍呢)
    - [9、使用大内存机器来优化上述场景](#9使用大内存机器来优化上述场景)
    - [10、本文总结](#10本文总结)
    - [11、小小思考题](#11小小思考题)
- [041、第6周作业：打开脑洞！如果你的线上系统压力增长100倍，会有频繁GC问题吗？](#041第6周作业打开脑洞如果你的线上系统压力增长100倍会有频繁gc问题吗)
- [042、第6周答疑：本周问题答疑汇总！](#042第6周答疑本周问题答疑汇总)
- [043、动手实验：自己动手模拟出频繁Young GC的场景体验一下！](#043动手实验自己动手模拟出频繁young-gc的场景体验一下)
    - [1、前文回顾](#1前文回顾-2)
    - [2、程序的JVM参数示范](#2程序的jvm参数示范)
    - [3、如何打印出JVM GC日志？](#3如何打印出jvm-gc日志)
    - [4、示例程序代码](#4示例程序代码)
    - [5、对象是如何分配在Eden区内的](#5对象是如何分配在eden区内的)
    - [6、采用指定JVM参数运行程序](#6采用指定jvm参数运行程序)
    - [自己疑问](#自己疑问)
- [044、高级工程师的硬核技能：JVM的Young GC日志应该怎么看？](#044高级工程师的硬核技能jvm的young-gc日志应该怎么看)
    - [1、前文回顾](#1前文回顾-3)
    - [2、程序运行采用的默认JVM参数如何查看？](#2程序运行采用的默认jvm参数如何查看)
    - [3、一次GC的概要说明](#3一次gc的概要说明)
    - [4、图解GC执行过程](#4图解gc执行过程)
    - [5、GC过后的堆内存使用情况](#5gc过后的堆内存使用情况)
    - [6、今日思考题](#6今日思考题)
- [045、动手实验：自己动手模拟出对象进入老年代的场景体验一下（上）](#045动手实验自己动手模拟出对象进入老年代的场景体验一下上)
    - [2、动态年龄判定规则](#2动态年龄判定规则)
    - [3、动态年龄判定规则的部分示例代码](#3动态年龄判定规则的部分示例代码)
    - [4、部分示例代码运行后产生的gc日志](#4部分示例代码运行后产生的gc日志)
    - [5、部分代码的GC日志分析](#5部分代码的gc日志分析)
    - [6、完善示例代码](#6完善示例代码)
    - [7、分析最终版的GC日志](#7分析最终版的gc日志)
    - [8、今日思考题](#8今日思考题)
    - [自己疑问](#自己疑问-1)
- [046、动手实验：自己动手模拟出对象进入老年代的场景体验一下（下）](#046动手实验自己动手模拟出对象进入老年代的场景体验一下下)
    - [1、前文回顾](#1前文回顾-4)
    - [2、示例代码](#2示例代码)
    - [3、GC日志](#3gc日志)
    - [4、一步一图来分析GC日志](#4一步一图来分析gc日志)
    - [5、本文总结](#5本文总结)
    - [6、今日思考题](#6今日思考题-1)
- [047、高级工程师的硬核技能：JVM的Full GC日志应该怎么看？](#047高级工程师的硬核技能jvm的full-gc日志应该怎么看)
    - [1、前文回顾](#1前文回顾-5)
    - [2、示例代码](#2示例代码-1)
    - [3、GC日志](#3gc日志-1)
    - [4、一步一图分析日志](#4一步一图分析日志)
    - [5、本文总结](#5本文总结-1)
    - [6、今日思考题](#6今日思考题-2)
    - [自己运行的日志](#自己运行的日志)
- [048、第7周作业：自己尝试着分析一把你们线上系统的JVM GC日志](#048第7周作业自己尝试着分析一把你们线上系统的jvm-gc日志)
- [049、第7周答疑：本周问题答疑汇总](#049第7周答疑本周问题答疑汇总)
- [050、动手实验：使用 jstat 摸清线上系统的JVM运行状况](#050动手实验使用-jstat-摸清线上系统的jvm运行状况)
    - [1、前文回顾](#1前文回顾-6)
    - [2、功能强大的jstat](#2功能强大的jstat)
    - [3、jstat -gc PID](#3jstat--gc-pid)
    - [4、其他的jstat命令](#4其他的jstat命令)
    - [5、到底该如何使用jstat工具？](#5到底该如何使用jstat工具)
    - [6、新生代对象增长的速率](#6新生代对象增长的速率)
    - [7、Young GC的触发频率和每次耗时](#7young-gc的触发频率和每次耗时)
    - [8、每次Young GC后有多少对象是存活和进入老年代](#8每次young-gc后有多少对象是存活和进入老年代)
    - [9、Full GC的触发时机和耗时](#9full-gc的触发时机和耗时)
    - [10、本文总结](#10本文总结-1)
    - [11、今日思考题](#11今日思考题)
- [051、动手实验：使用jmap和jhat摸清线上系统的对象分布](#051动手实验使用jmap和jhat摸清线上系统的对象分布)
    - [1、前文总结](#1前文总结)
    - [2、使用jmap了解系统运行时的内存区域](#2使用jmap了解系统运行时的内存区域)
    - [3、使用jmap了解系统运行时的对象分布](#3使用jmap了解系统运行时的对象分布)
    - [4、使用jmap生成堆内存转储快照](#4使用jmap生成堆内存转储快照)
    - [5、使用jhat在浏览器中分析堆转出快照](#5使用jhat在浏览器中分析堆转出快照)
    - [6、今日思考题](#6今日思考题-3)
- [052、从测试到上线：如何分析JVM运行状况及合理优化？](#052从测试到上线如何分析jvm运行状况及合理优化)
    - [1、前文回顾](#1前文回顾-7)
    - [2、开发好系统之后的预估性优化](#2开发好系统之后的预估性优化)
    - [3、系统压测时的JVM优化](#3系统压测时的jvm优化)
    - [4、对线上系统进行JVM监控](#4对线上系统进行jvm监控)
    - [5、今日思考题](#5今日思考题)
- [053、案例实战：每秒10万并发的BI系统，如何定位和解决频繁Young GC问题？](#053案例实战每秒10万并发的bi系统如何定位和解决频繁young-gc问题)
    - [06、模拟代码的JVM参数设置](#06模拟代码的jvm参数设置)
    - [07、示例程序](#07示例程序)
    - [08、如何在windows上执行命令？](#08如何在windows上执行命令)
    - [09、通过jstat观察程序的运行状态](#09通过jstat观察程序的运行状态)
    - [10、今日思考题](#10今日思考题)
    - [自己运行结果](#自己运行结果)
- [054、案例实战：每日百亿数据量的实时分析引擎，如何定位和解决频繁Full GC问题？](#054案例实战每日百亿数据量的实时分析引擎如何定位和解决频繁full-gc问题)
    - [8、运行程序用的示例JVM参数](#8运行程序用的示例jvm参数)
    - [9、示例程序](#9示例程序)
    - [10、基于jstat分析程序运行的状态](#10基于jstat分析程序运行的状态)
    - [11、对JVM性能进行优化](#11对jvm性能进行优化)
    - [12、今日思考题](#12今日思考题)
    - [自己实践](#自己实践)
- [055、第8周作业](#055第8周作业)
- [056、第8周答疑：本周问题答疑汇总](#056第8周答疑本周问题答疑汇总)
- [057、案例实战：每秒十万QPS的社交APP 如何优化GC性能提升3倍？](#057案例实战每秒十万qps的社交app-如何优化gc性能提升3倍)
- [058、案例实战：垂直电商APP后台系统，如何对Full GC进行深度优化？](#058案例实战垂直电商app后台系统如何对full-gc进行深度优化)
- [059、案例实战：新手工程师不合理设置JVM参数，是如何导致频繁Full GC的？](#059案例实战新手工程师不合理设置jvm参数是如何导致频繁full-gc的)
- [060、案例实战：一次线上系统每天数十次Full GC导致频繁卡死的优化实战！](#060案例实战一次线上系统每天数十次full-gc导致频繁卡死的优化实战)
- [061、案例实战：电商大促活动下，严重Full GC导致系统直接卡死的优化实战](#061案例实战电商大促活动下严重full-gc导致系统直接卡死的优化实战)
- [062、第9周作业](#062第9周作业)
- [063、第9周答疑以及学员思考题总结汇总](#063第9周答疑以及学员思考题总结汇总)
- [064、案例实战：一次线上大促营销活动导致的内存泄漏和Full GC优化](#064案例实战一次线上大促营销活动导致的内存泄漏和full-gc优化)
- [065、案例实战：百万级数据误处理导致的频繁Full GC问题优化](#065案例实战百万级数据误处理导致的频繁full-gc问题优化)
- [066、阶段性复习：JVM运行原理和GC原理你真的搞懂了吗？](#066阶段性复习jvm运行原理和gc原理你真的搞懂了吗)
- [067、阶段性复习：JVM性能优化到底该怎么做？](#067阶段性复习jvm性能优化到底该怎么做)
- [068、如何为你的面试准备自己负责的系统中的JVM优化案例？](#068如何为你的面试准备自己负责的系统中的jvm优化案例)
- [069、关于作业的说明](#069关于作业的说明)
- [070、第10周答疑汇总](#070第10周答疑汇总)
- [071、Java程序员的梦魇：线上系统突然挂掉，可怕的OOM内存溢出！](#071java程序员的梦魇线上系统突然挂掉可怕的oom内存溢出)
    - [1、Java程序员的梦魇：线上系统突然挂掉](#1java程序员的梦魇线上系统突然挂掉)
    - [2、Java程序员平时最常遇到的故障：系统OOM](#2java程序员平时最常遇到的故障系统oom)
    - [3、很多工程师都不知道如何处理OOM](#3很多工程师都不知道如何处理oom)
- [072、大厂面试题：什么是内存溢出？在哪些区域会发生内存溢出？](#072大厂面试题什么是内存溢出在哪些区域会发生内存溢出)
    - [1、前言](#1前言)
    - [2、运行一个Java系统就是运行一个JVM进程](#2运行一个java系统就是运行一个jvm进程)
    - [3、到底执行哪些代码：JVM得加载你写的类](#3到底执行哪些代码jvm得加载你写的类)
    - [4、Java虚拟机栈：让线程执行各种方法](#4java虚拟机栈让线程执行各种方法)
    - [5、堆内存：放我们创建的各种对象](#5堆内存放我们创建的各种对象)
    - [6、本文总结](#6本文总结)
- [073、Metaspace区域是如何因为类太多而发生内存溢出的？](#073metaspace区域是如何因为类太多而发生内存溢出的)
    - [1、前文回顾](#1前文回顾-8)
    - [2、Metaspace区域是如何触发内存溢出的？](#2metaspace区域是如何触发内存溢出的)
    - [3、到底什么情况下会发生Metaspace内存溢出？](#3到底什么情况下会发生metaspace内存溢出)
    - [4、本文总结](#4本文总结)
- [074、无限制的调用方法是如何让线程的栈内存溢出的？](#074无限制的调用方法是如何让线程的栈内存溢出的)
    - [1、前文回顾](#1前文回顾-9)
    - [2、一个线程调用多个方法的入栈和出栈](#2一个线程调用多个方法的入栈和出栈)
    - [3、一个重要的概念：每次方法调用的栈桢都是要占用内存的](#3一个重要的概念每次方法调用的栈桢都是要占用内存的)
    - [4、到底什么情况下会导致JVM中的栈内存溢出？](#4到底什么情况下会导致jvm中的栈内存溢出)
    - [5、一般什么情况下会发生栈内存溢出？](#5一般什么情况下会发生栈内存溢出)
    - [6、今日文章总结](#6今日文章总结)
- [075、对象太多了！堆内存实在是放不下，只能内存溢出！](#075对象太多了堆内存实在是放不下只能内存溢出)
    - [1、前文回顾](#1前文回顾-10)
    - [2、从对象在Eden区分配开始讲起](#2从对象在eden区分配开始讲起)
    - [3、高并发场景下导致ygc后存活对象太多](#3高并发场景下导致ygc后存活对象太多)
    - [4、什么时候会发生堆内存的溢出？](#4什么时候会发生堆内存的溢出)
    - [5、本文总结](#5本文总结-2)
- [076、动手实验：自己模拟出JVM Metaspace内存溢出的场景体验一下！](#076动手实验自己模拟出jvm-metaspace内存溢出的场景体验一下)
    - [2、Metaspace内存溢出原理回顾](#2metaspace内存溢出原理回顾)
    - [3、到底什么是动态生成类？](#3到底什么是动态生成类)
    - [4、一段CGLIB动态生成类的代码示例](#4一段cglib动态生成类的代码示例)
    - [5、限制Metaspace大小看看内存溢出效果](#5限制metaspace大小看看内存溢出效果)
    - [自己试验](#自己试验)
- [077、动手实验：自己模拟出JVM栈内存溢出的场景体验一下！](#077动手实验自己模拟出jvm栈内存溢出的场景体验一下)
- [078、动手实验：自己模拟出JVM堆内存溢出的场景体验一下！](#078动手实验自己模拟出jvm堆内存溢出的场景体验一下)
- [079、案例实战：一个超大数据量处理系统是如何不堪重负OOM的？](#079案例实战一个超大数据量处理系统是如何不堪重负oom的)
    - [1、前文回顾](#1前文回顾-11)
    - [2、还是那个超大数据量处理系统的案例](#2还是那个超大数据量处理系统的案例)
    - [3、针对Kafka故障设计的高可用场景](#3针对kafka故障设计的高可用场景)
    - [4、无法释放的内存最终导致OOM](#4无法释放的内存最终导致oom)
- [080、案例实战：两个新手工程师误写代码是如何导致OOM的？](#080案例实战两个新手工程师误写代码是如何导致oom的)
    - [1、前文回顾](#1前文回顾-12)
    - [2、第一个案例：一时迷糊写出了一个无限循环调用](#2第一个案例一时迷糊写出了一个无限循环调用)
    - [3、第二个案例：没有缓存的动态代理](#3第二个案例没有缓存的动态代理)
    - [4、本文总结](#4本文总结-1)
- [081、如何对对线上系统的OOM异常进行监控和报警！](#081如何对对线上系统的oom异常进行监控和报警)
    - [1、前文回顾](#1前文回顾-13)
    - [2、最佳的解决方案](#2最佳的解决方案)
    - [3、一个比较成熟的系统监控体系的建议](#3一个比较成熟的系统监控体系的建议)
    - [4、一种比较Low的JVM OOM问题的被动发现方法](#4一种比较low的jvm-oom问题的被动发现方法)
    - [5、本文总结](#5本文总结-3)
- [082、一个关键问题：如何在JVM内存溢出的时候自动dump内存快照？](#082一个关键问题如何在jvm内存溢出的时候自动dump内存快照)
    - [2、解决OOM问题的一个初步思路](#2解决oom问题的一个初步思路)
    - [3、在OOM的时候自动dump内存快照](#3在oom的时候自动dump内存快照)
    - [4、迄今为止我们可以得出的一份JVM参数模板](#4迄今为止我们可以得出的一份jvm参数模板)
- [083、动手实验：Metaspace区域内存溢出的时候，应该如何解决？](#083动手实验metaspace区域内存溢出的时候应该如何解决)
    - [1、前文回顾](#1前文回顾-14)
    - [2、示例代码](#2示例代码-2)
    - [3、分析GC日志](#3分析gc日志)
    - [4、分析内存快照](#4分析内存快照)
    - [5、本文总结](#5本文总结-4)
    - [自己运行日志分析](#自己运行日志分析)
- [084、动手实验：JVM栈内存溢出的时候，应该如何解决？](#084动手实验jvm栈内存溢出的时候应该如何解决)
- [085、动手实验：JVM堆内存溢出的时候，应该如何解决？](#085动手实验jvm堆内存溢出的时候应该如何解决)

<!-- /TOC -->


# 036、糟糕！运行着的线上系统突然卡死无法访问，万恶的JVM GC！

## 1、前文回顾

第六周的内容是对JVM GC相关的内容做一个总结，梳理出来一些名词的清晰的含义，做一个承上启下的作用，引出后面几周的JVM纯实战内容。

从第七周开始，就会对JVM优化进行实操，带着大家动手去模拟出来各种生产故障，然后通过各种工具以及JVM GC日志，去学习如何排查、定位和解决JVM的性能问题。

## 2、基于JVM运行的系统最怕什么？

通过之前的学习相信大家现在都能理解一个点，就是在JVM运行的时候，最核心的内存区域，其实就是堆内存，在这里会放各种我们系统中创建出来的对象。

而且堆内存里通常都会划分为新生代和老年代两个内存区域，对象一般来说都是优先放在新生代的，如下图所示。

![](../../pic/2020-03-07-23-37-28.png)

接着随着系统不停的运行，一定会导致越来越多的对象放入年轻代中，然后年轻代都快塞满了，放不下更多的对象了，毕竟内存都是有限的。

这个时候你就必须清理一下年轻代的垃圾对象，也就是那些没有GC Roots引用的对象。

大家都知道，所谓的GC Roots就是类的静态变量，方法的局部变量。

平时我们最经常创建对象的地方，就是在方法里，但是一旦一个方法运行完毕之后，方法的局部变量就没了，此时之前在方法里创建出来的对象就是垃圾了，没人引用了。所以在咱们的年轻代里，其实99%都是这种没人引用的垃圾对象。

在年轻代（也可以叫做新生代）快要塞满的时候，就会触发年轻代gc，也就是对年轻代进行垃圾回收，需要把年轻代里的垃圾对象都给回收掉。

那么到底怎么回收呢？

其实我们通过之前的学习，都很清楚，会通过复制算法进行回收，通常来说新生代会有一块Eden区域用来创建对象，默认占据80%的内存，还有两块Survivor区域用来放垃圾回收后存活下来的对象，分别占据10%的内存，如下图所示。

![](../../pic/2020-03-07-23-40-57.png)

而且大家要注意一点，一旦要对新生代进行垃圾回收了，此时一定会停止系统程序的运行，不让系统程序执行任何代码逻辑了，这个叫做“Stop the World”。

此时只能允许后台的垃圾回收器的多个垃圾回收线程去工作，执行垃圾回收，如下图。

![](../../pic/2020-03-07-23-42-42.png)

所谓的复制算法，说白了，就是对所有的GC Roots进行追踪，去标记出来所有被GC Roots直接或者间接引用的对象，他们就是存活对象

比如上图中大家可以看到有一个类的静态变量就引用了一个对象，那个对象就是存活对象。

接着就会把存活对象都转移到一块Survivor区域里去，如上图，就把存活的对象转移到一块Survivor区域里去了。

接着就会直接把Eden区里的剩下的垃圾对象全部回收掉，释放内存空间，然后恢复系统程序的运行，如下图。

![](../../pic/2020-03-07-23-43-42.png)

看到这里，要给大家说第一个重点了，不知道大家发现了没有，这里有一个很大的问题，就是每次一旦年轻代塞满之后，在进行垃圾回收的时候，这个期间都必须停止系统程序的运行！

这个就是基于JVM运行的系统最害怕的问题：**系统卡顿问题！**

假设一次年轻代垃圾回收需要20ms，那么就意味着在这20ms内，系统是无法工作的，此时用户对系统发送的请求，在这20ms内是无法处理的，需要卡住20ms，如下图所示。

![](../../pic/2020-03-07-23-45-11.png)

## 3、年轻代gc到底多久一次对系统影响不大？

那么现在有一个问题，年轻代gc对系统的性能影响到底大不大？

其实通常来说是不大的，不知道大家发现没有，其实年轻代gc几乎没什么好调优的，因为他的运行逻辑非常简单，就是Eden一旦满了无法放新对象就触发一次gc。

一般来说，真要说对年轻代的gc进行调优，只要你给系统分配足够的内存即可，核心点还是在于堆内存的分配、新生代内存的分配

内存足够的话，通常来说系统可能在低峰时期在几个小时才有一次新生代gc，高峰期最多也就几分钟一次新生代gc。

而且一般的业务系统都是部署在2核4G或者4核8G的机器上，此时分配给堆的内存不会超过3G，给新生代中的Eden区的内存也就1G左右。

而且新生代采用的复制算法效率极高，因为新生代里存活的对象很少，只要迅速标记出这少量存活对象，移动到Survivor区，然后回收掉其他全部垃圾对象即可，速度很快。

很多时候，一次新生代gc可能也就耗费几毫秒，几十毫秒。大家设想一下，假如说你的系统运行着，然后每隔几分钟或者几十分钟执行一次新生代gc，系统卡顿几十毫秒，就这期间的请求会卡顿几十毫秒，几乎用户都是无感知的，所以新生代gc一般基本对系统性能影响不大。

## 4、什么时候新生代gc对系统影响很大？

简单，当你的系统部署在大内存机器上的时候，比如说你的机器是32核64G的机器，此时你分配给系统的内存有几十个G，新生代的Eden区可能30G~40G的内存。

此时如果你的系统负载非常的高，对于大数据系统是很有可能的，比如每秒几万的访问请求到Kafka、Elasticsearch上去。

那么可能导致你Eden区的几十G内存频繁塞满要触发垃圾回收，假设1分钟会塞满一次。

然后每次垃圾回收要停顿掉Kafka、Elasticsearch的运行，然后执行垃圾回收大概需要几秒钟，此时你发现，可能每过一分钟，你的系统就要卡顿几秒钟，有的请求一旦卡死几秒钟就会超时报错，此时可能会导致你的系统频繁出错。

## 5、如何解决大内存机器的新生代GC过慢的问题？

那么如何解决这种几十G的大内存机器的新生代GC过慢的问题呢？**用G1垃圾回收器**

大家都知道，我们针对G1垃圾回收器，可以设置一个期望的每次GC的停顿时间，比如我们可以设置一个20ms。

那么G1基于他的Region内存划分原理，就可以在运行一段时间之后，比如就针对2G内存的Region进行垃圾回收，此时就仅仅停顿20ms，然后回收掉2G的内存空间，腾出来了部分内存，接着还可以继续让系统运行。

G1天生就适合这种大内存机器的JVM运行，可以完美解决大内存垃圾回收时间过长的问题。

## 6、要命的频繁老年代gc问题

综上所述，其实新生代gc一般问题不会太大，但是真正问题最大的地方，在于频繁触发老年代的GC。

之前给大家讲过对象进入老年代的几个条件：年龄太大了、动态年龄判断规则、新生代gc后存活对象太多无法放入Survivor中。

给大家重新分析一下这几个条件。

- 1、对象年龄太大了，这种对象一般很少，都是系统中确实需要长期存在的核心组件，他们一般不需要被回收掉，所以在新生代熬过默认15次垃圾回收之后就会进入老年代。

- 2、动态年龄判定规则，如果一次新生代gc过后，发现Survivor区域中的几个年龄的对象加起来超过了Survivor区域的50%，比如说年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区域的50%，此时就会把年龄3以上的对象都放入老年代。

- 3、新生代垃圾回收过后，存活对象太多了，无法放入 Surviovr中，此时直接进入老年代。

其实上述条件中，第二个和第三个都是很关键的，通常如果你的新生代中的Survivor区域内存过小，就会导致上述第二个和第三个条件频繁发生，然后导致大量对象快速进入老年代，进而频繁触发老年代的gc

![](../../pic/2020-03-07-23-57-06.png)

老年代gc通常来说都很耗费时间，无论是CMS垃圾回收器还是G1垃圾回收器，因为比如说CMS就要经历初始标记、并发标记、重新标记、并发清理、碎片整理几个环节，过程非常的复杂，G1同样也是如此。

通常来说，老年代gc至少比新生代gc慢10倍以上，比如新生代gc每次耗费200ms，其实对用户影响不大，但是老年代每次gc耗费2s，那可能就会导致老年代gc的时候用户发现页面上卡顿2s，影响就很大了。

所以一旦你因为jvm内存分配不合理，导致频繁进行老年代gc，比如说几分钟就有一次老年代gc，每次gc系统都停顿几秒钟，那简直对你的系统就是致命的打击。此时用户会发现页面上或者APP上经常性的出现点击按钮之后卡顿几秒钟。

## 7、JVM性能优化到底在优化什么？

所以这篇文章一个承上启下的结论就出现了，其实说白了，系统真正最大的问题，就是因为内存分配、参数设置不合理，导致你的对象频繁的进入老年代，然后频繁触发老年代gc，导致系统频繁的每隔几分钟就要卡死几秒钟。




# 037、大厂面试题：解释一下什么是Young GC和Full GC？

不知道大家注意到没有，在之前我们的文章中出现了很多名词：Minor GC、Young GC、Full GC、Old GC、Major GC、Mixed GC。

其实说实话，这些名词在业内也并没有完全标准而且统一的定义，甚至在不同的书里，不同的文章里，对同一个名词的定义都是不一样的。所以我们也是尽量给大家把这些名词的含义区分开来。

此外在面试中，这些名词也会经常被问到，面试官很有可能会考一下你对这些名词的理解

但是有可能会出现你的理解和面试官的理解是不同的，所以大家切记切记，在面试的时候回答此类问题，一定要对一个名词可能有的多种不同的理解都给出说明，避免双方理解的歧义。

## （1）Minor GC / Young GC

首先我们先来看最简单的名词，Minor GC / Young GC，这个非常好理解，大家都知道，“新生代”也可以称之为“年轻代”，这两个名词是等价的。那么在年轻代中的Eden内存区域被占满之后，实际上就需要触发年轻代的gc，或者是新生代的gc。

此时这个新生代gc，其实就是所谓的“Minor GC”，也可以称之为“Young GC”，这两个名词，相信大家就理解了，说白了，就专门针对新生代的gc。

## （2）Full GC？Old GC？傻傻分不清楚

之前给大家分析的时候，一直是说老年代一旦被占满之后，就会触发老年代的gc，之前称呼这种GC为Full GC。

所以之前就有同学提出异议了，有人觉得老年代的gc怎么能叫做Full GC呢？他并不是这个含义啊

其实所谓的老年代gc，称之为“Old GC”更加合适一些，因为从字面意义上就可以理解，这就是所谓的老年代gc。

但是在这里之所以我们把老年代GC称之为Full GC，其实也是可以的，只不过是一个字面意思的多种不同的说法。

为了更加精准的表述这个老年代gc的含义，我们从现在开始，一律把老年代gc称之为Old GC，后续也如此定义。

所以在这里，大家务必捋清这个概念，在跟面试官聊的时候，如果说到所谓的老年代gc，为了避免歧义，建议大家用Old GC来指代。


## （3）Full GC

对于Full GC，其实这里有一个更加合适的说法，就是说Full GC指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为Full GC。

从字面意思上也可以理解，“Full”就是整体的意思，所以就是对JVM进行一次整体的垃圾回收，把各个内存区域的垃圾都回收掉。

但是说实话，不同的名词如何定义每个人都有自己的看法，有些人，包括我自己，平时有一定的习惯是把Full GC直接等价为Old GC的，也就是仅仅针对老年代的垃圾回收。

但是如果从字面意义上来理解，建议大家日后在外面跟别人交谈的时候，把Full GC理解为针对JVM内所有内存区域的一次整体垃圾回收。


## （4）Major GC[尽量不用]

还有一个名词是所谓的Major GC，这个其实一般用的比较少，他也是一个非常容易混淆的概念

有些人把Major GC跟Old GC等价起来，认为他就是针对老年代的GC，也有人把Major GC和Full GC等价起来，认为他是针对JVM全体内存区域的GC。

所以针对这个容易混淆的概念，建议大家以后少提。如果听到有人说这个Major GC的概念，大家可以问清楚，他到底是想说Old GC呢？还是Full GC呢？


## （5）Mixed GC

Mixed GC是G1中特有的概念，其实说白了，主要就是说在G1中，一旦老年代占据堆内存的45%了，就要触发Mixed GC，此时对年轻代和老年代都会进行回收。这个概念很好理解，大家只要知道是G1中特有的名词即可。


# 038、大厂面试题：Young GC和Full GC分别在什么情况下会发生？

## 1、前文回顾

统一用Young GC指代年轻代gc，用Old GC指代老年代GC，用Full GC指代年轻代、老年代、永久代共同的gc

## 2、Young GC的触发时机

其实之前几周的文章里，我们已经分析的很清楚了，Young GC其实一般就是在新生代的Eden区域满了之后就会触发，采用复制算法来回收新生代的垃圾

所以Young GC的触发时机，我觉得所有跟到现在的同学，闭着眼睛都能说出来了。

## 3、Old GC和Full GC的触发时机

其实之前的文章里也对Old GC的触发时机说的很清晰了，简而言之就是下面几种情况：

- （1）发生Young GC之前进行检查，如果“老年代可用的连续内存空间” < “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间。此时必须先触发一次Old GC给老年代腾出更多的空间，然后再执行Young GC。

- （2）执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Old GC。

- （3）老年代内存使用率超过了92%，也要直接触发Old GC，当然这个比例是可以通过参数调整的。

其实说白了，上述三个条件你概括成一句话，就是老年代空间也不够了，没法放入更多对象了，这个时候务必执行Old GC对老年代进行垃圾回收。

可能很多人不理解，其实如果你把咱们这里的几个条件分析清楚了就知道了，一般Old GC很可能就是在Young GC之前触发或者在Young GC之后触发的，所以自然Old GC一般都会跟一次Young GC连带关联在一起了。

另外一个，在很多JVM的实现机制里，其实在上述几种条件达到的时候，他触发的实际上就是Full GC，这个Full GC会包含Young GC、Old GC和永久代的GC

也就是说触发Full GC的时候，可能就会去回收年轻代、老年代和永久代三个区域的垃圾对象。

下周开始我们进入JVM实操环节，会带大家用各种代码模拟出各种场景，然后观察JVM GC日志

大家会看到，其实满足上述一些条件的时候，在GC日志中看到的就是Full GC的字样，同时在Full GC中大家会看到同时对年轻代、老年代、永久代都进行了垃圾回收。

但是这个东西其实没办法给大家一个准确的定义，说到底触发Full GC的时候，是先执行Young GC？还是先执行Old GC。

因为不同的Full GC触发条件其实是不一样的，而且不同的JVM版本的实现机制也不同。

所以很多时候，我们也只能给大家笼统的概括一句：上述条件满足时触发Full GC，Full GC一般会带上一次Young GC去回收新生代，同时也会有Old GC也回收老年代，还会去回收永久代。

## 4、永久代满了之后怎么办？

大家现在既然都知道了，Full GC有上述几个触发条件，同时触发Full GC的时候其实会带上针对新生代的Young GC，也会有针对老年代的Full GC，还会有针对永久代的GC。所以假如存放类信息、常量池的永久代满了之后，就会触发一次Full GC。

这样Full GC执行的时候，就会顺带把永久代中的垃圾给回收了，但是永久代中的垃圾一般是很少的，因为里面存放的都是一些类，还有常量池之类的东西，这些东西通常来说是不需要回收的。如果永久代真的放满了，回收之后发现没腾出来更多的地方，此时只能抛出内存不够的异常了。




# 039、案例实战：每秒10万并发的BI系统是如何频繁发生Young GC的？


## 2、服务于百万级商家的BI系统是什么？

简单来说，比如你是一个平台，然后有数十万甚至上百万的商家在你的平台上做生意，会使用你的这个平台系统

此时一定会产生大量的数据，然后基于这些数据我们需要为商家提供一些数据报表，比如：每个商家每天有多少访客？有多少交易？付费转化率是多少？

所谓BI，英文全称是“Business Intelligence”，也就是“商业智能”，听起来是不是特别的高大上？

其实也别想的太高大上了，说白了，就是把一些商家平时日常经营的数据收集起来进行分析，然后把各种数据报表展示给商家的一套系统。

所谓“商务智能”，指的就是给你看一些数据报表，然后让你平时能够更好的了解自己的经营状况，然后让老板“智能”的去调整经营策略，提升业绩。

所以类似这样的一个BI系统，大致的运行逻辑如下所示，首先从我们提供给商家日常使用的一个平台上会采集出来很多商家日常经营的数据，如下图所示。

![](../../pic/2020-03-08-09-53-12.png)

接着就可以对这些经营数据依托各种大数据计算平台，比如Hadoop、Spark、Flink等技术进行海量数据的计算，计算出来各种各样的数据报表，如下图所示。

![](../../pic/2020-03-08-09-53-47.png)

然后我们需要将计算好的各种数据分析报表都放入一些存储中，比如说MySQL、Elastcisearch、HBase都可以存放类似的数据，如下图所示。

![](../../pic/2020-03-08-09-54-31.png)

最后一步，就是基于MySQL、HBase、Elasticsearch中存储的数据报表，基于Java开发出来一个BI系统，通过这个系统把各种存储好的数据暴露给前端，允许前端基于各种条件对存储好的数据进行复杂的筛选和分析，如下图所示。

![](../../pic/2020-03-08-09-56-22.png)

## 3、刚开始上线系统时候的部署架构

我们在这里重点作为案例分析的就是上述场景中的BI系统，其他环节都跟大数据相关的技术是有关联的，我们暂时先不涉及，未来有机会可以给大家出更多的课程来阐述那些技术。

刚开始的时候，这个BI系统使用的商家是不多的。因为大家要知道，即使在一个庞大的互联网大厂里，虽然说大厂本身积累了大量的商家，但是你要是针对他们上线一个付费的产品，刚开始未必所有人都买账，所以一开始系统上线大概就少数商家在使用，比如就几千个商家。

所以刚开始系统部署的非常简单，就是用几台机器来部署了上述的BI系统，机器都是普通的4核8G的配置，然后在这个配置之下，一般来说给堆内存中的新生代分配的内存都在1.5G左右，Eden区大概也就1G左右的空间

![](../../pic/2020-03-08-09-59-10.png)

## 4、技术痛点：实时自动刷新报表 + 大数据量报表

其实刚开始，在少数商家的量级之下，这个系统是没多大问题的，运行的非常良好，但是问题恰恰就出在突然使用系统的商家数量开始暴涨的时候。

突然使用系统的商家开始越来越多，比如给大家举个例子，当商家的数量级达到几万的时候。

此时要给大家说明一个此类BI系统的特点，就是在BI系统中有一种数据报表，他是支持前端页面有一个JS脚本，自动每隔几秒钟就发送请求到后台刷新一下数据的，这种报表称之为“实时数据报表”，如下图所示。

![](../../pic/2020-03-08-10-00-33.png)

那么大家可以设想一下，假设仅仅就几万商家作为你的系统用户，很可能同一时间打开那个实时报表的商家就有几千个

然后每个商家打开实时报表之后，前端页面都会每隔几秒钟发送请求到后台来加载最新数据，基本上会出现你BI系统部署的每台机器每秒的请求会达到几百个，我们假设就是每秒500个请求吧。

然后每个请求会加载出来一张报表需要的大量数据，因为BI系统可能还需要针对那些数据进行内存中的现场计算加工一下，才能返回给前端页面展示。

根据我们之前的测算，每个请求大概需要加载出来100kb的数据进行计算，因此每秒500个请求，就需要加载出来50MB的数据到内存中进行计算，如下图所示。

![](../../pic/2020-03-08-10-02-55.png)


## 5、没什么大影响的频繁Young GC

其实大家都已经发现上述系统的问题了，在上述系统运行模型下，基本上每秒会加载50MB的数据到Eden区中，只要区区200s，也就是3分钟左右的时间，就会迅速填满Eden区，然后触发一次Young GC对新生代进行垃圾回收。

当然1G左右的Eden进行Young GC其实速度相对是比较快的，可能也就几十ms的时间就可以搞定了

所以之前也分析过，其实对系统性能影响并不大。而且上述BI系统场景下，基本上每次Young GC后存活对象可能就几十MB，甚至是几MB。

所以如果仅仅只是这样的话，那么大家可能会看到如下场景，BI系统运行几分钟过后，就会突然卡顿个10ms，但是对终端用户和系统性能几乎是没有影响的，如下图。

![](../../pic/2020-03-08-10-05-07.png)

## 6、提升机器配置：运用大内存机器

针对这样的一套系统，后来随着越来越多的商家来使用，并发压力越来越大，甚至高峰期会有每秒10万的并发压力

大家想想，如果还是用4核8G的机器来支撑，那么可能需要部署上百台机器来抗住每秒10万的高并发压力。

所以一般针对这种情况，我们会提升机器的配置，本身BI系统就是非常吃内存的系统，所以我们将部署的机器全面提升到了16核32G的高配置机器上去。每台机器可以抗个每秒几千请求，此时只要部署比如二三十台机器就可以了。

但是此时问题就来了，大家可以想一下，如果要是用大内存机器的话，那么新生代至少会分配到20G的大内存，Eden区也会占据16G以上的内存空间，此时如下图所示。

![](../../pic/2020-03-08-10-08-28.png)

此时每秒几千请求的话，每秒大概会加载到内存中几百MB的数据，那么大概可能几十秒，甚至1分钟左右就会填满Eden区，会就需要执行Young GC。

此时Young GC要回收那么大的内存，速度会慢很多，也许此时就会导致系统卡顿个几百毫秒，或者1秒钟，如下图所示。

![](../../pic/2020-03-08-10-09-18.png)

那么你要是系统卡顿时间过长，必然会导致瞬间很多请求积压排队，严重的时候会导致线上系统时不时出现前端请求超时的问题，就是前端请求之后发现一两秒后还没返回就超时报错了。

## 7、用G1来优化大内存机器的Young GC性能

所以当时对这个系统的一个优化，就是**采用G1垃圾回收器**来应对大内存的Young GC过慢的问题

对G1设置一个预期的GC停顿时间，比如100ms，让G1保证每次Young GC的时候最多停顿100ms，避免影响终端用户的使用。

此时效果是非常显著的，G1会自动控制好在每次Young GC的时候就回收一部分Region，确保GC停顿时间控制在100ms以内

这样的话，也许Young GC的频率会更高一些，但是每次停顿时间很小，这样对系统影响就不大了。


## 8、本文总结

本文用一个案例，其实就想给大家说明一个问题，那就是通常Young GC哪怕发生的频繁一些，其实一般都对系统造成不了太大的影响

只有在你机器内存特别大的时候，要注意Young GC也可能会导致比较长时间的停顿，此时针对大内存机器通常建议采用G1垃圾回收器

## 9、小小思考题

看到这里，给大家留一个小思考题，去想办法看看自己线上系统：

- 多长时间发生一次Young GC？
- Young GC耗时多久？
- 然后你觉得它对你的系统影响大吗？



# 040、案例实战：每日百亿数据量的实时分析引擎，为啥频繁发生Full GC ？


## 2、一个日处理上亿数据的计算系统

先给大家说一下这个系统的案例背景，大概来说是当时我们团队里自己研发的一个数据计算系统，日处理数据量在上亿的规模。

简单来说，这个系统就是会不停的从MySQL数据库以及其他数据源里提取大量的数据加载到自己的JVM内存里来进行计算处理，如下图所示。

![](../../pic/2020-03-08-10-15-07.png)

这个数据计算系统会不停的通过SQL语句和其他方式，从各种数据存储中提取数据到内存中来进行计算，大致当时的生产负载是每分钟大概需要执行500次数据提取和计算的任务。

但是这是一套分布式运行的系统，所以生产环境部署了多台机器，每台机器大概每分钟负责执行100次数据提取和计算的任务。

每次会提取大概1万条左右的数据到内存里来计算，平均每次计算大概需要耗费10秒左右的时间，然后每台机器是4核8G的配置，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间，大家看下图。

![](../../pic/2020-03-08-10-16-25.png)

## 3、这个系统到底多块会塞满新生代？

既然这个系统每台机器上部署的实例，每分钟会执行100次数据计算任务，每次是1万条数据需要计算10秒的时间，那么我们来看看每次1万条数据大概会占用多大的内存空间？

这里每条数据都是比较大的，大概每条数据包含了平均20个字段，可以认为平均每条数据在1KB左右的大小。那么每次计算任务的1万条数据就对应了10MB的大小。

所以大家此时可以思考一下，如果新生代是按照8:1:1的比例来分配Eden和两块Survivor的区域，那么大体上来说，Eden区就是1.2GB，每块Survivor区域在100MB左右，如下图。

![](../../pic/2020-03-08-10-18-44.png)

基本上按照这个内存大小而言，大家会发现，每次执行一个计算任务，就会在Eden区里分配10MB左右的对象，那么一分钟大概对应100次计算任务，其实基本上一分钟过后，Eden区里就全是对象，基本就全满了。

所以说，回答这个小节的问题，新生代里的Eden区，基本上1分钟左右就迅速填满了。


## 4、触发Minor GC的时候会有多少对象进入老年代？

此时假设新生代的Eden区在1分钟过后都塞满对象了，然后在接着继续执行计算任务的时候，势必会导致需要进行Minor GC回收一部分的垃圾对象。

那么上篇文章给大家讲过这里在执行Minor GC之前会先进行的检查。

首先第一步，先看看老年代的可用内存空间是否大于新生代全部对象？看下图，此时老年代是空的，大概有1.5G的可用内存空间，新生代的Eden区大概算他有1.2G的对象好了。

![](../../pic/2020-03-08-10-20-52.png)

此时会发现老年代的可用内存空间有1.5GB，新生代的对象总共有1.2GB，即使一次Minor GC过后，全部对象都存活，老年代也能放的下的，那么此时就会直接执行Minor GC了。

那么此时Eden区里有多少对象还是存活的，无法被垃圾回收呢？

大家可以考虑一下之前说的那个点，每个计算任务1万条数据需要计算10秒钟，所以假设此时80个计算任务都执行结束了，但是还有20个计算任务共计200MB的数据还在计算中

那么此时就是200MB的对象是存活的，不能被垃圾回收掉，然后有1GB的对象是可以垃圾回收的，大家看下图。

![](../../pic/2020-03-08-10-22-59.png)

此时一次Minor GC就会回收掉1GB的对象，然后200MB的对象能放入Survivor区吗？

不能！

因为任何一块Survivor区实际上就100MB的空间，此时就会通过空间担保机制，让这200MB对象直接进入老年代去，占用里面200MB内存空间，然后Eden区就清空了，大家看下图。

![](../../pic/2020-03-08-10-23-57.png)

## 5、系统运行多久，老年代大概就会填满？

按照上述计算，每分钟都是一个轮回，大概算下来是每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，然后大概都会有200MB左右的数据进入老年代。

那么大家可以想一下，假设现在2分钟运行过去了，此时老年代已经有400MB内存被占用了，只有1.1GB的内存可用，此时如果第3分钟运行完毕，又要进行Minor GC会做什么检查呢？

![](../../pic/2020-03-08-10-31-31.png)

此时会先检查老年代可用空间是否大于新生代全部对象！

此时老年代可用空间1.1GB，新生代对象有1.2GB，那么此时假设一次Minor GC过后新生代对象全部存活，老年代是放不下的，那么此时就得看看一个参数是否打开了 。

如果“-XX:-HandlePromotionFailure”参数被打开了，当然一般都会打开其实，此时会进入第二步检查，就是看看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。

我们已经计算过了，大概每分钟会执行一次Minor GC，每次大概200MB对象会进入老年代。

那么此时发现老年代的1.1GB空间，是大于每次Minor GC后平均200MB对象进入老年代的大小的，所以基本可以推测，本次Minor GC后大概率还是有200MB对象进入老年代，1.1G可用空间是足够的。

所以此时就会放心执行一次Minor GC，然后又是200MB对象进入老年代。

转折点大概在运行了7分钟过后，7次Minor GC执行过后，大概1.4G对象进入老年代，老年代剩余空间就不到100MB了，几乎快满了，如下图。

![](../../pic/2020-03-08-10-33-31.png)

## 6、这个系统运行多久，老年代会触发1次Full GC？

大概在第8分钟运行结束的时候，新生代又满了，执行Minor GC之前进行检查，此时发现老年代只有100MB内存空间了，比之前每次Minor GC后进入老年代的200MB对象要小，此时就会直接触发一次Full GC。

Full GC会把老年代的垃圾对象都给回收了，假设此时老年代被占据的1.4G空间里，全部都是可以回收的对象，那么此时一次性就会把这些对象都给回收了，如下图。

![](../../pic/2020-03-08-10-34-51.png)

然后接着就会执行Minor GC，此时Eden区情况，200MB对象再次进入老年代，之前的Full GC就是为这些新生代本次Minor GC要进入老年代的对象准备的，如下图。

![](../../pic/2020-03-08-10-35-37.png)

按照这个运行模型，基本上平均就是七八分钟一次Full GC，这个频率就相当高了。

因为每次Full GC速度都是很慢的，性能很差，而且明天的文章会告诉大家，为什么Full GC的时候会严重影响系统性能。

## 7、该案例应该如何进行JVM优化？

相信通过这个案例，大家结合图一路看下来，对新生代和老年代如何配合使用，然后什么情况下触发Minor GC和Full GC，什么情况下会导致频繁的Minor GC和Full GC，大家都有了更加深层次和透彻的理解了。

对这个系统，其实要优化也是很简单的，因为这个系统是数据计算系统，每次Minor GC的时候，必然会有一批数据没计算完毕，但是按照现有的内存模型，最大的问题，其实就是每次Survivor区域放不下存活对象。

所以当时我们就是对生产系统进行了调整，增加了新生代的内存比例，3GB左右的堆内存，其中2GB分配给新生代，1GB留给老年代，这样Survivor区大概就是200MB，每次刚好能放得下Minor GC过后存活的对象了，如下图所示。

![](../../pic/2020-03-08-10-37-50.png)

只要每次Minor GC过后200MB存活对象可以放Survivor区域，那么等下一次Minor GC的时候，这个Survivor区的对象对应的计算任务早就结束了，都是可以回收的

此时比如Eden区里1.6GB空间被占满了，然后Survivor1区里有200MB上一轮 Minor GC后存活的对象，如下图。

![](../../pic/2020-03-08-10-38-44.png)

然后此时执行Minor GC，就会把Eden区里1.4GB对象回收掉，Survivor1区里的200MB对象也会回收掉，然后Eden区里剩余的200MB存活对象会放入Survivor2区里，如下图。

![](../../pic/2020-03-08-10-39-15.png)

以此类推，基本上就很少对象会进入老年代中，老年代里的对象也不会太多的。

通过这个分析和优化，定时我们成功的把生产系统的老年代Full GC的频率从几分钟一次降低到了几个小时一次，大幅度提升了系统的性能，避免了频繁Full GC对系统运行的影响。


## 8、如果该系统的工作负载再次扩大10倍呢？

相信大家之前都看过这个案例了，这次正好借着这个机会再次重看一遍，加深一下印象，同时我们接着说当时那个生产系统在每日处理1亿数据之后，随着一段时间过后，工作负载再次扩大10倍的情景。

如果工作负载扩大10倍，那么大家参照上图来看，此时会导致每秒钟要加载100MB的数据到内存里去，对于1.6G的Eden而言，10多秒就会迅速塞满，此时就会触发Young GC。

但是之前说过，你每次加载一批数据到内存里去，一般要处理10秒以上的时间才能计算完毕，在计算完毕之前这些数据是不能被回收的。

所以如果你10多秒就触发一次Young GC，直接导致的后果就是，此时可能能回收掉的垃圾也就几百MB而言，可能1GB的对象都是无法回收的，大家仔细理解一下这个意思。

此时就会导致每隔10多秒，就有1GB的数据进入老年代中，而老年代之前给大家说过，也就1GB左右的空间而已，即使勉强让你放下了，那么下一次过10多秒之后，又会放1GB的对象到老年代，此时必然会提前触发Full GC去回收老年代里的1GB的对象，然后再让你把这次Young GC后存活的1GB对象放入老年代。

这就是当时我们遇到的真实生产场景，基本上一台4核8G的机器，每分钟要触发二三次Full GC，对系统性能造成了巨大的影响，简直是可怕至极。


## 9、使用大内存机器来优化上述场景

所以但是针对这个问题，因为考虑是计算类的系统，也是非常的吃内存的，所以同样是更换成了每台机器都是16核32G的高配置机器

这样的话，Eden基本上空间会扩大10倍，比如有16GB。

那么此时按照每秒加载100MB的数据到内存里进行计算，要2分钟左右才会触发一次Young GC，因为降低了Young GC的频率，所以每次Young GC的时候存活对象大概也就几百MB而已，不会超过1GB。

当时给Survivor区域分配的是每个Survivor有2GB内存，所以每次Young GC过后的存活对象可以轻松放入Survivor区域中，不会进入老年代。这就完美的通过提升机器配置的方式，解决了频繁Young GC和Full GC的问题。

很多同学可能会提问了，那么针对大内存机器，需要用G1来减少每次Young GC的停顿时间吗？

答案是：不用

。因为这是一个后台自动进行计算的系统，他不是直接面向用户的系统，所以哪怕每隔2分钟一次Young GC，一次要停顿1秒钟，也对系统几乎没任何影响。


## 10、本文总结

这篇文章接着之前的案例，让大家看了一下，1亿数据量级下的系统部署4核8G的机器，Full GC为何频繁发生，如何优化？10亿量级下的系统部署在4核8G的机器上，Full GC会发生的有多么的恐怖，如何通过提升机器配置来优化？

相信大家仔细看完这个案例，多看几遍，透彻理解了，多频繁Full GC问题就彻底理解了。


## 11、小小思考题

- 看看你们线上系统一般每隔多长时间发生一次Full GC？
- 每次Full GC持续多久？
- 对你们系统的性能有影响吗？


# 041、第6周作业：打开脑洞！如果你的线上系统压力增长100倍，会有频繁GC问题吗？

所以本周的作业非常简单，就是让你思考一个问题：打开脑洞，如果你当前负责的系统负载增加10倍，或者100倍，那么在有限的机器资源下，每台机器复杂都打到很高的话，此时你分析分析，Young GC的频率会如何？Full GC的频率会如何？对你们的系统性能会有影响吗？


# 042、第6周答疑：本周问题答疑汇总！

> g1和pn+cms调优原则都是尽可能ygc，不做老年代gc。 g1相对而言更加智能，也意味着jvm会用更多的资源去判断每个region的使用情况。而pn+cms也更加纯粹和直接，虽然g1在gc时不会产生碎片，但是由于每个region存在存活率85%不清理的机制，会导致内存没有充分释放问题。 因此，对于cpu性能高的，内存容量大的，对应用响应度高的系统推荐使用g1。 而内存小，cpu性能比较低下的系统也可以使用pn+cms会更合适。

> 老师，这里为什么说G1就适合大堆的情况呢？说对实时性要求高一点的可以理解，因为它有Maxpause的时间限制，但这个适合大堆的情况是怎么来理解呢

假设你有32G内存，如果用ParNew+CMS，必须等待你的内存填满了才会触发GC，此时一GC就会回收几十G的垃圾，那么速度会很慢，可能导致你的系统停顿时间多达几十秒都有可能。但是用了G1之后，他会更加频繁的回收Region，每次就回收一部分Region，保证停机时间不会太长。所以G1其实更加适合大内存的机器

> 动态对象年龄判断我有点疑惑，假设年龄为3的对象大小超过了survivor 区域的一半，年龄都为3，说明它们都是经过了3次gc存活下来的，都是从年龄为2的时候经过gc存活下来的，那在年龄为2的时候这些对象大小就应该超过survivor的一半了.同理年龄为1的时候也一样，也就是说如果有同龄的对象大小超过了survivor的一半，就只能是年龄为1的对象，而根据规则，年龄大于等于1的就得转移到老年代去了.那根据以上的推论，根本就不会出现年龄大于1的同龄对象总大小超过survivor一半的，如果有，早在年龄为1的时候这些对象就已经转移到老年代了。然后在一篇博客上看到说这是一个误区，是年龄从小到大进行累加，当加入某个年龄段后大小超过一半了，就从这个年龄段往上的年龄转移到老年代，而不是某个年龄的大小。看上去好像也挺有道理的，所以就有点疑惑。

其实是年龄1+年龄2+年龄3的对象占据了超过50%的Survivor，就会让年龄3以上的对象进入老年代，动态年龄判定规则应该是这样的

> 请问老师，动态年龄判断算法是这样么：Survivor区的对象年龄从小到大进行累加，当累加到 X 年龄时的总和大于50%（可以使用-XX:TargetSurvivorRatio=? 来设置保留多少空闲空间，默认值是50），那么比X大的都会晋升入老年代

对的，就是你说的这样


> 系统采用是g1回收器。 

- 1.如果新生代未达60%，老年代未达45%，系统照常运行，不会触发回收 

- 2.如果新生代达60%，此后如果如有新对象生成，跑到新生代，会触发ygc.

    - （1）开启了空间担保机制，ygc先判断是否需要fgc,如果每次回收后对象少于老年代空闲大小，则不用fgc,否则要 ;
    - （2）不用触发，但ygc后的对象大于老年代空闲大小，无法直接进入老年代，触发fgc. 
    - （3）触发混合回收，先通过gcroot初始标记哪些不是垃圾对象(此过程会stw,不过很快)，然后并发标记(用户线程和标记线程并行)，接着最终标记(会stw，标记并发标记过程中可能新产生的垃圾对象)，最后混合回收(此过程采用复制算法，不会产生垃圾碎片，所以不用在回收完去整理内存碎片;

g1会按照我们给定的时间去stw并回收，争取回收性价比的对象，如果回收次数少于8次，则再次混合回收。不过，在回收中空闲region大小达到堆5%，会提前结束。)如果回收失败，则转换采用serialold回收器。

- 3.当老年代代达45%会触发上面那个混合过程。


> 老师，请教下，是否有方法可以根据设定的xss的大小推算可以支撑多少线程的方法？是不是可以理解为整个jvm的大小减掉堆和方法区的余下额度/xss的大小呢？谢谢

对的，就是这样子，但是一般单个JVM内部也就最多几百个线程，其实不会太多的



> 学员总结：

文章总体意思，就是新生代gc一般没什么影响 ，但是大内存的堆就会导致 新生代回收很慢 。

如果在高并发的情况下，不仅慢而且还没频繁 full gc影响很大 涉及过程很复杂 ，时间也是新生代的10倍以上 。但是 full gc频繁不频繁又和新生代 gc有很大的关系 比如 

- 1.新生代年龄躲过15次以后 
- 2.大对象直接进入老年代 G1例外 有专门存储大对象的region 
- 3.动态年龄规则 
- 4.supervisor区放不下 

其中 3和 4是 最值得关注的 比如supervisor区内存很小 会引发3 4 很频繁 导致很频繁的full gc


> 1、minor fc和full gc一样都是追踪追踪gc root，为什么full gc的root追踪就更慢呢？是因为minor fc的root更少，还是链条更短？ 2、从root追踪是垃圾回收线程从扫描栈中的局部变量开始吗？

- 1、老年代gc，从GC Roots开始追踪，但是老年代的存活对象更多，所以追踪速度更慢；新生代存活对象极少，所以追踪速度极快 

- 2、GC Roots就是两种，方法里的局部变量，类的静态变量，从这两个地方开始追踪扫描即可


> 学员思考题回答：

系统创建的对象被分配到java堆内存中，要想计算创建的对象内所占的内存对象，就需要计算对象的每个部分所占的内存大小；

java对象包括对象头、实例数据以及对象填充： 对象头包括对象的基本信息以及class的指针类等相关信息占用64bit（64位机器不压缩）； 

数据实例包括八种数据基本类型以及引用类型，将所用的全部算起来相加； 最后再加上对象头，计算8的最低倍数进行是否填充，最终则为所占用的内存空间bit

> 学员总结：

新系统上线要估算核心业务，每次请求产生的内存垃圾

例如100k，访问量QPS为100，则每秒产生垃圾10M，每次请求响应限制在时间为200ms以内,每次回收会有2M的对象卡在内存中,这40M内存触发Minor GC的时候还有引用，是存活对象，Minor GC后进入Survivor区。 

1个4和8G的服务器，可以分配永久代0.5G(512M)+新生代4G+(4G+0.5G+0.5G)+永久代1G， 那相当于平均没400秒（大约7分钟）Eden区就满了，就触发Minor GC。 

- 如果发现有太多对象没进入Survivor区，而是直接进入老年代，频繁Full GC的情况，则可以加大Survivor区。 

- 如果发现有对象写对象存活时间较长，进行15次GC后进入老年代，然后被Full GC清理。则可以加大MaxTenuringThreshold的参数值。 

- 大致思路就是尽量减少对象进入老年代，让年轻对象在MInor GC就被清理。 如果访问量暴增，则可以用多台机器进行负载均衡。


> 老师：一直有一个疑问，就是对象在minor gc后，survivor无法容纳就会进入老年代。疑问：gc剩余的对象年龄各不相同，应该是部分进入老年代？还是全部进入老年代

要是Survivor无法容纳， 那就全部进入老年代


> 假如我们设置GC停顿时间设置为20ms，新生代默认最大占比60%，当G1监控到Region区域的对象的回收预期时间满足20ms，是否会马上进行一次minor GC？此时新生代的占比仅为20%。老师请问下，上述表述是否正确，或者说另一个触发G1 minor gc的条件是新生代监控到的可回收象的回收预期时间满足MaxGCPauseMills就立马触发，进行垃圾回收，释放空间？

不会的，其实他很可能让你用到50%的时候，然后回收掉里面一小部分Region，保证gc停顿时间在20ms


> 可以不可以这样理解采用G1回收刚开始新生代是不会回收的即便是最初的eden满了也不会gc此时因为还有好多region可以分配所以继续扩展region直到堆内存的60%或者你设置的置才不会扩展region但是回收 region还是遵循规定时间内回收一部分region


> 学员总结：

看了大家的回复，都提到了spring 的bean。除此之外，我觉得还有以下几类长生命周期对象： 线程池的核心线程，coreSize那些，以及他们引用的对象，包括threadlocal引用的对象（除非手动清理） tomcat的各类组件，包括connector和container部分，比如filter，servlet，listener； 同时，classloader， Class对象这些也是长生命周期； 各类池化技术，比如线程池，连接池等等。 暂时就知道这些吧




# 043、动手实验：自己动手模拟出频繁Young GC的场景体验一下！

## 1、前文回顾

从本周开始，我们将要全面进入实操环节，也就是说之前几周时间都是在分析JVM的运行原理、GC原理以及优化原理，但是本周开始我们将要通过各种代码模拟出来JVM的各种场景，同时结合GC日志去分析到底JVM是怎么运行的。

今天的文章，我们将会给大家通过代码演示年轻代的Young GC是如何发生的，同时告诉大家如何在JVM参数中去配置打印对应的GC日志，然后我们通过GC日志来慢慢的分析JVM的GC到底是如何运行的。

## 2、程序的JVM参数示范

首先，我们通过之前的学习都知道，我们平时系统运行创建的对象，除非是那种大对象，否则通常来说都是优先分配在新生代中的Eden区域的.而且新生代还有另外两块Survivor区域，默认Eden区域占据新生代的80%，每块Survivor区域占据新生代的10%。

比如我们用以下JVM参数来运行代码：

-XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC

上述参数都是基于JDK 1.8版本来设置的，不同的JDK版本对应的参数名称是不太一样的，但是基本意思是类似的。

上面“-XX:InitialHeapSize和-XX:MaxHeapSize”就是初始堆大小和最大堆大小，“-XX:NewSize和-XX:MaxNewSize”是初始新生代大小和最大新生代大小，“-XX:PretenureSizeThreshold=10485760”指定了大对象阈值是10MB。

相当于给堆内存分配10MB内存空间，其中新生代是5MB内存空间，其中Eden区占4MB，每个Survivor区占0.5MB，大对象必须超过10MB才会直接进入老年代，年轻代使用ParNew垃圾回收器，老年代使用CMS垃圾回收器，看下图图示。

![](../../pic/2020-03-08-11-41-07.png)


## 3、如何打印出JVM GC日志？

接着我们需要在系统的JVM参数中加入GC日志的打印选型，如下所示：

- -XX:+PrintGCDetils：打印详细的gc日志
- -XX:+PrintGCTimeStamps：这个参数可以打印出来每次GC发生的时间
- -Xloggc:gc.log：这个参数可以设置将gc日志写入一个磁盘文件

-XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log

## 4、示例程序代码

![](../../pic/2020-03-08-11-44-43.png)

## 5、对象是如何分配在Eden区内的

上面的这段代码非常简单，先通过“new byte[1024 * 1024]”这样的代码连续分配了3个数组，每个数组都是1MB

然后通过array1这个局部变量依次引用这三个对象，最后还把array1这个局部变量指向了null

那么在JVM中上述代码是如何运行的呢？

byte[] array1 = new byte[1024 * 1024];。

这行代码一旦运行，就会在JVM的Eden区内放入一个1MB的对象，同时在main线程的虚拟机栈中会压入一个main()方法的栈帧，在main()方法的栈帧内部，会有一个“array1”变量，这个变量是指向堆内存Eden区的那个1MB的数组，如下图。

![](../../pic/2020-03-08-11-46-48.png)

接着我们看第二行代码：array1 = new byte[1024 * 1024];

此时会在堆内存的Eden区中创建第二个数组，并且让局部变量指向第二个数组，然后第一个数组就没人引用了，此时第一个数组就成了没人引用的“垃圾对象”了，如下图所示。

![](../../pic/2020-03-08-11-48-04.png)


然后看第三行代码：byte[] array1 = new byte[1024 * 1024];。

这行代码在堆内存的Eden区内创建了第三个数组，同时让array1变量指向了第三个数组，此时前面两个数组都没有人引用了，就都成了垃圾对象，如下图所示。

![](../../pic/2020-03-08-11-48-45.png)

接着我们来看第四行代码：array1 = null;。

这行代码一执行，就让array1这个变量什么都不指向了，此时会导致之前创建的3个数组全部变成垃圾对象，如下图。

![](../../pic/2020-03-08-11-49-27.png)

最后看第五行代码：byte[] array2 = new byte[2 * 1024 * 1024];。

此时会分配一个2MB大小的数组，尝试放入Eden区中，大家觉得这个时候Eden区能放的下吗？


明显是不行的，因为Eden区总共就4MB大小，而且里面已经放入了3个1MB的数组了，所以剩余空间只有1MB了，此时你放一个2MB的数组是放不下的。

所以这个时候就会触发年轻代的Young GC。

## 6、采用指定JVM参数运行程序

之前给大家讲过，在Eclipse等开发工具里如何以指定JVM参数运行程序，就是对你的程序右键，然后选择“Run As -> Run Configurations”，接着在下图中填入对应的JVM参数：

![](../../pic/2020-03-08-11-51-02.png)

然后运行即可，此时运行完毕后，会在下述工程目录中出现一个gc.log文件，里面就是本次程序运行的gc日志，如下图所示。

![](../../pic/2020-03-08-11-52-46.png)

打开gc.log文件，我们会看到如下所示的gc日志：

![](../../pic/2020-03-08-11-53-44.png)

是不是觉得乱七八糟，密密麻麻的？

没关系，明天的文章我们会对照gc日志以及通过一步一图的方式，来分析一下到底Young GC是如何运行的。


## 自己疑问

```
public class Demo1 {
    public static void main(String[] args){
        byte[] arr1 = new byte[1024*1024];
//        arr1 = new byte[1024*1024];
//        arr1 = new byte[1024*1024];
//        arr1= null;
//        byte[] arr2 = new byte[2*1024*1024];
    }
}
```

```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(1621136k free), swap 15811140k(8450508k free)
CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
Heap
 par new generation   total 4608K, used 2992K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
  eden space 4096K,  73% used [0x00000000ff600000, 0x00000000ff8ec2d8, 0x00000000ffa00000)
  from space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
  to   space 512K,   0% used [0x00000000ffa80000, 0x00000000ffa80000, 0x00000000ffb00000)
 concurrent mark-sweep generation total 5120K, used 0K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3442K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K


```

这里只是申请了一个1M的数组，为什么占用却是：2M多年轻代？？？

疑问2：

测试代码：

```java
public class Demo1 {
    public static void main(String[] args) throws Exception{
        Thread.sleep(30000);
        byte[] arr1 = new byte[1024*1024];
        arr1 = new byte[1024*1024];
        arr1 = new byte[1024*1024];
        arr1= null;
        byte[] arr2 = new byte[2*1024*1024];
        Thread.sleep(30000);
    }
}
```


![](../../pic/2020-03-08-19-28-41.png)

这里进行young Gc后E区的使用量变大了？


```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(567536k free), swap 15811140k(6688164k free)
CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
30.169: [GC (Allocation Failure) 30.169: [ParNew: 3934K->512K(4608K), 0.0056379 secs] 3934K->1689K(9728K), 0.0059377 secs] [Times: user=0.02 sys=0.02, real=0.01 secs] 
Heap
 par new generation   total 4608K, used 3703K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
  eden space 4096K,  77% used [0x00000000ff600000, 0x00000000ff91dc60, 0x00000000ffa00000)
  from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
  to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
 concurrent mark-sweep generation total 5120K, used 1177K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K


```


疑问3：

测试代码：

```java
public class Demo1 {
    public static void main(String[] args) throws Exception{
        Thread.sleep(30000);
        byte[] arr1 = new byte[1024*1024];
        Thread.sleep(2000);
        arr1 = new byte[1024*1024];
        Thread.sleep(2000);
        arr1 = new byte[1024*1024];//这里的时候就触发了GC，会把上面的2M回收掉
        Thread.sleep(2000);
        arr1= null;
        byte[] arr2 = new byte[2*1024*1024];
        Thread.sleep(30000);
    }
}

```


![](../../pic/2020-03-08-19-35-44.png)

从日志中可以看到，不知道哪里来的1M多的对象在E区，当在分配第三个1M的时候就触发了垃圾回收，并且把1M多的对象移动到了老年代[这个未知对象是什么？？？]，最后年轻代中剩余的是3M的对象。





# 044、高级工程师的硬核技能：JVM的Young GC日志应该怎么看？

备注：自己运行后的日志，而且每次运行的输出并非完全一样.

疑问：为什么这个时候老年代会有约1M多的对象？


```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(360084k free), swap 31624156k(2141792k free)
CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
4.755: [GC (Allocation Failure) 4.755: [ParNew: 3813K->512K(4608K), 0.0238942 secs] 3813K->1659K(9728K), 0.0241026 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] 
Heap
 par new generation   total 4608K, used 3746K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
  eden space 4096K,  78% used [0x00000000ff600000, 0x00000000ff9289a8, 0x00000000ffa00000)
  from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
  to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
 concurrent mark-sweep generation total 5120K, used 1147K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3296K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 361K, capacity 388K, committed 512K, reserved 1048576K


```

```java
package com.ls.jvm;

/**
 * @program: java-new-feature
 * @author: lishuai
 * @create: 2020-03-08 13:19
 * young gc 触发代码
 * 
 * jvm参数：
-XX:NewSize=5242880
-XX:MaxNewSize=5242880
-XX:InitialHeapSize=10485760
-XX:MaxHeapSize=10485760
-XX:SurvivorRatio=8
-XX:PretenureSizeThreshold=10485760
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:gc.log
 */
public class Demo1 {
    public static void main(String[] args){
        byte[] arr1 = new byte[1024*1024];
        arr1 = new byte[1024*1024];
        arr1 = new byte[1024*1024];
        arr1= null;
        byte[] arr2 = new byte[2*1024*1024];
    }
}

```


## 1、前文回顾

昨天的文章我们给大家了一个示例性的代码，同时给出了实验用的JVM参数，教会了大家如何在Eclipse中去使用指定的JVM参数运行程序，并且看到了代码运行触发的Young GC的日志，然后先让大家自己尝试思考和分析一下。

今天我们的文章就通过一步一图的方式，接着昨天的内容继续来仔细分析GC日志，同时配合画图告诉大家依次Young GC的实际执行过程。

## 2、程序运行采用的默认JVM参数如何查看？

在GC日志中，可以看到如下内容：CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 .........

这就是告诉你这次运行程序采取的JVM参数是什么，基本都是我们设置的，同时还有一些参数默认就给设置了，不过一般关系不大。

告诉大家这个，是很多人问我，如果没设置JVM参数的话，怎么看系统用的默认JVM参数？

很简单，给你的JVM起码加一段打印gc日志的参数，就可以在这里看到他默认会给你的JVM进程分配多大的内存空间了。默认给的内存是很小的。


## 3、一次GC的概要说明

接着我们看GC日志中的如下一行：

0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K->512K(4608K), 0.0015734 secs] 4030K->574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

这个就是概要说明了本次GC的执行情况，给大家讲一遍，大家就知道怎么回事了。

GC (Allocation Failure)，这个看字面意思就知道，为啥会发生一次GC呢？

很简单，因为看上图，要分配一个2MB的数组，结果Eden区内存不够了，所以就出现了“Allocation Failure”，也就是对象分配失败。

所以此时就要触发一次Young GC。

那这次GC是什么时候发生的呢？

很简单，看一个数字，“0.268”，这个意思就是你的系统运行以后过了多少秒发生了本次GC，比如这里就是大概系统运行之后过了大概200多毫秒，发生了本次GC。

ParNew: 4030K->512K(4608K), 0.0015734 secs

这个“ParNew”的意思，大家很明确了吧，我们触发的是年轻代的Young GC，所以是用我们指定的ParNew垃圾回收器执行GC的。

4030K->512K(4608K)

这个代表的意思是，年轻代可用空间是4608KB，也就是4.5MB，为啥是4.5MB呢？

大家看上图，Eden区是4MB，两个Survivor中只有一个是可以放存活对象的，另外一个是必须一致保持空闲的，所以他考虑年轻代的可用空间，就是Eden+1个Survivor的大小，也就是4.5MB。

然后4030K->512K，意思就是对年轻代执行了一次GC，GC之前都使用了4030KB了，但是GC之后只有512KB的对象是存活下来的。

0.0015734 secs，这个就是本次gc耗费的时间，看这里来说大概耗费了1.5ms，仅仅是回收3MB的对象而已。

4030K->574K(9728K), 0.0017518 secs，这段话指的是整个Java堆内存的情况

意思是整个Java堆内存是总可用空间9728KB（9.5MB），其实就是年轻代4.5MB+老年代5M，然后GC前整个Java堆内存里使用了4030KB，GC之后Java堆内存使用了574KB。

[Times: user=0.00 sys=0.00, real=0.00 secs] 

这个意思就是本次gc消耗的时间，大家可以看，这里最小单位是小数点之后两位，但是这里全部是0.00 secs，也就是说本次gc就耗费了几毫秒，所以从秒为单位来看，几乎是0。

相信大家看到这里，会有很多疑惑，感觉好像跟自己的认知有一些差距

不要紧，稍安勿躁，继续跟着看下去，接下来我们给大家图解一下这个GC发生的过程。


## 4、图解GC执行过程

第一个问题，看这行日志，ParNew: 4030K->512K(4608K), 0.0015734 secs

大家很奇怪，我们在GC之前，明明在Eden区里就放了3个1MB的数组，一共是3MB，也就是3072KB的对象，那么GC之前年轻代应该是使用了3072KB的内存啊，为啥是使用了4030KB的内存呢？

其实这个问题，大家先不要纠结，你只要明白两点：

- 其实你创建的数组本身虽然是1MB，但是为了存储这个数组，JVM内置还会附带一些其他信息，所以每个数组实际占用的内存是大于1MB的；

- 除了你自己创建的对象以外，可能还有一些你看不见的对象在Eden区里，至于这些看不见的未知对象是什么，后面我们有专门的工具可以分析堆内存快照，以后会带你看到这些对象是什么。

所以如下图所示，GC之前，三个数组和其他一些未知对象加起来，就是占据了4030KB的内存。

![](../../pic/2020-03-08-13-42-47.png)


接着你想要在Eden分配一个2MB的数组，此时肯定触发了“Allocation Failure“，对象分配失败，就触发了Young GC

然后ParNew执行垃圾回收，回收掉之前我们创建的三个数组，此时因为他们都没人引用了，一定是垃圾对象，如下图所示。

![](../../pic/2020-03-08-13-43-18.png)

然后我们继续看gc日志，ParNew: 4030K->512K(4608K), 0.0015734 secs

gc回收之后，从4030KB内存使用降低到了512KB的内存使用

也就是说这次gc日志有512KB的对象存活了下来，从Eden区转移到了Survivor1区，其实我们可以把称呼改改，叫做Survivor From区，另外一个Survivor叫做Survivor To区，如下图。

![](../../pic/2020-03-08-13-44-34.png)

其实结合GC日志就能看出来，这就是本次GC的全过程。

## 5、GC过后的堆内存使用情况

![](../../pic/2020-03-08-13-47-12.png)

这段日志是在JVM退出的时候打印出来的当前堆内存的使用情况，其实也很简单，一点点看一下，先看下面这段。

par new generation   total 4608K, used 2601K，这就是说“ParNew”垃圾回收器负责的年轻代总共有4608KB（4.5MB）可用内存，目前是使用了2601KB（2.5MB）。

那么大家思考一下，此时在JVM退出之前，为什么年轻代占用了2.5MB的内存？

很简单，在gc之后，我们这不是通过如下代码又分配了一个2MB的数组吗：byte[] array2 = new byte[2 * 1024 * 1024];

所以此时在Eden区中一定会有一个2MB的数组，也就是2048KB，然后上次gc之后在From Survivor区中存活了一个512KB的对象，大家也不知道是啥，先不用管他。

但是此时你疑惑了，2048KB + 512KB = 2560KB。

那为什么说年轻代使用了2601KB呢？

因为之前说过了每个数组他会额外占据一些内存来存放一些自己这个对象的元数据，所以你可以认为多出来的41KB可以是数组对象额外使用的内存空间。

![](../../pic/2020-03-08-13-50-21.png)

接着我们继续看GC日志：

eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)

from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)

to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)

通过GC日志就能验证我们的推测是完全准确的，这里说的很清晰了，Eden区此时4MB的内存被使用了51%，就是因为有一个2MB的数组在里面。

然后From Survivor区，512KB是100%的使用率，此时被之前gc后存活下来的512KB的未知对象给占据了。

接着看GC日志：

concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 
class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

concurrent mark-sweep generation total 5120K, used 62K，这个很简单，就是说Concurrent Mark-Sweep垃圾回收器，也就是CMS垃圾回收器，管理的老年代内存空间一共是5MB，此时使用了62KB的空间，这个是啥你也先不用管了，可以先忽略不计，以后我们有内存分析工具了，你都能看到。

其他两段日志也很简单，意思就是Metaspace元数据空间和Class空间，存放一些类信息、常量池之类的东西，此时他们的总容量，使用内存，等等。

## 6、今日思考题

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

对JDK 1.8以后的Metaspace和Classspace，大家去百度一下，这里都是存放什么内容的



# 045、动手实验：自己动手模拟出对象进入老年代的场景体验一下（上）

## 2、动态年龄判定规则

之前我们给大家总结过对象进入老年代的4个常见的时机：

- 1、躲过15次gc，达到15岁高龄之后进入老年代；

- 2、动态年龄判定规则，如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%，此时年龄n以上的对象会进入老年代，不一定要达到15岁

- 3、如果一次Young GC后存活对象太多无法放入Survivor区，此时直接计入老年代

- 4、大对象直接进入老年代

首先我们先通过代码给大家模拟出来最常见的一种进入老年代的情况，如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%，此时年龄n以上的对象会进入老年代，也就是所谓的动态年龄判定规则


先来看看我们这次示例程序的JVM参数：

“-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log”

在这些参数里我们注意几点，新生代我们通过“-XX:NewSize”设置为10MB了

然后其中Eden区是8MB，每个Survivor区是1MB，Java堆总大小是20MB，老年代是10MB，大对象必须超过10MB才会直接进入老年代

但是我们通过“-XX:MaxTenuringThreshold=15”设置了，只要对象年龄达到15岁才会直接进入老年代。

一切准备就绪，先看看我们当前的内存分配情况，如下图，然后接下来我们开始来看看我们的示例代码。

![](../../pic/2020-03-08-14-03-41.png)

## 3、动态年龄判定规则的部分示例代码

![](../../pic/2020-03-08-14-14-25.png)

```java
package com.ls.jvm;

/**
 * @program: java-new-feature
 * @author: lishuai
 * @create: 2020-03-08 13:19
动态年龄判定规则的部分示例代码


-XX:NewSize=5242880
-XX:MaxNewSize=5242880
-XX:InitialHeapSize=10485760
-XX:MaxHeapSize=10485760
-XX:SurvivorRatio=8
-XX:PretenureSizeThreshold=10485760
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:gc.log
 */
public class Demo2 {
    public static void main(String[] args){
        byte[] arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1= null;
        byte[] arr2 = new byte[128*1024];
        byte[] arr3 = new byte[2*1024*1024];
    }
}

```
研究jvm运行过程，一定要一步一步调试代码，上面只是我们例子的部分代码，但是我们需要先运行部分代码，通过gc日志来分析这部分代码执行过后jvm中的对象分配情况。

## 4、部分示例代码运行后产生的gc日志

接着我们把上述示例代码以及我们给出的JVM参数配合起来运行，此时会看到如下的GC日志，接着我们就开始一步一步分析一下这部分代码运行后的gc日志。

```
0.297: [GC (Allocation Failure) 0.297: [ParNew: 7260K->715K(9216K), 0.0012641 secs] 7260K->715K(19456K), 0.0015046 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

Heap

par new generation   total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

from space 1024K,  69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)

to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

class space    used 300K, capacity 386K, committed 512K, reserved 1048576K

```

## 5、部分代码的GC日志分析

![](../../pic/2020-03-08-14-14-38.png)

在这里连续创建了3个2MB的数组，最后还把局部变量array1设置为了null，所以此时的内存如下图所示：

![](../../pic/2020-03-08-14-14-56.png)

byte[] array2 = new byte[128 * 1024];。此时会在Eden区创建一个128KB的数组同时由array2变量来引用，如下图。

![](../../pic/2020-03-08-14-15-26.png)

然后会执行下面的代码：byte[] array3 = new byte[2 * 1024 * 1024];

此时希望在Eden区再次分配一个2MB的数组，大家觉得可行吗？

因为此时Eden区里已经有3个2MB的数组和1个128KB的数组，大小都超过6MB了，Eden总共才8MB，此时是不可能让你创建2MB的数组的。

因此此时一定会触发一次Young GC，接着我们开始看GC日志。

ParNew: 7260K->715K(9216K)

这行日志清晰表明了，在GC之前年轻代占用了7260KB的内存，这里大概就是6MB的3个数组 + 128KB的1个数组 + 一些未知对象

![](../../pic/2020-03-08-14-17-21.png)

7260K->715K(9216K)，一次Young GC过后，剩余的存活对象大概是715KB，大家还记得我们上篇文章分析的GC日志吗？

之前就说过大概年轻代刚开始会有512KB左右的未知对象，此时再加上我们自己的128KB的数组，大家想想，是不是差不多就是700KB？

接着看GC日志如下：


```
par new generation   total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

from space 1024K,  69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)

to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
```

从上面的日志可以清晰看出，此时From Survivor区域被占据了69%的内存，大概就是700KB左右，这就是一次Young GC后存活下来的对象，他们都进入From Survivor区了。

同时Eden区域内被占据了26%的空间，大概就是2MB左右，这就是byte[] array3 = new byte[2 * 1024 * 1024];，这行代码在gc过后分配在Eden区域内的数组

![](../../pic/2020-03-08-14-21-12.png)

那么大家思考一个问题，现在Survivor From区里的那700kb的对象，是几岁呢？

答案是：1岁

他熬过一次gc，年龄就会增长1岁。而且此时Survivor区域总大小是1MB，此时Survivor区域中的存活对象已经有700KB了，绝对超过了50%。


##  6、完善示例代码

![](../../pic/2020-03-08-14-22-34.png)


```java
public class Demo2 {
    public static void main(String[] args){
        byte[] arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1= null;
        byte[] arr2 = new byte[128*1024];
        byte[] arr3 = new byte[2*1024*1024];//这里6M多了，再分配一个2M不够触发GC


        arr3 = new byte[2*1024*1024];
        arr3 = new byte[2*1024*1024];
        arr3 = new byte[128*1024];
        arr3= null;

        byte[] arr4 = new byte[2*1024*1024];//这里6M多了，再分配一个2M不够触发GC
    }
}

```
接着我们把示例代码给完善一下，变成上述的样子，我们要触发出来第二次Young GC，然后看看Survivor区域内的动态年龄判定规则能否生效。

先看下面几行代码：

```java
        arr3 = new byte[2*1024*1024];
        arr3 = new byte[2*1024*1024];
        arr3 = new byte[128*1024];
        arr3= null;
```

这几行代码运行过后，实际上会接着分配2个2MB的数组，然后再分配一个128KB的数组，最后是让array3变量指向null，如下图所示。

![](../../pic/2020-03-08-14-28-50.png)

此时接着会运行下面的代码：byte[] array4 = new byte[2 * 1024 * 1024];

这个时候，大家会发现，Eden区如果要再次放一个2MB数组下去，是放不下的了，所以此时必然会触发一次Young GC。

大家使用上述的JVM参数运行这段程序会看到如下的GC日志：

```

0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K->713K(9216K), 0.0013103 secs] 7260K->713K(19456K), 0.0015501 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K->0K(9216K), 0.0036521 secs] 7017K->700K(19456K), 0.0037342 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] 

Heap

 par new generation   total 9216K, used 2212K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)

 eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)

 from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

 to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)

 concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

 Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K

 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K
```
## 7、分析最终版的GC日志

首先第一次GC的日志如下：

0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K->713K(9216K), 0.0013103 secs] 7260K->713K(19456K), 0.0015501 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

这个过程刚才我们分析过了。

接着第二次GC的日志如下：

0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K->0K(9216K), 0.0036521 secs] 7017K->700K(19456K), 0.0037342 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] 

第二次触发Yuong GC，就是我们上述代码执行的时候，此时大家发现ParNew: 7017K->0K(9216K)

这行日志表明，这次GC过后，年轻代直接就没有对象了，也就是说没有任何存活对象，你觉得可能吗？

要是这么简单的想，绝对是侮辱自己的智商了，大家还记得array2这个变量一直引用着一个128KB的数组，他绝对是存活对象，还有那500多KB的未知对象，此时都去哪里了呢？

首先我们先看看上面的图，在Eden区里有3个2MB的数组和1个128KB的数组，这绝对是会被回收掉的，如下图所示。

![](../../pic/2020-03-08-14-35-49.png)

接着其实此时会发现Survivor区域中的对象都是存活的，而且总大小超过50%了，而且年龄都是1岁

此时根据动态年龄判定规则：年龄1+年龄2+年龄n的对象总大小超过了Survivor区域的50%，年龄n以上的对象进入老年代。

当然这里的对象都是年龄1的，所以直接全部进入老年代了，如下图。

![](../../pic/2020-03-08-14-37-04.png)

大家看下面的日志可以确认这一点：

concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

CMS管理的老年代，此时使用空间刚好是700KB，证明此时Survivor里的对象触发了动态年龄判定规则，虽然没有达到15岁，但是全部进入老年代了。

包括我们自己的那个array2变量一直引用的128KB的数组。

然后array4变量引用的那个2MB的数组，此时就会分配到Eden区域中，如下图所示。

![](../../pic/2020-03-08-14-39-34.png)

此时大家看下面的日志：

eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)

这里就说明Eden区当前就是有一个2MB的数组。

然后再看下面的日志：  

from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)

to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)


两个Survivor区域都是空的，因为之前存活的700KB的对象都进入老年代了，所以当然现在Survivor里都是空的了。


##  8、今日思考题

今天已经给大家分析了对象是如何通过动态年龄判定规则进入老年代的

其实之前我们通过大量的案例给大家演示过，如果你每次Young GC过后存活的对象太多进入Survivor，特别是超过了Survivor 50%的空间，很可能下次Young GC的时候就会让一些对象触发动态年龄判定规则进入老年代中。

希望大家自己通过代码模拟出来对象达到15岁年龄之后自然进入老年代的场景

自己写代码，自己模拟，自己看GC日志，这样才能真正学好。


## 自己疑问

在自己电脑运行的日志：为何第二次新生代会存在128K的对象在S区？？？

```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(433932k free), swap 31624156k(515140k free)
CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
0.517: [GC (Allocation Failure) 0.517: [ParNew: 8139K->673K(9216K), 0.0009368 secs] 8139K->673K(19456K), 0.0010719 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.519: [GC (Allocation Failure) 0.519: [ParNew: 7104K->128K(9216K), 0.0020178 secs] 7104K->784K(19456K), 0.0020895 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 2340K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)
  from space 1024K,  12% used [0x00000000ff400000, 0x00000000ff420010, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 concurrent mark-sweep generation total 10240K, used 656K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3442K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K
```




# 046、动手实验：自己动手模拟出对象进入老年代的场景体验一下（下）


## 1、前文回顾

上篇文章给大家分析了一下对象是如何通过动态年龄判定规则进入老年代的，同时让大家自己动手去模拟写代码体验一下对象达到15岁之后自动进入老年代的场景。

今天这篇文章我们就来给大家示范一下，对象是如何在Young GC过后因为放入下Survivor区域，就直接进入老年代了。

## 2、示例代码

![](../../pic/2020-03-08-15-54-48.png)


```java
package com.ls.jvm;

/**
 * @program: java-new-feature
 * @author: lishuai
 * @create: 2020-03-08 13:19
动态年龄判定规则的部分示例代码


-XX:NewSize=5242880
-XX:MaxNewSize=5242880
-XX:InitialHeapSize=10485760
-XX:MaxHeapSize=10485760
-XX:SurvivorRatio=8
-XX:PretenureSizeThreshold=10485760
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:gc.log
 */
public class Demo3 {
    public static void main(String[] args){
        byte[] arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];

        byte[] arr2 = new byte[128*1024];
        arr2=null;
        byte[] arr3 = new byte[2*1024*1024];
    }
}

```


自己运行Gc日志

```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(2113124k free), swap 15811140k(9291104k free)
CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
0.523: [GC (Allocation Failure) 0.523: [ParNew: 8139K->692K(9216K), 0.0022115 secs] 8139K->2742K(19456K), 0.0023746 secs] [Times: user=0.00 sys=0.02, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 3110K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  29% used [0x00000000fec00000, 0x00000000fee5c478, 0x00000000ff400000)
  from space 1024K,  67% used [0x00000000ff500000, 0x00000000ff5ad3a0, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3358K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 369K, capacity 388K, committed 512K, reserved 1048576K


```


## 3、GC日志

然后我们使用之前的JVM参数来跑一下上面的程序，可以看到下面的GC日志：

![](../../pic/2020-03-08-15-56-23.png)


## 4、一步一图来分析GC日志

![](../../pic/2020-03-08-15-56-58.png)

上面的代码中，首先分配了3个2MB的数组，然后最后让array1变量指向了第三个2MB数组

接着创建了一个128K的数组，但是确让array2指向了null，同时我们一直都知道，Eden区里会有500KB左右的未知对象

此时如下图所示：

![](../../pic/2020-03-08-15-57-46.png)

接着会执行如下代码：byte[] array3 = new byte[2 * 1024 * 1024];。此时想要在Eden区里再创建一个2MB的数组，肯定是不行的，所以此时必然触发一次Young GC。

ParNew: 7260K->573K(9216K), 0.0024098 secs。

这里清晰说明了，本次GC过后，年轻代里就剩下了500多KB的对象

这是为什么呢？此时明明array1变量是引用了一个2MB的数组的啊！

其实道理很简单，大家可以想一下，这次GC的时候，会回收掉上图中的2个2MB的数组和1个128KB的数组，然后留下一个2MB的数组和1个未知的500KB的对象

![](../../pic/2020-03-08-16-01-40.png)

那么此时剩下来的2MB的数组和500KB的未知对象能放入From Survivor区吗？

答案是：不能

因为Survivor区仅仅只有1MB。根据我们之前说过的规则，此时是不是要把这些存活对象全部放入老年代？

答案：也不是

大家看如下日志：

eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)

首先Eden区内一定放入了一个新的2MB的数组，就是刚才最后想要分配的那个数组，由array3变量引用，如下图。

![](../../pic/2020-03-08-16-03-20.png)

其次，看下面的日志：

 from space 1024K,  55% used [0x00000000ff500000, 0x00000000ff58f570, 0x00000000ff600000)

 大家发现此时From Survivor区中有500KB的对象，其实就是那500KB的未知对象！

 所以在这里并不是让2MB的数组和500KB的未知对象都进入老年代，而是把500KB的未知对象放入From Survivor区中！

 从这里可以看到，很多细节，我们都是逐步给大家揭露开来的，之前有同学问我，如果对象放入下Survivor，是不是会有部分留在Survivor，部分进入老年代？

 我当时没做明确的回答，而且之前的案例里从没提过这个细节，那是因为时机不到，当时大家不需要理解到这么细的程度。

 但是现在结合GC日志，大家可以清晰的看到，在这种情况下，是会把部分对象放入Survivor区的。


![](../../pic/2020-03-08-16-05-29.png)

接着我们看如下日志：
concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)

此时老年代里确有2MB的数组，因此可以认为，Young GC过后，发现存活下来的对象有2MB的数组和500KB的未知对象。

此时把500KB的未知对象放入Survivor中，然后2MB的数组直接放入老年代，如下图。

![](../../pic/2020-03-08-16-06-33.png)
 
## 5、本文总结

本文篇幅不长，但是很好的给大家结合GC日志分析了Young GC过后存活对象放不下Survivor区域，从而部分对象会进入老年代的示例

在这里大家也明白了一个细节，在这种场景下，有部分对象会留在Survivor中，有部分对象会进入老年代的。


## 6、今日思考题

今天给大家留一个思考题，希望大家去写代码模拟一下，分配一个大对象，然后让大对象直接进入老年代，看看GC日志，是否大对象会直接进入老年代？

我这里直接分配一个9M的对象

byte[] arr1 = new byte[9*1024*1024];


日志：

```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(1591104k free), swap 15811140k(8433244k free)
CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
Heap
 par new generation   total 9216K, used 2159K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee1bfc0, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 concurrent mark-sweep generation total 10240K, used 9216K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3442K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K

```

concurrent mark-sweep generation total 10240K, used 9216K

可以看到老年代中一个9M的对象，但是par new generation   total 9216K, used 2159K为什么E取会有一个2M多的占用？？？



# 047、高级工程师的硬核技能：JVM的Full GC日志应该怎么看？

## 1、前文回顾

之前两篇文章已经给大家分析清楚了对象是如何进入老年代的，接着我们就给大家演示一下，老年代的GC是如何触发的。

## 2、示例代码

![](../../pic/2020-03-08-16-23-45.png)

```java
package com.ls.jvm;

/**
 * @program: java-new-feature
 * @author: lishuai
 * @create: 2020-03-08 13:19
-XX:NewSize=10485760
-XX:MaxNewSize=10485760
-XX:InitialHeapSize=20971520
-XX:MaxHeapSize=20971520
-XX:SurvivorRatio=8
-XX:MaxTenuringThreshold=15
-XX:PretenureSizeThreshold=3145728
-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:gc4.log
 */
public class Demo4 {
    public static void main(String[] args){
        byte[] arr1 = new byte[4*1024*1024];//直接进入老年代
        arr1 = null;
        byte[] arr2 = new byte[2*1024*1024];
        byte[] arr3 = new byte[2*1024*1024];
        byte[] arr4 = new byte[2*1024*1024];
        byte[] arr5 = new byte[128*1024];

        byte[] arr6 = new byte[2*1024*1024];

    }
}


```


## 3、GC日志

我们需要采用如下参数来运行上述程序：

“-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3145728 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log”

这里最关键一个参数，就是“-XX:PretenureSizeThreshold=3145728”

这个参数要设置大对象阈值为3MB，也就是超过3MB，就直接进入老年代。

运行之后会得到如下GC日志：

![](../../pic/2020-03-08-16-42-45.png)


## 4、一步一图分析日志

![](../../pic/2020-03-08-16-43-11.png)

这行代码直接分配了一个4MB的大对象，此时这个对象会直接进入老年代，接着array1不再引用这个对象

![](../../pic/2020-03-08-16-43-38.png)

接着看下面的代码：

![](../../pic/2020-03-08-16-44-01.png)

连续分配了4个数组，其中3个是2MB的数组，1个是128KB的数组，如下图所示，全部会进入Eden区域中。

![](../../pic/2020-03-08-16-44-27.png)

接着会执行如下代码：byte[] array6 = new byte[2 * 1024 * 1024];。此时还能放得下2MB的对象吗？不可能了，因为Eden区已经放不下了。因此此时会直接触发一次Young GC。

我们看下面的GC日志：ParNew (promotion failed): 7260K->7970K(9216K), 0.0048975 secs

这行日志显示了，Eden区原来是有7000多KB的对象，但是回收之后发现一个都回收不掉，因为上述几个数组都被变量引用了。

所以此时大家都知道，一定会直接把这些对象放入到老年代里去，但是此时老年代里已经有一个4MB的数组了，还能放的下3个2MB的数组和1个128KB的数组吗？

明显是不行的，此时一定会超过老年代的10MB大小。

所以此时我们看gc日志：

[CMS: 8194K->6836K(10240K), 0.0049920 secs] 11356K->6836K(19456K), [Metaspace: 2776K->2776K(1056768K)], 0.0106074 secs]

大家可以清晰看到，此时执行了CMS垃圾回收器的Full GC，我们之前讲过Full GC其实就是会对老年代进行Old GC，同时一般会跟一次Young GC关联，还会触发一次元数据区（永久代）的GC。

在CMS Full GC之前，就已经触发过Young GC了，此时大家可以看到此时Young GC就已经有了，接着就是执行针对老年代的Old GC，也就是如下日志：

CMS: 8194K->6836K(10240K), 0.0049920 secs

这里看到老年代从8MB左右的对象占用，变成了6MB左右的对象占用，这是怎么个过程呢？

很简单，一定是在Young GC之后，先把2个2MB的数组放入了老年代，如下图。

![](../../pic/2020-03-08-16-47-34.png)

此时要继续放1个2MB的数组和1个128KB的数组到老年代，一定会放不下，所以此时就会触发CMS的Full GC

然后此时就会回收掉其中的一个4MB的数组，因为他已经没人引用了，如下图所示。

![](../../pic/2020-03-08-16-48-20.png)

接着放入进去1个2MB的数组和1个128KB的数组，如下图所示。

![](../../pic/2020-03-08-16-48-40.png)

所以大家再看CMS的垃圾回收日志：CMS: 8194K->6836K(10240K), 0.0049920 secs，他是从回收前的8MB变成了6MB，就是上图所示。

最后在CMS Full GC执行完毕之后，其实年轻代的对象都进入了老年代，此时最后一行代码要在年轻代分配2MB的数组就可以成功了，如下图。

![](../../pic/2020-03-08-16-49-17.png)


## 5、本文总结

本文给大家又讲解了一个触发老年代GC的案例，就是年轻代存活的对象太多放不下老年代了，此时就会触发CMS的Full GC，大家可以清晰的看到全过程。


## 6、今日思考题

今天留给大家的思考题，就是让大家可以自己写代码模拟出来另外几种老年代GC的场景

其中一个就是在触发Young GC之前，可能老年代可用空间小于了历次Young GC后升入老年代的对象的平均大小，就会在Young GC之前，提前触发Full GC。

还有一个，就是老年代被使用率达到了92%的阈值，也会触发Full GC。

其实说实话，很多场景并不太容易用代码模拟出来，但是大家还是尽量尝试一下，因为这样可以增强大家对这里原理的一个理解。


## 自己运行的日志

1、年轻代垃圾回收后老年代存储不了触发

```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(1436556k free), swap 15811140k(8432120k free)
CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=3145728 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
0.141: [GC (Allocation Failure) 0.141: [ParNew (promotion failed): 8139K->8801K(9216K), 0.0034801 secs]0.144: [CMS: 8194K->6795K(10240K), 0.0045849 secs] 12235K->6795K(19456K), [Metaspace: 3437K->3437K(1056768K)], 0.0082266 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
Heap
 par new generation   total 9216K, used 2422K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  29% used [0x00000000fec00000, 0x00000000fee5d898, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 concurrent mark-sweep generation total 10240K, used 6795K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 376K, capacity 388K, committed 512K, reserved 1048576K

```


# 048、第7周作业：自己尝试着分析一把你们线上系统的JVM GC日志

本周作业很简单，大家已经完全结合JVM的GC日志搞明白了到底应该如何去结合GC日志去分析自己的系统平时的GC情况

而且结合GC日志也完全搞明白了平时Young GC的触发时机和原理，对象升入老年代的原理，Full GC的触发时机和原理，相当于从实操层面对之前所学内容进行了一个印证。

所以本周就是希望大家去看看自己线上系统的GC日志，然后分析分析每次GC的触发时机，以及每次GC之后的对象变化情况。


# 049、第7周答疑：本周问题答疑汇总





> 学员总结：

就着这篇作业，总结一下。我理解的优化思路： 项目上线初期： 

1、上线前，根据预期的并发量、平均每个任务的内存需求大小等，然后评估需要使用几台机器来承载，每台机器需要什么样的配置。 

2、根据系统的任务处理速度，评估内存使用情况，然后合理分配Eden、Survivor，老年代的内存大小。 

总体原则就是，让短命对象在YoungGC就被回收，不要进入老年代，长期存活的对象，尽早进入老年代，不要在新生代复制来复制去。对系统响应时间敏感且内存需求大的，建议采用G1回收器


如何合理分配各个区域: 

- 根据内存增速来评估多久进行Young GC 

- 根据每次Young GC的存活，评估一下Survivor区的大小设置是否合理 

- 评估多久进行一次FullGC，产生的STW，是否可以接受？ 

公司的运营很牛，过了一段时间，系统负载增加了10倍，100倍： 

方案1：增加服务器数量 根据系统负载的增比，同比增加机器数量，机器配置，和jvm的配置可以保持不变。 


方案2：使用更高配置的机器 更高的配置，意味着更快速的处理速度和更大的内存。响应时间敏感且内存需求大的使用G1回收器 这时候需要和‘项目上线初期’一样，合理的使用配置和分配内存



回答：理解完全正确



> 问题：

老师，如果在做定时任务数据处理的时候，在一个方法里面通过多线程的方式来处理数据库中的数据，在其他线程没有结束之前，其中一个线程提前处理完了，那该线程所new的对象会变成垃圾对象吗？还是说也要等到其他线程都处理完了才会变成垃圾对象？


回答：他自己引用的对象，他自己线程销毁了，自然那些对象都是垃圾了，如果触发gc就会被回收



> 问题：

在main方法中周期性执行loadReplicasFromDisk方法，文中说，loadReplicasFromDisk方法执行完毕之后，一旦方法结束，loadReplicasFromDisk方法的栈帧就会出栈，就没人引用ReplicaManager对象了。


我的疑问是为什么loadReplicasFromDisk执行完毕就会出栈呢，不应该是一直调用这个loadReplicasFromDisk方法，对应的一直有新的loadReplicasFromDisk方法的栈帧入栈


除非while true结束了，也就是main方法结束了，各个栈帧才会按照后进先出的顺序陆续出栈吗？栈帧A出栈后，才会回收栈帧A的局部变量表，这个时候才可以说没人引用栈帧A创建的那个ReplicaManager对象。


回答：一次方法调用就得入栈一次，一次方法调用结束了就会出栈，不是说一个方法调用多次，他就一直在栈里的



> 问题：

老师， 我想问一下， 当一次MinorGC时 发现应该进行 FullGC， 此时就进行FullGC。 今天的我课中说到，在并发清理的过程中可能会有Minor 送来的新对象在老年代放不下 ，就会出发 Concurrent Mode Failure 错误。 

我想问的是： 在第一次的Minor 触发FullGC时， Minor 送来的那批对象是怎么处理的呢？ 

是先卡一会儿， 等 FullGC的并发清理阶段 有了那么大的空间后， 这次的Minor对象就放下去， 然后这次MinorGC结束。 此时 FullGC依旧在处理并发清理阶段， 这个时候若老年代进来的对象大于可用的连续内存， 所以就 换成 Serial Old 去 STW 单线程的 GC 全部的老年代， 然后在把这批对象放进去是吗？


回答：是的，你理解没错

> 问题：

有个疑问：每次1w条数据需要处理10秒，那么每分钟也就处理6次数据，那么新生代就会积压94次数据，即积压940M（94*10M）数据未处理。也就是说1分钟把新生代填满，940M存活。而不是文中说的200M存活对象啊。

如果老师指的10秒的处理时间是单核处理速度，那每分钟4核也就处理240M还剩760M存活呢？

回答：不是的，1分钟来计算，填满之后，会垃圾回收，大部分对象会被回收掉，然后遗留200MB左右的数据是存活的


> 问题：

老师，在你的例子中，把s区扩大到200M，刚好占满s区，然后就只有很少的对象进入老年代。

我有个疑问，都占到s区的100%了，难道不会触发年龄担保机制么？

回答：对的，这里我只是做一个示例，其实最好让S增加到400左右，避免触发动态年龄判定机制

> 问题：

我有两个问题: 

1.基于动态年龄来判断的时候，如果年龄1-5的对象占有s区的50%，那么是＞=5还是＞5的对象会进入老年代？这里是否会有＝号？ 

2.按照动态年龄判断的规则，是不是每次minor gc后，都保证s区存活的对象＜=s区大小的50%?(因为根据年龄判断，50%以外的那部分直接进入老年代了，所以每次minor gc后s区最多剩下50%)

 

回答：

1、>=5

2、对的，你最好是让存活对象小于S的50%


> 问题：

这里我有个误区，那就是动态年龄的判断并不伴随minor gc，他应该拥有属于自己的触发时机(何时会触发？)


那我是不是可以这么理解：基于动态年龄的机制是随时有可能会触发的(那么触发的时机是什么？)

这时候，s区剩余空间一定是＜=50％。 但是minor gc之后，s区的存活对象是有可能＞50％的，只有等到下一次动态年龄判断触发时，又会下降到50％以及以下。



回答：每次Minor GC过后就会触发动态年龄判定机制





> 学员总结：

参数设置： 参数设置了堆大小为10M，指定了新生代5M ，那么老年代也是5M，因为SurvivorRatio=8，所以Eden区4M，S1、S2分别是0.5M。 

GC前的空间分配及判断： 先分配了3次1M对象进入Eden区，再次分配2M时，Eden区放不下了，准备进行Young GC，此时需要判断是否需要空间担保，5M的老年代空余>3M的新生代已用空间，不需要空间担保。直接进行Young GC。 

执行Young GC： 遍历所有线程栈中的和静态的引用变量，进行GCRoots追踪，发现新生代的Eden和S1区没有对象存活，不需要进行对象的拷贝，直接清空Eden区和S1区。此时YoungGC执行完成。



回答：对的


> 问题：

问题1：案例中的s区大小为200m，刚好容得下每次minor gc后存活对象的大小，但是根据动态年龄判断的规则



因此这里的s区大小是否应该设置为400m，才能更大程度的避免对象在一次minor gc后进入老年代？（也就是调整eden:s:s=6:2:2）但是这样好像又导致了更加频繁的minor gc 



问题2：文章中在提及动态年龄判断规则的时候，说的是同龄对象占有s区大小>50%，但是其实应该是年龄1-N的对象占有s区大小>50%吧，然后年龄>=N的对象会直接进入老年代



回答：

1、那个是示例，其实S可以搞的再大点，让存活对象小于S区的50% 



2、对的，后面有多处说明，就是你说的这个意思





学员总结：

新生代初始5M，最大5M，堆初始10M，总大小10M。Eden和Survivor区比例 8:1:1，即 4M:0.5M:0.5M，对象超过10M直接在老年代。 



垃圾回收算法: 新生代 ParNew + 老年代 CMS  

第一次分配 1M 第二次第三次第四次, 失去指向, 存在3M垃圾, Eden还剩 1M可用空间

分配 array2 为 2M Eden区空间不够

需要对新生代进行youngGC

回收垃圾大小为3M 和老年代剩余连续空间大小作比较 3M < 5 M, 不需要空间担保和Full GC

新生代进行垃圾回收 STW

将array2 放到 Eden区



回答：总结的很好





学员评价：

读完这节，以及本周的安排 我意识到老师的课程设计是我见过的最佳之一。 为什么这么说呢？ 



因为课程不仅由浅入深 一步一图，更是考虑到了 学而时习之 周期性回顾的重要性，节奏比速度更重要。 



可能有些老师会忽略一件事：就是以为学生的精力都放在他这一门课上，其实不是的



以我为例，我同时在学jvm、算法、石杉的架构(此处硬广)，精力那是要平衡分配的，如果某一门课一味求快 求多，可能最终是学完就忘，欲速则不达。



回答：是的，其实专栏类的东西，最好的就是在全流程里贯穿核心的知识体系，反复强化，不停的强化，适当的复习和总结，最终一个长周期后，彻底掌握这个技术的实战



学员总结：

整个堆的情况 Eden : 4m Survivor : 0.5m old : 5M 



正常来说的过程应该是这样的： 开始分配3m的对象，有2m是垃圾对象，此时分配2m的对象时发现eden空间不够， 根据空间担保规则，老年代5m大于新生代已占用内存3m，所以放心MinorGC， GC完了之后，新生代还有1M对象存活(array1引用)



此时发现survivor的一个 区域0.5m不足以放下存活的对象会将1m对象转移到老年代，接着新生代开始分配2m的对象 



对象分配完毕之后整个堆的情况：新生代2m，老年代1m。 事实上，经过我多次测试，运行这样的代码会产生2次MinorGC和一次Full GC。



这个结果可能根据每个人的电脑不一样也会产生误差(也有可能是在IDEA运行的原因)。 我的JDK版本为1.8.0.201 



另外根据GC日志分析，其实他计算的不单单是我们程序使用的内存，可能jvm本身使用的内存也计算上了。 



虽然我们heap大小设置为10m,但是GC日志中只有9728k，并不是10m，所以我认为在分析GC的时候，还是无法精确分析到每一个细节的，我们只能大致上来猜测GC的行为。

 



学员思考题回答：

深夜打卡。 

1、老年代5m空间大于3m，可以直接YoungGC，3M垃圾直接回收，Eden区清空，S1，S2也清空。但实际情况，根据日志，from space是占满了。 



2、根据日志，发现确实进行了一次Young GC。具体日志：0.116: [GC (Allocation Failure) 0.116: [ParNew: 3964K->512K(4608K), 0.0009533 secs] 3964K->549K(9728K), 0.0010680 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 



其中Allocation Failure应该表明了GC的原因（连续内存空间不足，内存空间分配失败），和具体的回收情况，可以看到内存空间被释放出来了，但却不是全部释放（可以看到原本的空间是3964K，而不是就三个数组的3072K）

 

回答：非常好



问题：

老师，请教一个问题，就是survivor区使用达到100%，按之前的规则一批对象占用survivor区超过50%，年龄大于等于这批对象的就进入老年代，好像这次gc没有触发，我要怎样才能模拟出这个规则的触发？

 

回答：他这一次达到Survivor 100%不会立马触发动态年龄判定机制，需要下一次GC的时候看你还是超过Survivor 50%，才会进行动态年龄判定，往后看，会有演示的



问题：

Java8 取消了PermGen。取而代之的是MetaSpace，方法区在java8以后移至MetaSpace。 Jdk8开始把类的元数据放到本地内存（native heap），称之为MetaSpace



理论上本地内存剩余多少，MetaSpace就有多大，当然我们也不可能无限制的增大MetaSpace，需要用-XX:MaxMetaSpaceSize来指定MetaSpace区域大小。 



关于used capacity commited 和reserved，在stackoverflow找到个比较靠谱的答案，我尝试翻译一下： MetaSpace由一个或多个Virtual Space（虚拟空间）组成。虚拟空间是操作系统的连续存储空间，虚拟空间是按需分配的。当被分配时，虚拟空间会向操作系统预留（reserve）空间，但还没有被提交（committed）。



MetaSpace的预留空间（reserved）是全部虚拟空间的大小。 虚拟空间的最小分配单元是MetaChunk（也可以说是Chunk）。



当新的Chunk被分配至虚拟空间时，与Chunk相关的内存空间被提交了（committed）。MetaSpace的committed指的是所有Chunk占有的空间。 



每个Chunk占据空间不同，当一个类加载器（Class Loader）被gc时，所有与之关联的Chunk被释放（freed）。这些被释放的Chunk被维护在一个全局的释放数组里。



MetaSpace的capacity指的是所有未被释放的Chunk占据的空间。 这么看gc日志发现自己committed是4864K，capacity4486K。有一部分的Chunk已经被释放了，代表有类加载器被回收了



可以这么理解吗老师？

 

附上原文链接：

https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout 

有一个示意图 有助于理解



回答：非常好，标准答案，优秀



学员总结：

这周实际操作的课程，只有周末才有时间试试。 懂了原理，会看 GC 日志，感觉这个垃圾回收的原理，基本没问题了。

 

回答：对的，吃透这些，jvm运行原理基本没问题了





问题：

可是minor gc不是会产生stw吗？ 那么stw是允许仅所有的垃圾回收线程运行？



即使是两个不同的正在运行的垃圾收集器，他们也是可以同时运行的，只不过工作线程无法一起运行罢了。请问是这样吗？



回答：stw，是说停止所有工作线程，不是垃圾回收线程





问题：

文中第二次发生gc的时候，清除了eden区域的对象，并判断from survivor的一岁的对象大于50%。然后准备将survivor所有对象移动至老年代。 然后第三次gc的时候，将survivor全部对象移动至老年代



但是为什么此时GC日志写的是（Allocation Failure）分配失败呢？



并且新生代那7017K的对象是哪里来的呢？不是前面一次gc后只剩下713K吗？期间就算有新对象生成也应该只有array4的2M对象？



求老师解惑



回答：

1、Allocation Failure，意思就是分配对象的时候内存不够触发了gc 



2、7000kb，不是文章里解释了吗，有一些是对象头，还有一些是未知对象





问题：

关于动态年龄判断的疑问：ParNew: 7017K->0K ，这次Young GC 没有Eden区的对象存活，此时Survivor区的存活对象年龄+1 变为2岁，按照文中的动态年龄判断逻辑不是应该“大于2岁”的对象进入老年代么？ 



如果按照专栏25讲描述的动态年龄判断逻辑倒是可以解释的通（一批同龄对象，直接超过了Survivor区空间的50%，此时也可能会导致对象进入老年代）

 

回答：对的，他就是同龄对象超过了Survivor的50%，所以进入老年代了





问题：

请问老师后续规划的 mysql 实战专栏，会包括分库分表部分吗？



回答：那是肯定的





问题：

老师，您好，请问，是不是不仅仅新生代eden区满了，会回收新生代，有时候，如果G1觉得region的个数可以满足200ms的时候，也会回收？那回收的是新生代吗？还是mixgc

 

回答：是的，g1感觉可以回收了也会回收，通常是新生代





问题：

老师，我接着上一条的评论发文。可能我说的不够清晰



我想问的是 对象移动至老年代的时候发生了两次GC。第一次GC是7260k--713k。然后紧接着又发生了一次GC是7017k--0k。



第一次GC是因为为array4分配内存的时候分配失败发生了一次gc。但是为什么紧接着又发生了一次GC？并且原因也是分配失败，明明堆内存此时只占用713K，是分配未知对象的时候分配失败了吗？而且这将近7M的对象都是未知对象吗？就算此时array4分配内存也才占用2M而已

 

回答：同学，你仔细看下文章，文章后面对代码做了改动的，他是两次触发了gc





问题：

G1的垃圾回收器，存不存在类似 P+CMS频繁的回收进而导致系统变慢？



看文章资料，G1变为单线程是因为region内存不够导致的。如果频繁的回收，那么内存应该是足够的，并且标记速度也很快。



回答：

g1可能会频繁回收，但是他每次回收时间可控，所以不会对系统造成太大影响





学员思考题回答：

代码改写如下： 

1、不改变年轻代的大小，改变SurvivorRatio=4，这样Eden区6912K，两个Survivor有1664K，避免一开始未知对象+128K超过S区的50%，触发动态年龄计算。 



2、代码如下： 

image.png



实际运行中，发现第15次gc后，日志输出：

[ParNew: 7223K->0K(8576K), 0.0011635 secs] concurrent mark-sweep generation total 10240K, used 675K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) 



证明15岁之后，array2进入老年代。

 

回答：很棒，优秀回答





问题：

下面是我的jdk版本：

Java HotSpot(TM) Client VM (25.121-b13) for windows-x86 JRE (1.8.0_121-b13), built on Dec 12 2016 18:17:00 by "java_re" with MS VC++ 10.0 (VS2010)



为什么我两次例子的GC日志都只有Metaspace，没有class space的消息？ 

Metaspace used 1709K, capacity 2242K, committed 2368K, reserved 4480K



回答：不同的jdk版本，细节略有不同，核心原理一致就行





学员做思考题之后的总结：

昨天实验时就发现，虽然设置了大对象的标准10M，此时分配了8.2M的对象大于8M的Eden 区，连YoungGC都不用触发 ，也不会判断是否符合大对象的标准（8.2M小于10M），直接进入老年代。当然在实际生产中不太可能出现比Eden区还大的对象。





学员实践总结：

这次参数和老师的一样了：



0.114: [GC (Allocation Failure) 0.114: [ParNew: 7420K->805K(9216K), 0.1442133 secs] 7420K->805K(19456K), 0.1443909 secs] [Times: user=0.00 sys=0.00, real=0.14 secs] 0.260: [GC (Allocation Failure) 0.260: [ParNew: 7109K->0K(9216K), 0.0061104 secs] 7109K->792K(19456K), 0.0061938 secs] [Times: user=0.03 sys=0.02, real=0.01 secs] Heap par new generation total 9216K, used 2212K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) concurrent mark-sweep generation total 10240K, used 792K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) 



因为我没有用eclipse或者idea，而是用命令行直接运行的



回答：很棒，就是要多去动手实践



问题：

老师，有个疑问。为什么G1垃圾收集器需要两个S区呢？而不是把两个S区合并为一个S区，那S区岂不是会更大（这样不就可以更大程度上避免对象进入老年代）？



既然采用的是复制算法，那么只用一个S区应该也是可以的吧，在每次新生代gc之后，把回收的 Survivor Region 复制到另一个空闲的，没人用的Region不就好了吗？



回答：

如果只有一个S区的话，假设Eden和S现在对象都放满了，需要垃圾回收，此时复制算法需要先把存活对象标记出来，放入一个地方，那此时没有一个空白区域给他放，怎么办呢？所以必须要两个S区来使用


# 050、动手实验：使用 jstat 摸清线上系统的JVM运行状况

## 1、前文回顾

上周我们已经通过带着大家分析GC日志的方式，给大家重新回顾了一遍JVM的整体运行原理，包括对象优先在Eden区分配，Young GC的触发时机和执行过程，对象进入老年代的时机，Full GC的触发时机和执行过程，相信大家通过GC日志可以把JVM整体运行原理理解的更加的深入而且透彻。

本周我们就要带着大家开始用一个工具来分析运行中的系统，他的对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。


## 2、功能强大的jstat

平时我们对运行中的系统，如果要检查他的JVM的整体运行情况，比较实用的工具之一，就是jstat

他可以轻易的让你看到当前运行中的系统，他的JVM内的Eden、Survivor、老年代的内存使用情况，还有Young GC和Full gC的执行次数以及耗时。

通过这些指标，我们可以轻松的分析出当前系统的运行情况，判断当前系统的内存使用压力以及GC压力，还有就是内存分配是否合理。下面我们就一点点来看看这个jstat工具的使用。

## 3、jstat -gc PID

首先第一个命令，就是在你们的生产机器linux上，找出你们的Java进程的PID，这个大家自行百度一下即可，用jps命令就可以看到。

接着就针对我们的Java进程执行：jstat -gc PID。这就可以看到这个Java进程（其实本质就是一个JVM）的内存和GC情况了。

运行这个命令之后会看到如下列，给大家解释一下：

![](../../pic/2020-03-08-17-28-59.png)

不知道大家发现什么没有，其实这些指标都是非常实用的jvm gc分析指标，接下来我们一步一步告诉大家该怎么使用这个工具。

另外给大家说句题外话，接下来我们有两篇文章会给大家一段模拟出生产案例的程序，然后在windows本地电脑上运行，然后我们会带着大家用jstat工具去分析他的jvm运行情况。

但是jstat工具本身如果要在windows上运行需要使用专门针对windows的版本，所以后面的文章我们会教会大家怎么在windows上使用jstat工具的。

## 4、其他的jstat命令

除了上面的jstat -gc命令是最常用的以外，他还有一些命令可以看到更多详细的信息，如下所示：

![](../../pic/2020-03-08-17-30-59.png)

大家可以后面自己有机会尝试尝试这些命令，多看看，还是挺好玩儿的，但是其实最完整、最常用、最实用的还是jstat -gc命令，基本足够我们日常分析jvm的运行情况了。

## 5、到底该如何使用jstat工具？

接着教教大家一些jstat工具使用的小技巧，先明确一下，我们分析线上的JVM进程，最想要知道的信息有哪些？

对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。

只要知道了这些信息，其实我们就可以结合之前几周的文章分析过的JVMGC优化的方法，合理分配内存空间，尽可能让对象留在年轻代不进入老年代，避免发生频繁的Full GC。这就是对JVM最好的性能优化了！

因此我们一点点分析，通过jstat工具如何得到上述信息。

## 6、新生代对象增长的速率

如果认真看过之前几周文章的同学，应该都知道，我们平时对jvm第一个要了解的事儿，就是随着系统运行，每秒钟会在年轻代的Eden区分配多少对象。

要分析这东西，你只要在线上linux机器上运行如下命令：jstat -gc PID 1000 10

这行命令，他的意思就是每隔1秒钟更新出来最新的一行jstat统计信息，一共执行10次jstat统计

通过这个命令，你可以非常灵活的对线上机器通过固定频率输出统计信息，观察每隔一段时间的jvm中的Eden区对象占用变化。

比如给大家举个例子，执行这个命令之后，第一秒先显示出来Eden区使用了200MB内存，第二秒显示出来的那行统计信息里，发信Eden区使用了205MB内存，第三秒显示出来的那行统计信息里，发现Eden区使用了209MB内存，以此类推。

此时你可以轻易的推断出来，这个系统大概每秒钟会新增5MB左右的对象。

而且这里大家可以根据自己系统的情况灵活多变的使用，比如你们系统负载很低，不一定每秒都有请求，那么可以把上面的1秒钟调整为1分钟，甚至10分钟，去看你们系统每隔1分钟或者10分钟大概增长多少对象。

还有就是一般系统都有高峰和日常两种状态，比如系统高峰期用的人很多，此时你就应该在系统高峰期去用上述命令看看高峰期的对象增长速率。然后你再得在非高峰的日常时间段内看看对象的增长速率。

按照上述思路，基本上你可以对线上系统的高峰和日常两个时间段内的对象增长速率有很清晰的了解。


## 7、Young GC的触发频率和每次耗时

接着下一步我们就想知道大概多久会触发一次Young GC，以及每次Young GC的耗时了。

其实多久触发一次Young GC就很容易推测出来了，因为系统高峰和日常时候的对象增长速率你都知道了，那么非常简单就可以推测出来高峰期多久发生一次Young GC，日常期多久发生一次Young GC。

比如你Eden区有800MB内存，那么发现高峰期每秒新增5MB对象，大概高峰期就是3分钟会触发一次Young GC。日常期每秒新增0.5MB对象，那么日常期大概需要半个小时才会触发一次Young GC。

那么每次Young GC的平均耗时呢？

简单，之前给大家说过，jstat会告诉你迄今为止系统已经发生了多少次Young GC以及这些Young GC的总耗时。

比如系统运行24小时后共发生了260次Young GC，总耗时为20s。那么平均下来每次Young GC大概就耗时几十毫秒的时间。

你大概就知道每次Young GC的时候会导致系统停顿几十毫秒。


## 8、每次Young GC后有多少对象是存活和进入老年代

接着我们想要知道，每次Young GC后有多少对象会存活下来，以及有多少对象会进入老年代。

其实每次Young GC过后有多少对象会存活下来，这个没法直接看出来，但是有办法可以大致推测出来。

之前我们已经推算出来高峰期的时候多久发生一次Young GC，比如3分钟会有一次Young GC

那么此时我们可以执行下述jstat命令：jstat -gc PID 180000 10。这就相当于是让他每隔三分钟执行一次统计，连续执行10次。

此时大家可以观察一下，每隔三分钟之后发生了一次Young GC，此时Eden、Survivor、老年代的对象变化。

正常来说，Eden区肯定会在几乎放满之后重新变得里面对象很少，比如800MB的空间就使用了几十MB。Survivor区肯定会放入一些存活对象，老年代可能会增长一些对象占用。所以这里的关键，就是观察老年代的对象增长速率。

从一个正常的角度来看，老年代的对象是不太可能不停的快速增长的，因为普通的系统其实没那么多长期存活的对象。如果你发现比如每次Young GC过后，老年代对象都要增长几十MB，那很有可能就是你一次Young GC过后存活对象太多了。

存活对象太多，可能导致放入Survivor区域之后触发了动态年龄判定规则进入老年代，也可能是Survivor区域放不下了，所以大部分存活对象进入老年代。

最常见的就是这种情况。如果你的老年代每次在Young GC过后就新增几百KB，或者几MB的对象，这个还算情有可缘，但是如果老年代对象快速增长，那一定是不正常的。

所以通过上述观察策略，你就可以知道每次Young GC过后多少对象是存活的，实际上Survivor区域里的和进入老年代的对象，都是存活的。

你也可以知道老年代对象的增长速率，比如每隔3分钟一次Young GC，每次会有50MB对象进入老年代，这就是年代对象的增长速率，每隔3分钟增长50MB。

## 9、Full GC的触发时机和耗时

只要知道了老年代对象的增长速率，那么Full GC的触发时机就很清晰了，比如老年代总共有800MB的内存，每隔3分钟新增50MB对象，那么大概每小时就会触发一次Full GC。

然后可以看到jstat打印出来的系统运行起劲为止的Full GC次数以及总耗时，比如一共执行了10次Full GC，共耗时30s，每次Full GC大概就是需要耗费3s左右。

## 10、本文总结

通过本文对jstat命令的介绍，以及结合我们之前学习过的jvm运行原理，我们教给了大家这套分析线上系统jvm运行情况的技巧

大家完全可以灵活运行jstat这个实用的工具，轻而易举的掌控到线上jvm运行的详细情况，然后针对jvm的具体运行情况去进行有针对性的优化。

另外，很多同学会问了：老师，其实有很多其他的工具也特别好用啊，比如JConsole、VisualVM等可视化的监控工具，还有其他一些开源的监控系统，都是可视化的。


针对这个问题，其实我也没说不可以用那些可视化工具，下篇文章我们就要给大家介绍更多的可视化监控JVM的工具。

但是有一点要告诉大家，一个优秀、合格的工程师，他一定是可以非常灵活的运用各种命令行工具，在命令行就搞定一切的。

所以jstat作为一个最简单易用、高效实用的命令行jvm监控工具，其实绝对是值得大家首先掌握他的。因为每个人的公司情况不一样，万一你公司不支持你用各种可视化工具呢？那你就必须从最“low”最原始的命令行工具开始，快速上手实用，定位问题。

而且其实你理解了本文的思想之后，你用其他任何工具，都能轻松的把线上jvm的运行情况通过工具提供的数据分析清楚。

## 11、今日思考题

今天交给大家一个练习题，就是在自己线上负责的系统使用jstat命令，按照上述我们介绍的思路，把以下jvm运行情况全部摸出来：

![](../../pic/2020-03-08-17-43-05.png)




# 051、动手实验：使用jmap和jhat摸清线上系统的对象分布

## 1、前文总结

本文我们继续给大家介绍两个平时工作里非常实用的工具，jmap和jhat。

这两个工具可以帮助我们观察线上JVM中的对象分布，了解到你的系统平时运行过程中，到底哪些对象占据了主角位置，他们占据了多少内存空间，让你对你的系统运行有更加细致的了解。

## 2、使用jmap了解系统运行时的内存区域

其实如果单单只是要了解JVM的运行状况，然后去进行JVM GC优化，通常来说jstat就完全够用了

但是有的时候可能我们会发现JVM新增对象的速度很快，然后就想要去看看，到底什么对象占据了那么多的内存。

如果发现有的对象在代码中可以优化一下创建的时机，避免那种对象对内存占用过大，那么也许甚至可以去反过来优化一下代码。

当然，其实如果不是出现OOM那种极端情况，也并没有那么大的必要去着急优化代码。

但是这篇文章我们来学习一下如何了解线上系统jvm中的对象分布，也是有好处的，比如之前我们在上周的案例中就发现年轻代里总是有500kb左右的未知对象，大家是不是会很好奇？如果可以看到jvm中这500kb的对象到底是什么就好了，所以学习一下这个技巧是有用的。

先看一个命令：jmap -heap PID

这个命令可以打印出来一系列的信息，我们就不长篇大论的粘贴出来具体的信息了，因为内容篇幅太大了，其实也没太大意义，因为里面的东西大家自己看字面意思都能看懂的。我们就简单给大家说一下这里会打印出来什么东西。

大致来说，这个信息会打印出来堆内存相关的一些参数设置，然后就是当前堆内存里的一些基本各个区域的情况

比如Eden区总容量、已经使用的容量、剩余的空间容量，两个Survivor区的总容量、已经使用的容量和剩余的空间容量，老年代的总容量、已经使用的容量和剩余的容量。

但是这些信息大家会想了，其实jstat已经有了啊！对的，所以一般不会用jmap去看这些信息，毕竟他信息还没jstat全呢，因为没有gc相关的统计。

## 3、使用jmap了解系统运行时的对象分布

其实jmap命令比较有用的一个使用方式，是如下的：jmap -histo PID

这个命令会打印出来类似下面的信息：

![](../../pic/2020-03-08-17-48-27.png)

这个就很有意思了，各位同学看上述打印出来的东西，他会按照各种对象占用内存空间的大小降序排列，把占用内存最多的对象放在最上面。

所以如果你只是想要简单的了解一下当前jvm中的对象对内存占用的情况，只要直接用jmap -histo命令即可，非常好用

你可以快速了解到当前内存里到底是哪个对象占用了大量的内存空间。

## 4、使用jmap生成堆内存转储快照

但是如果你仅仅只是看一个大概，感觉就只是看看上述那些对象占用内存的情况，感觉还不够，想要来点深入而且仔细点的

那就可以用jmap命令生成一个堆内存快照放到一个文件里去，用如下的命令即可：

jmap -dump:live,format=b,file=dump.hprof PID

这个命令会在当前目录下生成一个dump.hrpof文件，这里是二进制的格式，你不能直接打开看的，他把这一时刻JVM堆内存里所有对象的快照放到文件里去了，供你后续去分析。

## 5、使用jhat在浏览器中分析堆转出快照

接着就可以使用jhat去分析堆快照了，jhat内置了web服务器，他会支持你通过浏览器来以图形化的方式分析堆转储快照

使用如下命令即可启动jhat服务器，还可以指定自己想要的http端口号，默认是7000端口号：

jhat dump.hprof -port 7000

接着你就在浏览器上访问当前这台机器的7000端口号，就可以通过图形化的方式去分析堆内存里的对象分布情况了。

这里我们先简单介绍一下，后面马上有两个案例，jstat、jmap、jhat我们都会带着大家动手来玩一下的。


## 6、今日思考题

今天留给大家的作业，就是自己去线上系统的机器上，用jmap -histo看看对象大致分布情况，然后用jmap生成一个堆转储快照，再用jhat分析一下堆转储快照，看看当前系统运行的时候，各种对象的分布情况。



# 052、从测试到上线：如何分析JVM运行状况及合理优化？

## 1、前文回顾

前面两篇文章，已经给大家介绍了jstat、jmap、jhat等工具，可以非常轻松的分析出系统运行时的JVM状况，包括内存使用压力还有GC压力，包括内存中的对象分布情况。

这篇文章，我们结合之前介绍过的两个工具，给大家做一个实际开发、测试到上线的一个整体JVM优化的梳理。

## 2、开发好系统之后的预估性优化

大家平时如果在开发一个新系统的时候，完成开发之后，是不是就要经历测试以及上线的过程？


此时在系统开发完毕之后，实际上各位同学就应该参照之前我们多个案例中介绍的思路，对系统进行预估性的优化。

那什么叫做预估性的优化呢？

就是跟之前案例中说的一样，自行估算系统每秒大概多少请求，每个请求会创建多少对象，占用多少内存，机器应该选用什么样的配置，年轻代应该给多少内存，Young GC触发的频率，对象进入老年代的速率，老年代应该给多少内存，Full GC触发的频率。

这些东西其实是可以根据你自己写的代码，大致合理的预估一下的。

在预估完成之后，就可以采用之前多个案例介绍的优化思路，先给自己的系统设置一些初始性的JVM参数

比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值，等等。

优化思路其实简单来说就一句话：尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。


这个之前几周内容都在围绕这个核心在讲述，相信大家现在都理解的很清楚了。实际上这个过程应该是在新系统开发完毕之后必须有的一个环节。

## 3、系统压测时的JVM优化

通常一个新系统开发完毕之后，就会经过一连串的测试

从本地的单元测试，到系统集成测试，再到测试环境的功能测试，预发布环境的压力测试，要保证系统的功能全部正常

而且在一定压力下性能、稳定性和并发能力都正常，最后才会部署到生产环境运行。

这里非常关键的一个环节就是预发布环境的压力测试，通常在这个环节，会使用一些压力测试工具模拟比如1000个用户同时访问系统，造成每秒500个请求的压力，然后看系统能否支撑住每秒500请求的压力。同时看系统各个接口的响应延时是否在比如200ms之内，也就是接口性能不能太慢，或者是在数据库中模拟出来百万级单表数据，然后看系统是否还能稳定运行。

具体如何进行系统压测，不是我们这里要讲述的内容，大家自行百度一下“Java压力测试”，就会看到很多开源的工具，可以轻松模拟出N个用户同时访问你系统的场景，还能给你一份压力测试报告，告诉你系统可以支撑每秒多少请求，包括系统接口的响应延时。

在这个环节，通常压测工具会对系统发起持续不断的请求，持续很长时间，比如几个小时，甚至几天时间。

所以此时，大家完全就可以在这个环节，对测试机器运行的系统，采用jstat工具来分析在模拟真实环境的压力下，JVM的整体运行状态。

具体如何使用jstat来进行分析，之前都讲的很详细了，包括如何借助jstat的各种功能分析出来以下JVM的关键运行指标：新生代对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。

然后根据压测环境中的JVM运行状况，如果发现对象过快进入老年代，可能是因为年轻代太小导致频繁Young GC，然后Young GC的时候很多对象还是存活的，结果Survivor也太小，导致很多对象频繁进入老年代。当然也可能是别的什么原因。

此时就需要采用之前介绍的优化思路，合理调整新生代、老年代、Eden、Survivor各个区域的内存大小，保证对象尽量留在年轻代，不要过快进入老年代中。

之前很多人网上会胡乱搜索JMV优化的博客，看到里面人家怎么优化，你就怎么优化

比如很多博客说年轻代和老年代的占比一般是3:8，其实完全是片面的。每个系统都是不一样的，特点不同，复杂度不同。

大家记住一点：真正的优化，必须是你根据自己的系统，实际观察之后，然后合理调整内存分布，根本没什么固定的JVM优化模板。

当你对压测环境下的系统优化好JVM参数之后，观察Young GC和Full GC频率都很低，此时就可以部署系统上线了。


## 4、对线上系统进行JVM监控

当你的系统上线之后，你就需要对线上系统的JVM进行监控，这个监控通常来说有两种办法。

第一种方法会“low”一些，其实就是每天在高峰期和低峰期都用jstat、jmap、jhat等工具去看看线上系统的JVM运行是否正常，有没有频繁Full GC的问题。

如果有就优化，没有的话，平时每天都定时去看看，或者每周都去看看即可。


第二种方法在中大型公司里会多一些，大家都知道，很多中大型公司都会部署专门的监控系统，比较常见的有Zabbix、OpenFalcon、Ganglia，等等。

然后你部署的系统都可以把JVM统计项发送到这些监控系统里去。

此时你就可以在这些监控系统可视化的界面里，看到你需要的所有指标，包括你的各个内存区域的对象占用变化曲线，直接可以看到Eden区的对象增速，还会告诉你Young GC发生的频率以及耗时，包括老年代的对象增速以及Full GC的频率和耗时。

而且这些工具还允许你设置监控。也就是说，你可以指定一个监控规则，比如线上系统的JVM，如果10分钟之内发生5次以上Full GC，就需要发送报警给你。比如发送到你的邮箱、短信里，这样你就不用自己每天去看着了。

对于我们而言，主要会带大家使用的就是JDK自身提供的命令行工具，包括jstat、jmap和jhat

其实把这些命令行用好了，基本线上系统的JVM监控和优化都能搞定了。而且我本人而言，还是非常推崇工程师平时除了要会用图形化工具，还必须得熟练使用命令行的工具，这才像一个“工程师”应该有的样子。

简单一句话总结：对线上运行的系统，要不然用命令行工具手动监控，发现问题就优化，要不然就是依托公司的监控系统进行自动监控，可视化查看日常系统的运行状态。

## 5、今日思考题

你们公司的系统开发流程里有压测环节吗？

如果有，你能否在自己的工作流程中加入一项，在开发之后先进行预估性JVM优化，然后再在压测环境进行测试性JVM优化。

你们线上生产环境有没有JVM监控方案？

如果没有，建议在工作内容中引入一项，每天日常工作可以在固定时间段去线上机器里用命令行工具观察一下JVM运行状态，作为日常线上系统巡查的一个工作内容。

如果你们公司有类似Zabbix、OpenFalcon之类的监控系统，是否对线上系统都指定了JVM GC监控？如果JVM发生频繁Full GC能否及时通知到你？



# 053、案例实战：每秒10万并发的BI系统，如何定位和解决频繁Young GC问题？

针对39讲进行模拟

## 06、模拟代码的JVM参数设置

接着我们会用一段程序来模拟出上述BI系统那种频繁Young GC的一个场景，此时JVM参数如下所示：

-XX:NewSize=104857600 -XX:MaxNewSize=104857600 -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3145728 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log

大家只要注意一下上述我们把堆内存设置为了200MB，把年轻代设置为了100MB，然后Eden区是80MB，每块Survivor区是10MB，老年代也是100MB。

我们把案例中的内存大小适当缩小了一些，这样方便大家在本地windows电脑来运行试验。


## 07、示例程序

![](../../pic/2020-03-08-18-54-22.png)

针对这段示例程序给大家做一点说明。

Thread.sleep(30000); 

为什么刚开始先休眠30s？

因为一会儿会告诉大家，程序刚启动，必须得先让我们找到这个程序的PID，也就是进程ID，然后再执行jstat命令来观察程序运行时JVM的状态。

接着看loadData()方法内的代码，其实非常简单，他会循环50次，模拟每秒50个请求

然后每次请求会分配一个100KB的数组，模拟每次请求会从数据存储中加载出来100KB的数据。接着会休眠1秒钟，模拟这一切都是发生在1秒内的。

其实这些对象都是短生存周期的对象，所以方法运行结束直接对象都是垃圾，随时可以回收的。

然后在main()方法里有一个while(true)循环，模拟系统按照每秒钟50个请求，每个请求加载100KB数据的方式不停的运行，除非我们手动终止程序，否则永不停歇。


## 08、如何在windows上执行命令？

这里交给大家一个windows上做实验特别好用的工具，就是Git for Windows

大家可能疑惑，这跟Git有什么关系？他不是一个版本管理工具吗？

没错，但是这个Git for Windows，你主要安装之后，就可以在windows上启动一个Git Bash的窗口，然后你可以随意执行各种命令，非常的好用。

所以推荐给大家这个工具的官网：https://gitforwindows.org/

大家自己到官网里下载最新版本即可，安装和使用非常的简单。

在你安装完毕之后，在windows桌面上右击的时候，会看到一个“Git Bash Here”的选项，此时选择他，就可以直接打开一个命令行窗口，里面可以随意执行命令。

当然，其实如果你不想那么麻烦，也可以直接打开windows自己的命令行窗口，在里面也可以执行jps、jstat等命令，这也是没问题的。只不过我习惯于通过Git for Windows来执行一些命令。

## 09、通过jstat观察程序的运行状态

接着我们使用预订的JVM参数启动程序，此时程序会先进入一个30秒的休眠状态，此时尽快执行jps命令，查看一下我们启动程序的进程ID，如下图所示：

![](../../pic/2020-03-08-19-00-20.png)

此时会发现我们运行的Demo1这个程序的JVM进程ID是51464。

然后尽快执行下述jstat命令：jstat -gc 51464 1000 1000

他的意思就是针对51464这个进程统计JVM运行状态，同时每隔1秒钟打印一次统计信息，连续打印1000次。

然后我们就让jstat开始统计运行，每隔一秒他都会打印一行新的统计信息，过了几十秒后可以看到如下图所示的统计信息：

![](../../pic/2020-03-08-19-01-30.png)

接着我们一点点来分析这个图。首先我们先看如下图所示的一段信息：

![](../../pic/2020-03-08-19-02-18.png)

这个EU大家应该还记得，就是之前我们所说的Eden区被使用的容量，可以发现他刚开始是3MB左右的内存使用量

接着从我们程序开始运行，会发现每秒钟都会有对象增长，从3MB左右到7MB左右，接着是12MB，17MB，22MB，每秒都会新增5MB左右的对象。

这个跟我们写的代码是完全吻合的，我们就是每秒钟会增加5mB左右的对象。

然后当Eden区使用量达到70多MB的时候，再要分配5MB的对象就失败了，此时就会触发一次Young GC，然后大家继续看下面的图：

![](../../pic/2020-03-08-19-04-14.png)

注意看上面红圈里的内容，大家会发现，Eden区的使用量从70多MB降低为了1MB多，这就是因为一次Young GC直接回收掉了大部分对象。

所以我们现在就知道了，针对这个代码示例，可以清晰的从jstat中看出来，对象增速大致为每秒5MB左右，大致在十几秒左右会触发一次Young GC


这个就是Young GC的触发频率，以及每次Young GC的耗时，大家

![](../../pic/2020-03-08-19-05-40.png)


上图清晰告诉你了，一次Young GC回收70多MB对象，大概就1毫秒，所以大家想想，Young GC其实是很快的，即使回收800MB的对象，也就10毫秒那样。

所以你想如果是线上系统，他Eden区800MB的话，每秒新增对象50MB，十多秒一次Young GC，也就10毫秒左右，系统卡顿10毫秒，几乎没什么大影响的。

所以我们继续推论，在这个示例中，80MB的Eden区，每秒新增对象5MB，大概十多秒触发一次Young GC，每次Young GC耗时在1毫秒左右。

那么每次Young GC过后存活的对象呢？

简单看上上图，S1U就是Survivor中被使用的内存，之前一直是0，在一次Young GC过后变成了675KB，所以一次Young GC后也就存活675KB的对象而已，轻松放入10MB的Survivor中。

而且大家注意上上图中的OU，那是老年代被使用的内存量，在Young GC前后都是0

这说明这个系统运行良好，Young GC都不会导致对象进入老年代，这就几乎不需要什么优化了。因为几乎可以默认老年代对象增速为0，Full  GC发生频率趋向于0，对系统无影响。

所以大家回顾一下，通过一个示例程序的运行，是不是可以通过jstat分析出来以下信息：

![](../../pic/2020-03-08-17-43-05.png)


## 10、今日思考题

大家可以让这个程序多运行一段时间，反复观察其每次Young GC之后的Eden、Survivor、Old区的内存变化

然后多思考思考，对一个运行中的系统，到底要观察些什么东西？

## 自己运行结果

运行代码

```java
public class Demo5 {

    public static void main(String[] args) throws InterruptedException {
        Thread.sleep(30000);
        while (true) {
            loaddata();
        }
    }

    public static void loaddata() throws InterruptedException{//模拟秒钟产生5M的垃圾
        byte[] data = null;
        for (int i =0 ; i < 50; i++) {
            data = new byte[100*1024];
        }
        Thread.sleep(1000);
    }
}


```


![](../../pic/2020-03-08-19-19-29.png)


问题：初始化的E区3M是哪里的？



# 054、案例实战：每日百亿数据量的实时分析引擎，如何定位和解决频繁Full GC问题？

## 8、运行程序用的示例JVM参数

下面的参数唯一修改的就是“”，把大对象阈值修改为了20MB，避免我们程序里分配的大对象直接进入老年代。


-XX:NewSize=104857600 -XX:MaxNewSize=104857600 -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log

100M的年轻代，80M的E区；100M的老年代


## 9、示例程序

![](../../pic/2020-03-08-19-45-42.png)


大概意思其实就是，每秒钟都会执行一次loadData()方法，他会分配4个10MB的数组，但是都立马成为垃圾，但是会有data1和data2两个10MB的数组是被变量引用必须存活的，此时Eden区已经占用了六七十MB空间了，接着是data3变量依次指向了两个10MB的数组，这是为了在1s内触发Young GC的。


## 10、基于jstat分析程序运行的状态

![](../../pic/2020-03-08-19-52-34.png)

接着我们一点点来分析这个jvm的运行状态。首先我们先看如下一行截图：

![](../../pic/2020-03-08-19-53-00.png)

在这里最后一行，可以清晰看到，程序运行起来之后，突然在一秒内就发生了一次Young GC，这是为什么呢？

很简单，按照我们上述的代码，他一定会在一秒内触发一次Young GC的。

Young GC过后，我们发现S1U，也就是一个Survivor区中有587KB的存活对象，这应该就是那些未知对象了。

然后我们明显看到在OU中多出来了30MB左右的对象，因此可以确定，在这次Young GC的时候，有30MB的对象存活了，此时因为Survivor区域放不下，所以直接进入老年代了。

我们接着看下面的截图：

![](../../pic/2020-03-08-19-57-16.png)

大家看上图中红圈的部分，很明显每秒会发生一次Young GC，都会导致20MB~30MB左右的对象进入老年代

因为每次Young GC都会存活下来这么多对象，但是Survivor区域是放不下的，所以都会直接进入老年代。

此时看到老年代的对象占用从30MB一路到60MB左右，此时突然在60MB之后下一秒，明显发生了一次Full GC，对老年代进行了垃圾回收，因为此时老年代重新变成30MB了。

为啥会这样？

很简单，老年代总共就100MB左右，已经占用了60MB了，此时如果发生一次Young GC，有30MB存活对象要放入老年代的话，你还要放30MB对象，明显老年代就要不够了，此时必须会进行Full GC，回收掉之前那60MB对象，然后再放入进去新的30MB对象。

所以大家可以看到，按照我们的这段代码，几乎是每秒新增80MB左右，触发每秒1次Young GC，每次Young GC后存活下来20MB~30MB的对象，老年代每秒新增20MB~30MB的对象，触发老年代几乎三秒一次Full GC，是不是跟我们上面的案例中分析的场景很类似？Young GC太频繁，而且每次GC后存活对象太多，频繁进入老年代，频繁触发老年代的GC。

那么Young GC和Full GC的耗时呢？看下图：

![](../../pic/2020-03-08-20-00-29.png)

大家看上图，有没有发现Young GC特别坑爹，28次Young GC，结果耗费了180毫秒，平均下来一次Young GC要6毫秒左右。但是14次Full GC才耗费34毫秒，平均下来一次Full GC才耗费两三毫秒。这是为什么呢？

很简单，按照上述程序，每次Full GC都是由Young GC触发的，因为Young GC过后存活对象太多要放入老年代，老年代内存不够了触发Full GC，所以必须得等Full GC执行完毕了，Young GC才能把存活对象放入老年代，才算结束。这就导致Young GC也是速度非常慢。


## 11、对JVM性能进行优化

接着我们按照之前学习的思路对JVM进行优化，很简单，他最大的问题就是每次Young GC过后存活对象太多了，导致频繁进入老年代，频繁触发Full GC

我们只需要调大年轻代的内存空间，增加Survivor的内存即可，看如下JVM参数：

-XX:NewSize=209715200 -XX:MaxNewSize=209715200 -XX:InitialHeapSize=314572800 -XX:MaxHeapSize=314572800 -XX:SurvivorRatio=2  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=20971520 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log

我们把堆大小调大为了300MB，年轻代给了200MB，同时“-XX:SurvivorRatio=2”表明，Eden:Survivor:Survivor的比例为2:1:1，所以Eden区是100MB，每个Survivor区是50MB，老年代也是100MB。

接着我们用这个JVM参数运行程序，用jstat来监控其运行状态如下：

![](../../pic/2020-03-08-20-03-06.png)

在上述截图里，大家可以清晰看到，每秒的Young gC过后，都会有20MB左右的存活对象进入Survivor，但是每个Survivor区都是50MB的大小，因此可以轻松容纳，而且一般不会过50%的动态年龄判定的阈值。

我们可以清晰看到每秒触发Yuong GC过后，几乎就没有对象会进入老年代，最终就600KB的对象进入了老年代里，其他就没有对象进入老年代了。

再看下面的截图：

![](../../pic/2020-03-08-20-03-59.png)

我们可以看到，只有Young GC，没有Full GC，而且11次Young GC才不过9毫秒，平均一次GC1毫秒都不到，没有Full GC干扰之后，Young GC的性能极高。

所以，其实这个案例就优化成功了，同样的程序，仅仅是调整了内存分配比例，立马就大幅度提升了JVM的性能，几乎把Full GC给消灭掉了。


## 12、今日思考题

这周内容学完之后，大家不用多说，直接自己按照文章的思路，写出来模拟代码，尝试用jstat去观察一下运行状态

尤其是今天的文章，需要你去亲自动手写代码，观察优化前频繁full gc的问题，然后优化jvm参数之后，再看看优化后的效果，相信大家基本从实操层面就完全明白jvm的优化方法了。


## 自己实践

代码
```java
public class Demo6 {

    public static void main(String[] args) throws InterruptedException {
        Thread.sleep(30000);
        while (true) {
            loaddata();
        }
    }

    public static void loaddata() throws InterruptedException{
        byte[] data = null;
        for (int i =0 ; i < 4; i++) {//40M的垃圾
            data = new byte[10*1024*1024];
        }
        byte[] data1 = new byte[10*1024*1024];
        byte[] data2 = new byte[10*1024*1024];
        byte[] data3 = new byte[10*1024*1024];
        data3 = new byte[10*1024*1024];
        Thread.sleep(1000);
    }
}
```



![](../../pic/2020-03-08-20-14-05.png)



优化过参数之后：

![](../../pic/2020-03-08-20-54-03.png)

可以看到老年代的数据基本没有变化，都在新生代中进行了回收。


# 055、第8周作业


思考题，结合你们系统的业务来分析，遇到频繁GC该怎么处理？

本周的作业非常简单，学完了这周内容，希望大家务必制定好自己公司从开发、测试到上线的全流程的JVM优化规范，每个环节都需要进行JVM优化。

同时对生产环境的系统需要制定好JVM监控方案，无论是手动监控，还是基于监控系统，都需要有。

同时去对你们生产系统按照本周教的方法观察一下运行状态，有问题的话可以尝试优化一下，亲自动手实战一下。

# 056、第8周答疑：本周问题答疑汇总

第8周答疑：

本周问题答疑汇总



问题：

我觉得有点虚了，我从今儿早上回来就一直试(工作准备加班完成了)，3个实验gc都和老师不一样，现在版本换成和老师的一样了，同样是不一样，老师的gc日志明显是老年代只有2m，我的不知道为什么gc后有5m。百思不得其解，这到底是为什么呢，是否有同学测试出来的结果和老师的一样？



回答：

别着急，说实话，细微的差别都是正常的，千万不要在jvm实验中钻牛角尖。因为eclipse、intellij idea、包括笔记本硬件、操作系统，其实都会对实验结果产生影响的。核心是理解我讲解的原理，然后结合自己的实验结果去分析大的原理，而不是扣细微的细节，jvm自身内置会产生一些对象，所以对象占用之类的，都是不一样的





问题：

实验了一下，又颠覆了我昨天的认知：触发了YoungGC，判断存活对象是否大于老年代剩余，即晋升失败 -ParNew (promotion failed)。如果晋升失败，这时触发Old GC，且所有的存活对象都会直接晋升到老年代。不管Survivor区放不放的下部分存活对象。而昨天提到的“部分晋升”的前提是晋升过程中不会触发Old GC



回答：

非常好，多动手试验





问题：

今天的课程有点颠覆我以前的认知了。。。我一直认为是发生OldGC后，一次性怼这个6M多的数据进入老年代的，按照老师你的讲解，它是分批进入老年代的呀



回答：

不是的，就是直接放入老年代，我分步骤讲解，是拆解那个过程给你理解的，不要认为是拆分开来走的



学员思考题回答：

系统如何尽量减少FULL GC？ 

一、首先说明什么情况下发生 full gc：

1、Minor GC 前：

年轻代对象大小>老年代可用内存&&没开通内存分配担保情况 

年轻代对象大小>老年代可用内存&&开通内存分配担保情况下，历次年轻代GC进入老年代大小平均值>老年代可用内存大小 

2、Minor GC 后，老年代放不下GC后存活的对象 



二、为了避免full gc：使每次minor gc后，存活的对象尽量能放在s区，不要放到老年代： 

可以调大survivor区的大小。考虑到动态年龄判断，如果系统资源比较足，可以估算每次minor gc后，存活对象的大概大小，将survivor区内存设置为这个内存的一倍 

如果系统运算时间比较长，导致对象的年龄比较大，可以适当调大"-XX:MaxTenuringThreshold"，使对象年龄大一些再进入老年代，这样也可以减少进入老年代的对象





问题：

老师你好，今天实验又发现个新情况：eden区放满触发了young GC，结果晋升的对象太多，触发了CMS，并把老年代放满了。后续又放入的对象把eden区占满了，再放入对象就直接放在了S区，而不是再次触发Young GC。



我花了好多时间去看gc log，然后推测 gc的算法，好费时间啊。老师有没有详细的垃圾收集算法，这样我就不用去推测了。推测了这么多，实际工作中好像又不太会遇到这种情况，挺浪费时间，但不搞清楚又不甘心



回答：你一定要明白一点，jvm的算法你永远没法完全搞明白，只要跟着文章理解大致思路和原理就行了。每个版本的算法都有区别，你要对你线上jvm的算法理解细节，只能一点一点的做测试和尝试





问题：

？？疑问，当晋升失败 - [ParNew (promotion failed): 15615K->19502K(20480K)，触发了OLd GC - [CMS: 5123K->5120K(6144K) ..]，这时全部的幸存对象进入老年代，S区是空的。



请问老师，此时回收的执行顺序是什么样的？ 本该放到S区的对象，现在是怎么处理的？



回答：先回收老年代，然后让young gc的幸存对象放入老年代中





问题：

回看这篇帖子，我终于知道我的疑问到底是什么了，也知道怎么提问了。 不想钻牛角尖，但是还是想大概明白这个问题是咋回事，希望能得到老师的指点。 所以我想问三个问题： 



1.在宏观上，其实仍然存在Eden+2S，举一个例子，现在Eden区满了，触发了一次新生代GC，于是把存活对象放到S1所属的Region。第二次，Eden区又满了，于是会触发第二次新生代GC，那么会把Eden+S1的幸存对象放入S2。 



那么第一个问题来：此时会清空S1的所有Region吗？ 



2.第二个问题：在宏观上，Eden区和S区是有比例的，比如默认的8：1：1，有800个属于Eden区的Region，那么理应有100个属于S1的Region和100个属于S2的Region。 



现在有一个新生代大小为2G的堆内存，每个Region大小为2m，Eden区占用了800个Region，两个S分别占用了100个Region。



比如在一次新生代GC过后，存活对象为100m，所以就会占用其中一个S区的50个Region。



那么为了符合Eden：S1：S2=8：1：1的比例，Eden区的Region是否应该变为400个Region，然后800-400=400的另外400个Region就成为了空闲的Region？ 



3.根据以上，是否可以得出一个结论：Survivor区是否随着Eden区的增长而变大？



回答：

1、当然会清空S1 

2、是有比例的 

3、对的，S会自然变大





问题：

大神，我之前统计系统内存就是直接使用jmeter去压测，把客户要求的tps（加了2倍去测试）。 

1使用 top 监控一段时间进程使用的内存大小 

2监控一段时间的 GC频率 

3统计结果（客户接受这样测试结果） 



请问一下大神们，这样简单暴力的方式有什么坑吗？



回答：其实没大坑，基本上可以看出来系统的具体情况





学员总结：

打卡，前面已经学习了上线前如何预估系统的压力，现在直接通过工具分析更加准确，感谢老师提供这么好的思路，现在感觉自己越来越接近具备解决生产问题的能力了，有点小激动。



回答：后面全部是大量的代码实战案例，结合各种工具分析线上生产问题，然后做出优化的实战，加油





问题：

动态年龄判断里，“年龄1+年龄2+年龄n”这句是不是指从最小年龄的对象开始依次向上与大龄对象累加大小？



比如累加到10岁的对象时，对象累加大小总和大于survivor区空间大小的50%了，那么survivor区里大于等于10岁的对象都移到老年代里



回答：没错的





问题：

在同一台机器上，启动一个java项目，就启动一个JVM进程，同一个项目项目，都运营在同一个JVM进程中，老师是这样吗？



回答：对的，就是你理解的这样子





问题：

老师，在Tomcat中启动一个war，这是启动了一个JVM进程吗，还是多个？



回答：Tomcat自己就是一个JVM进程，我们写的war包不过就是一些类而已，Tomcat加载到自己的JVM进程里去执行类的代码逻辑





问题：

看第二遍的想法： 判断是否是垃圾对象都是从GC ROOT出发的，老年代为什么没有像eden区那样一步到位把全部对象标出是否是垃圾对象？ 



是因为年轻代绝大部分的对象通过年像老年代初始标识阶段就能知道是否垃圾对象了，即通过直接引用的判断就能知道是否是垃圾对象，剩下极少部分对象是需要追踪间接引用（耗时少），所以年轻代一步到位去标识。而老年代刚好相反，很多对象是直接引用，也有很多是间接引用（比较耗时），所以分了多个阶段。



请问老师，这样理解对吗？



回答：老年代那么做是因为他不能直接stop the world去回收，那样太慢了，他要尽可能把一些环节跟工作线程并行运行，这样可以适当减轻gc对工作线程的影响





学员思考题总结：

本地实践下来，除了长期存活的那几百K对象经过15次GC进入老年代，之后每次Young GC存活对象都为0.所以频繁YoungGC，但就是触发不了FullGC。 其实这里感觉应该将年轻代调大，老年代设的小一点。比如年轻代150，老年代50，这样YoungGC频率也就可以相对低一点了，而且依然不会触发OldGC。



回答：对的，思路正确



学员总结：

非常有意思，实验有小小不同，第一次ygc之后，有8b不知道啥东西晋升老年代了，不过这个无关大雅。



问题：java项目一般都是运营在Tomcat中的，设置参数的时候，是不是只配置Tomcat的即可，还是要在程序中单独配置。 还有，这这些参数配置的作用范围是什么，是当前的JVM进程吗？



回答：对的，一般就是配置tomcat的jvm参数的，作用范围就是tomcat的jvm进程





问题：

老师我这 S0C 、S1C 的值为什么一直变化呢，他的含义是Survivor0的容量，这个容量不应该是一个定值吗



回答：正常啊，程序运行，一直触发young gc，每次gc过后存活对象先进入S0，然后下一次gc后存活对象进入S1，不就来回交替了，看来之前的文章内容还是没理解透，可以回过头二刷以前的文章



问题：

根据文章开始的例子，from和to区域只有100m，每次young gc后，会有200m的存活对象，优化后把from和to调整到200m，young gc后，存活的对象可以放到fro区域了。



那么问题来了，动态年龄判断啥时候触发啊？200m的from区，200m的存活对象，不会触发动态年龄判断吗？



回答：你可以观察文章里的情况，优化过后，一般不会触发动态年龄判定，因为S区没到50%





问题：

单单通过改变SurvivorRatio为2也可以了，只不过YGC更频繁而已；老师我这里有个问题，我本机用CMS，老年代达到50%，最多到80%就开始垃圾回收了。



我通过设置CMSInitiatingOccupancyFraction改变占比也还是老样子，这种情况算正常吗？最郁闷的一点是这个垃圾回收触发的占比通过jstat来看，每次都有点不固定，最低50%，最高80%触发。。



回答：其实也是正常的，因为看那几个条件，可能你历次升入老年代的平均对象大小会不停改变，那么自然触发老年代GC的时机不一样了

问题：

请问一下我的JDK版本是1.8.0_91, 配置-XX:+HandlePromotionFailure 时报错“Unrecognized VM option 'HandlePromotionFailure' Did you mean '(+/-)PromotionFailureALot'?”，请问是哪里配置的不对吗？



回答：那个参数在JDK 1.6之后就不需要了，可以忽略了，他默认只需要比较历次young gc后升入老年代的平均对象大小和老年代的可用空间大小就可以了，把那个参数删除就可以了





问题：

老师您好，问下G1回收器什么情况下会自动降级成parnew+cms，反过来升级的情况也可能发生嘛？



回答：G1一般不会自动降级，这个用什么垃圾回收器，都是你自己决定的



问题：

老师有个问题，我看我们生产服务器配的堆大小2g，其他都是默认。jmap看新生代eden区和survivor区的比例为8，按这比例，survivor区应该是新生代的10分之一，但是eden区有680m,survivor区却只有10m,而且每次yonggc后，eden区和survivor区的总大小都在变化，为什么呢？



回答：

那你们肯定是允许堆大小动态调整了，那个需要禁止掉的，就是-Xmx和-Xms需要一样的值

问题：

在创建对象是在eden和survivor1中随机分配内存的么？不是的话，那顺序是什么？



猜想是在eden分配，慢慢晋升到survivor1中，最后yongGC后存活的1%转移到survivor2中，对么？



回答：在eden里分配对象，gc后存活对象放入Survivor中






# 057、案例实战：每秒十万QPS的社交APP 如何优化GC性能提升3倍？

# 058、案例实战：垂直电商APP后台系统，如何对Full GC进行深度优化？

# 059、案例实战：新手工程师不合理设置JVM参数，是如何导致频繁Full GC的？

# 060、案例实战：一次线上系统每天数十次Full GC导致频繁卡死的优化实战！

# 061、案例实战：电商大促活动下，严重Full GC导致系统直接卡死的优化实战

# 062、第9周作业

# 063、第9周答疑以及学员思考题总结汇总

# 064、案例实战：一次线上大促营销活动导致的内存泄漏和Full GC优化

# 065、案例实战：百万级数据误处理导致的频繁Full GC问题优化

# 066、阶段性复习：JVM运行原理和GC原理你真的搞懂了吗？

# 067、阶段性复习：JVM性能优化到底该怎么做？

# 068、如何为你的面试准备自己负责的系统中的JVM优化案例？

# 069、关于作业的说明

# 070、第10周答疑汇总

# 071、Java程序员的梦魇：线上系统突然挂掉，可怕的OOM内存溢出！

## 1、Java程序员的梦魇：线上系统突然挂掉

大家作为一个Java程序员，平时开发系统，测试系统，上线部署系统，为了公司拼命的加班，任劳任怨的干活，然后。。。平时最害怕的是个什么事情？

想必不用我说，大家自己也知道了，就是出事故！

很多大公司管事故叫做Case，如果系统一旦出一个事故，比如线上核心系统突然宕机不可用，然后导致几个小时内用户无法下订单，进而导致公司损失几百万，甚至几千万。

或者公司的某个单点登录系统突然不可用，所有用户无法登录APP，也导致无法下单。

或者公司的缓存集群突然全面故障，然后导致公司的全部系统一起瘫痪。

或者因为某个明星突然出轨，结果导致流量集中访问某台服务器，直接把数据库搞挂了。

凡此种种，都是重大的Case。一旦有Case，就会有程序员被拉出去祭天，这是网上常见的一个段子，是不是？

其实祭天不至于那么夸张，但是一旦出了事故，总有人得去承担这个责任，去分析这个事故为什么会发生，谁的责任，后续如何改进

所以，自己负责的线上系统，或者负责维护的缓存集群，或者负责维护的数据库集群，突然莫名其妙挂掉，不可用，导致公司核心业务流程彻底中断，这个就是程序员平时最害怕的事情。


## 2、Java程序员平时最常遇到的故障：系统OOM

那么作为咱们Java程序员而言，先不考虑自己系统外部依赖的缓存、消息队列、数据库等等东西挂掉，就我们自己系统本身而言，最常见的挂掉的原因是什么？

其实就是系统OOM，也就是所谓的内存溢出！

大家之前跟着我们的专栏学习，已经对JVM的运行原理都比较了解了，那么现在我们就来想一想，所谓的JVM OOM内存溢出到底是什么？

其实说白了，也非常非常的简单，一句话形容，你的JVM内存就这么点，结果你拼命的往里面塞东西，结果内存塞不下了，不就直接溢出了吗？

![](../../pic/2020-03-08-21-01-15.png)

至于到底JVM是如何放不下对象导致内存溢出的，这个大家不要着急，情况有很多种，我们后面会一步一图一点点给大家分析的

此外我们还会结合一些案例用代码给大家演示出来发生内存溢出的一些场景，最后还会告诉大家平时对线上系统的内存溢出一般怎么来处理和解决。

通常而言，内存溢出这个问题可能对你的系统是毁灭性的打击，他代表你的JVM内存不足以支撑你的代码的运行

所以一旦发生这个情况，就会导致你的系统直接停止运转，甚至会导致你的JVM进程直接崩溃掉，进程都没了！

这个时候对于线上看起来的场景就是，用户突然发现很奇怪，为什么点击APP、点击网页，都没反应了呢？

然后大量的投诉和反馈给到客服，客服直接转移投诉给到运营，运营会直接反馈给技术人员。

这个时候技术人员往往得知这个消息会直接目瞪口呆，最害怕的事情发生了，自己负责的线上系统居然挂掉了，今年的年终奖。。。也许是泡汤了，弄不好还得提前出去找工作去了。。。

## 3、很多工程师都不知道如何处理OOM

最可怕的并不是线上系统发生了OOM，最可怕的是很多工程师压根儿就没有这种处理线上系统故障的经验

当发生OOM之后，根本不知道系统到底为什么会突然OOM？系统代码到底产生了多少对象？为什么会产生这么多对象？JVM为什么会放不下这么多对象？到底怎么去排查这个问题？又如何解决呢？

不知道，全都不知道！

因此我们的专栏接下来的几周内容，将全面围绕JVM OOM的问题展开。

我们先用一周时间带着大家一步一图分析各种可能发生OOM的情况，接着用一周的时间带着大家从一些案例入手来通过模拟代码真实感受一下OOM的发生

接着用一周的时间带着大家去学习如何监控、定位、排查、分析和解决JVM OOM的问题，最后用两周的时间带着大家去用各种真实的生产案例去体验不同场景下的OOM问题。

相信经过专栏最后几周的学习之后，每个人都能游刃有余的处理线上系统的JVM OOM问题的，最终成为JVM的实战高手。


# 072、大厂面试题：什么是内存溢出？在哪些区域会发生内存溢出？

## 1、前言

这篇文章，我们来聊一个面试常常被问的问题：JVM里的内存溢出到底是指的什么，哪些区域有可能会发生内存溢出？

要搞明白这个问题，那我们就得从头儿开始来捋一下了，我们这篇文章一步一图，从JVM的核心运行原理出发，然后给大家带出来到底哪些地方可能会发生内存溢出。


## 2、运行一个Java系统就是运行一个JVM进程

首先的话呢，大家得先搞明白一个事情，就是我们平时说启动一个Java系统，其实本质就是启动一个JVM进程。

咱们就用最最基本的情况来给大家演示一下好了，比如说下面的一段代码，是每个Java初学者都会写的一段代码：

![](../../pic/2020-03-08-21-06-37.png)

那么大家知道，当你在Eclipse或者Intellij IDEA中写好这个代码，然后通过IDE来运行这个代码的时候，会发生哪些事情吗？

首先，我们专栏最早的几篇文章就给大家说过，我们写好的代码他都是后缀为“.java”的源代码，这个代码是不能运行的。

所以第一步就是这份“.java”源代码文件必须先编译成一个“.class”字节码文件，这个字节码文件才是可以运行的，如下图所示。

![](../../pic/2020-03-08-21-07-16.png)


接着对于这种编译好的字节码文件，比如HelloWorld.class，如果里面包含了main方法，接下来我们就可以用“java命令”来在命令行执行这个字节码文件了

实际上一旦你执行“java命令”，相当于就会启动一个JVM进程。这个JVM进程就会负责去执行你写好的那些代码，如下图所示。

![](../../pic/2020-03-08-22-07-47.png)

所以首先要清楚第一点，运行一个Java系统，本质上就是启动一个JVM进程，这个JVM进程负责来执行你写好的一大堆代码。只要你的Java系统中包含一个main方法，接着JVM进程就会从你指定的这个main方法入手，开始执行你写的代码。

## 3、到底执行哪些代码：JVM得加载你写的类

大家都知道，Java是一个面向对象的语言，所以最最基本的代码组成单元就是一个一个的类，平时我们说写Java代码，不就是写一个一个的类吗？是不是。

然后在一个一个的类里我们会定义各种变量，方法，数据结构，通过if else之类的语法，写出来各种各样的系统业务逻辑，这就是所谓的编程了。

所以JVM既然要执行你写的代码，首先当然得把你写好的类加载到内存里来啊！

所以JVM的内存区域里大家都知道，有一块区域叫做永久代，当然JDK 1.8以后都叫做Metaspace了，我们也用最新的说法好了。

这块内存区域就是用来存放你系统里的各种类的信息的，包括JDK自身内置的一些类的信息，都在这块区域里。

JVM有类加载器和一套类加载的机制，我们在专栏最开始的时候都说过了，这里不再赘述，他会负责把我们写好的类从编译好的“.class”字节码文件里加载到内存里来，如下图。

![](../../pic/2020-03-08-22-09-59.png)

好，那么既然有这么一块Metaspace区域是用来存放类信息的，那是不是有可能在这个Metaspace区域里就会发生OOM？

没错，是有这种可能的。

## 4、Java虚拟机栈：让线程执行各种方法

大家都知道，我们写好的那些Java代码虽然是一个一个的类，但是其实核心的代码逻辑一般都是封装在类里面的各种方法中的

比如JVM已经加载了我们写好的HelloWorld类到内存里了，接着怎么执行他里面的代码呢？

Java语言中的一个通用的规则，就是一个JVM进程总是从main方法开始执行的，所以我们既然在HelloWorld中写了一个main()方法，那么当然得执行这个方法中的代码了。

但是等一等，JVM进程里的谁去执行main()方法的代码？

其实我们所有的方法执行，都必须依赖JVM进程中的某个线程去执行，你可以理解为线程才是执行我们写的代码的核心主体。

JVM进程启动之后默认就会有一个main线程，这个main线程就是专门负责执行main()方法的。

![](../../pic/2020-03-08-22-12-39.png)

现在又有一个问题了，在main()方法里定义了一个局部变量，“message”，那么大家回忆一下，这些方法里的局部变量可能会有很多，那么这些局部变量是放在哪里的呢？

很简单，每个线程都有一个自己的虚拟机栈，就是所谓的栈内存

然后这个线程只要执行一个方法，就会为方法创建一个栈桢，将栈桢放入自己的虚拟机栈里去，然后在这个栈桢里放入方法中定义的各种局部变量，如下图所示。

![](../../pic/2020-03-08-22-13-50.png)

好，现在问题来了，大家如果还记得之前我们讲过的一个参数，应该都知道，我们是可以设置JVM中每个线程的虚拟机栈的内存大小的，一般是设置为1MB。

那么既然每个线程的虚拟机栈的内存大小是固定的，是否可能会发生虚拟机栈的内存溢出？

没错，所以第二块可能发生OOM的区域，就是每个线程的虚拟机栈内存。


## 5、堆内存：放我们创建的各种对象

最后我们知道，我们写好的代码里，特别在一些方法中，可能会频繁的创建各种各样的对象，这些对象都是放在堆内存里的，如下图所示。

![](../../pic/2020-03-08-22-15-33.png)

而且我们通过之前的学习，也都知道了一点，通常我们在JVM中分配给堆内存的空间其实一般是固定的

既然如此，我们还不停在堆内存里创建对象，是不是说明，堆内存也有可能会发生内存溢出？

没错，第三块可能发生内存溢出的区域，就是堆内存空间！


## 6、本文总结

这篇文章我们从Java代码的运行的角度去分析了一下，我们写好的代码在运行的过程中涉及到了哪几块内存区域，然后这几块内存区域是不是就是有可能发生内存溢出的区域

大家先通过这篇文章的一步一图分析回顾一下，脑子里慢慢形成一些流动的图形，接下来三天，我们就分别来分析一下Metaspace、Java虚拟机栈和堆内存这几块内存区域到底在什么情况下会发生内存溢出。

# 073、Metaspace区域是如何因为类太多而发生内存溢出的？

## 1、前文回顾

上一篇文章我们已经把JVM的运行原理重新回顾了一遍，大家脑子里应该能重新浮现出JVM运行我们写的那些代码的流程图了。

而且结合那个运行流程，我们也点出来了有哪几块区域可能会发生内存溢出，那么今天我们就来着重分析一下Metaspace区域到底为什么会发生内存溢出。


## 2、Metaspace区域是如何触发内存溢出的？

好，我们通过之前的学习都知道，在启动一个JVM时是可以设置很多参数的，其中有一些参数就是专门用来设置Metaspace区域的内存大小的，大家如果有遗忘的回顾一下之前的文章即可。

如下两个参数就是用来设置Metaspace区域大小的：

-XX:MetaspaceSize=512m 

-XX:MaxMetaspaceSize=512m

我们看下图，图中我们就限定了Metaspace区域的内存大小为512m。

![](../../pic/2020-03-08-22-19-07.png)

所以实际上来说，在一个JVM中，Metaspace区域的大小是固定的，比如512MB。

那么一旦JVM不停地加载类，加载了很多很多的类，然后Metaspace区域放满了，此时会如何？大家看下图。

![](../../pic/2020-03-08-22-19-42.png)

大家如果还记得之前我们说过的频繁Full GC触发的几个问题，其中之一就是Metaspace区域满就会触发Full GC，Full GC会带着一块进行Old GC就是回收老年代的，也会带着回收年轻代的Young GC。

当然，Full GC的时候，必然会尝试回收Metaspace区域中的类，如下图所示。

![](../../pic/2020-03-08-22-20-20.png)

所以一旦Metaspace区域满了，此时会触发Full GC，连带着回收Metaspace里的类。

那么什么样的类才是可以被回收的呢？

这个条件是相当的苛刻，包括不限于以下一些：比如这个类的类加载器先要被回收，比如这个类的所有对象实例都要被回收，等等。

所以一旦你的Metaspace区域满了，未必能回收掉里面很多的类

那么一旦回收不了多少类，此时你的JVM还在拼命的加载类放到Metaspace里去，你觉得此时会发生什么事情？

显而易见，一旦你尝试回收了Metaspace中的类之后发现还是没能腾出来太多空间，此时还要继续往Metaspace中塞入更多的类，直接就会引发内存溢出的问题。因为此时Metaspace区域的内存空间不够了。

一旦发生了内存溢出就说明JVM已经没办法继续运行下去了，此时可能你的系统就直接崩溃了，这就是Metaspace区域发生内存溢出的一个根本的原理。

## 3、到底什么情况下会发生Metaspace内存溢出？

平心而论，Metaspace这块区域一般很少发生内存溢出，如果发生内存溢出一般都是因为两个原因：

- 1，很多工程师他不懂JVM的运行原理，在上线系统的时候对Metaspace区域直接用默认的参数，即根本不设置其大小。这会导致默认的Metaspace区域可能才几十MB而已，此时对于一个稍微大型一点的系统，因为他自己有很多类，还依赖了很多外部的jar包有有很多的类，几十MB的Metaspace很容易就不够了


- 2，就是很多人写系统的时候会用cglib之类的技术动态生成一些类，一旦代码中没有控制好，导致你生成的类过于多的时候，就很容易把Metaspace给塞满，进而引发内存溢出

对于第一种问题，通常来说，有经验的工程师上线系统往往会设置对应的Metaspace大小，推荐的值在512MB那样，一般都是足够的。

对于第二种问题，我们下周就会用模拟代码给大家演示那种不停的生成大量的类的情况，让大家亲眼看到这种情况下是如何触发Metaspace内存溢出的。


## 4、本文总结

今天的文章给大家分析了一下Metaspace区域发生内存溢出的原理，同时给出了大家两种常见的触发Metaspace内存溢出的场景

大家以后只要记得，合理分配Metaspace区域，同时避免无限制的动态生成类，一般这块区域其实都是比较安全的，不至于会触发内存溢出的。



# 074、无限制的调用方法是如何让线程的栈内存溢出的？

## 1、前文回顾

上一篇文章我们已经分析了Metaspace区域内存溢出的原理和两种情况，这篇文章我们就顺着JVM的运行原理继续分析一下，线程的栈内存是如何内存溢出的。

因为在JVM加载了我们写的类到内存里之后，下一步就是去通过线程执行方法，此时就会有方法的入栈出栈相关的操作，那么我们来分析一下线程的栈内存到底是因为什么原因会导致溢出呢？


## 2、一个线程调用多个方法的入栈和出栈

大家先回顾一下之前我们画好的图，那个图是一个相对较为完整的JVM运行原理图，如下所示。

![](../../pic/2020-03-08-22-26-37.png)

![](../../pic/2020-03-08-22-27-00.png)

按照我们之前所说的，JVM启动之后，HelloWorld类被加载到了内存里来，然后就会通过main线程执行main()方法

此时在main线程的虚拟机栈里，就会压入main()方法对应的栈桢，里面就会放入main()方法中的局部变量。

大家看看上面的图，在图里是不是有main线程的虚拟机栈和main()方法的栈桢的概念？

而且我们还知道一个概念，就是我们是可以手动设置每个线程的虚拟机栈的内存大小的，一般来说现在默认都是给设置1MB

所以看下图，main线程的虚拟机栈内存大小一般也是固定的。

![](../../pic/2020-03-08-22-28-18.png)

现在回过头思考一下上面的代码，代码中是不是在main()方法中又继续调用了一个sayHello()方法？

而且sayHello()方法中也会自己的局部变量，所以此时会继续将sayHello()方法的栈桢压入到main线程的虚拟机栈中去，如下图。

![](../../pic/2020-03-08-22-29-04.png)

接着sayHello()方法如果运行完毕之后，就不需要为这个方法在内存中保存他的一些局部变量之类的东西了，此时就会将sayHello()方法对应的栈桢从main线程的虚拟机栈里出栈，如下图。

![](../../pic/2020-03-08-22-29-30.png)

再接着，一旦main()方法自己本身也运行完毕，自然会将main()方法对应的栈桢也从main线程的虚拟机栈里出栈，这里我们就不在图里表示出来了。


## 3、一个重要的概念：每次方法调用的栈桢都是要占用内存的

在这里，要给大家明确一个重要的概念，那就是每个线程的虚拟机栈的大小是固定的，比如可能就是1MB，然后每次这个线程调用一个方法，都会将本次方法调用的栈桢压入虚拟机栈里，这个栈桢里是有方法的局部变量的。

虽然说一些变量和其他的一些数据占用不了太大的内存，但是大家要记得，每次方法调用的栈桢实际上也是会占用内存的！

这是非常关键的一点，哪怕一个方法调用的栈桢就占用几百个字节的内存，那也是内存占用！

## 4、到底什么情况下会导致JVM中的栈内存溢出？

既然明确了上述前提之后，那么大家思考一下，到底什么情况下JVM中的栈内存会溢出呢？

其实非常简单，既然一个线程的虚拟机栈内存大小是有限的，比如1MB，那么假设你不停的让这个线程去调用各种方法，然后不停的把方法调用的栈桢压入栈中，是不是就会不断的占用这个线程1MB的栈内存？

![](../../pic/2020-03-08-22-31-34.png)

那么如果不停的让线程调用方法，不停的往栈里放入栈桢，此时终有一个时刻，大量的栈桢会消耗完毕这个1MB的线程栈内存，最终就会导致出现栈内存溢出的情况。

## 5、一般什么情况下会发生栈内存溢出？

通常而言，哪怕你的线程的虚拟机栈内存就128KB，或者256KB，通常都是足够进行一定深度的方法调用的。

但是如果说你要是走一个递归方法调用，那就不一定了，看下面的代码。

![](../../pic/2020-03-08-22-32-39.png)

一旦出现上述代码，一个线程就会不停的调用同一个方法，即使是同一个方法，每一次方法调用也会产生一个栈桢压入栈里，比如说对sayHello()进行100次调用，那么就会有100个栈桢压入中。

所以如果疯狂的运行上述代码，就会不停的将sayHello()方法的栈桢压入栈里，最终一定会消耗掉线程的栈内存，引发内存溢出。

所以一般来说，其实引发栈内存溢出，往往都是代码里写了一些bug才会导致的，正常情况下发生的比较少。

## 6、今日文章总结

今天我们分析了栈内存溢出的根本原理和可能触发的一个场景，就是方法递归调用

但是一般来说，其实只要注意一下代码的编写，避免出现无限制的方法递归，就一般可以避免栈内存的溢出。


# 075、对象太多了！堆内存实在是放不下，只能内存溢出！

## 1、前文回顾

之前的文章已经分析了Metaspace和栈内存两块内存区域发生内存溢出的原理，同时给出了一些较为常见的引发他们内存溢出的场景，一般只要代码上注意一些，不太容易引发那两块区域的内存溢出。

本周的重点要来了，真正最容易引发内存溢出的，说白了就是平时我们系统创建出来的对象实在是太多了，最终就导致了系统的内存溢出！

## 2、从对象在Eden区分配开始讲起

如果要把这大量的对象是如何导致堆内存溢出的给讲清楚，那就得从系统运行，在Eden区创建对象开始讲起了。

咱们都知道，平时系统运行的时候一直不停的创建对象，然后大量的对象会填满Eden区

一旦Eden区满之后，就会触发一次Young GC，然后存活对象进入S区。

![](../../pic/2020-03-08-22-36-04.png)

![](../../pic/2020-03-08-22-36-27.png)

## 3、高并发场景下导致ygc后存活对象太多

当然因为各种各样的情况，一旦出现了高并发场景，导致ygc后很多请求还没处理完毕，存活对象太多，可能就在Survivor区域放不下了，此时就只能进入到老年代里去了，老年代很快就会放满了，如下图所示。

![](../../pic/2020-03-08-22-37-11.png)

一旦老年代放满了就会触发Full GC，如下图所示。

![](../../pic/2020-03-08-22-37-38.png)

我们假设ygc过后有一批存活对象，Survivor放不了，此时就等着要进入老年代里，然后老年代也满了，那么就得等着老年代进行CMS GC，必须回收掉一批对象，才能让年轻代里存活下来的一批对象进去。

但是呢，不幸的事情发生了，老年代GC过后，依然存活下来了很多的对象！如下图所示。

![](../../pic/2020-03-08-22-38-17.png)

这个时候如果年轻代还有一批对象等着放进老年代，人家GC过后空间还是不足怎么办？

还能怎么办！只能是内存溢出了！如下图所示！

![](../../pic/2020-03-08-22-39-05.png)

所以这个时候，老年代都已经塞满了，你还要往里面放东西，而且触发了Full GC回收了老年代还是没有足够内存空间，你坚持要放？那只能给你一个内存溢出的异常了！JVM跑不动了，崩溃掉。

这个就是典型的堆内存实在放不下过多对象的内存溢出的一个典型范例。

## 4、什么时候会发生堆内存的溢出？

发生堆内存溢出的原因其实总结下来，就一句话：有限的内存中放了过多的对象，而且大多数都是存活的，此时即使GC过后还是大部分都存活，所以要继续放入更多对象已经不可能了，此时只能引发内存溢出问题。

所以一般来说发生内存溢出有两种主要的场景：

- 1、系统承载高并发请求，因为请求量过大，导致大量对象都是存活的，所以要继续放入新的对象实在是不行了，此时就会引发OOM系统崩溃

- 2、系统有内存泄漏的问题，就是莫名其妙弄了很多的对象，结果对象都是存活的，没有及时取消对他们的引用，导致触发GC还是无法回收，此时只能引发内存溢出，因为内存实在放不下更多对象了

因此总结起来，一般引发OOM，要不然是系统负载过高，要不然就是有内存泄漏的问题

这个OOM问题，一旦你的代码写的不太好，或者设计有缺陷，还是比较容易引发的，所以这个问题也是我们后面要重点分析的。

## 5、本文总结

今天的文章我们分析了发生堆内存OOM的根本原因，即对象太多，且都是存活的，即使GC过后还是没有空间了，此时放不下新的对象，JVM只能选择崩溃！

今天的文章我们分析了发生堆内存OOM的根本原因，即对象太多，且都是存活的，即使GC过后还是没有空间了，此时放不下新的对象，JVM只能选择崩溃！


# 076、动手实验：自己模拟出JVM Metaspace内存溢出的场景体验一下！

## 2、Metaspace内存溢出原理回顾

![](../../pic/2020-03-09-22-25-23.png)

在这张图片里，我们通过之前的讲解，可以清晰的看到JVM整体的运行原理，包括类加载，线程执行方法，虚拟机栈，堆内存创建对象，GC以及对象转移老年代，等等。而且在这个图里，我们也清晰标志出来了哪些环节可能会发生内存溢出。

因此在这里我们来回顾一下，Metaspace区域发生内存溢出的一个场景，说白了就是如果我们在程序里不停的动态生成类，就会导致不停的加载类到Metaspace区域里去，而且这些动态生成的类必须还得是不能被回收掉的。

接着一旦Metaspace区域满了，就会触发Full GC连带着回收Metaspace中的类，但是此时大量的类是不能被回收的。

因此即使触发过Full GC过后，Metaspace区域几乎还是不能放下任何一个类，此时必然会触发Metaspace区域的内存溢出，导致JVM也是崩溃掉，无法继续运行了。


## 3、到底什么是动态生成类？

可能有的人不太理解什么叫做动态生成类，其实很简单，我们平时正常情况下，类都是通过自己的双手一行一行代码写出来的，而且都是写的“.java”后缀的源代码文件，大家想想是不是这样？

所以很多人可能想当然的以为在JVM中的类都是我们双手写出来的，其实并不是这样子。

大家回忆一下，平时我们自己写出来的类大致长什么样子？是不是一般都包含一些静态变量、实例变量、静态方法、实例方法，里面还有一大堆的业务逻辑？大致其实类就是这么个东西。

所以既然你双手都能写出来这种普普通通的类，那么当然是有办法可以借助一些方法在系统运行的时候，通过程序动态的生成出更多的类了，这是没有问题的。

所以一旦我们程序中拼命的生成大量的类，而且这些类还不能被回收，那么必然会最终导致Metaspace区域被占满，进而导致Metaspace内存溢出了。

接着我们就来实际看看代码层面上，动态生成类到底是怎么做的吧！

## 4、一段CGLIB动态生成类的代码示例

相信大家平时无论用Eclipse还是用IntelliJ IDEA，应该都大部分人都是基于Maven来进行项目构建的，当然现在也有一些公司在用Gradle进行项目构建。

我们这里就以Maven来举例好了，如果要用CGLIB来动态生成一些类，那么必须在你项目的pom.xml中引入以下的一些依赖。

```xml
<!-- https://mvnrepository.com/artifact/cglib/cglib -->
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>

```
接着我们就可以使用CGLIB来动态生成类了，大家看下面的代码：

![](../../pic/2020-03-09-22-29-44.png)

首先我们可以看到我们在这里定义了一个类，代表了一个汽车，他有一个run()方法，执行的时候就会启动汽车，开始让汽车行驶，大家看下面的这个代码片段：

```java
 static class Car{
        public void run() {
            System.out.println("汽车启动，开始行使。。。。。");
        }
    }
```

相信关于小汽车的这个类的定义，大家都是没有问题的。那么我们接着来看下面的代码片段，我们通过CGLIB的Enhancer类生成了一个Car类的子类

注意，从这里开始，就是开始动态生成类了，大家要仔细看，看下面的代码片段：

```java
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(Car.class);
enhancer.setUseCache(false);
```

你权且当做Enhancer是用来生成类的一个API吧，看到片段里我们给Enhancer设置了一个SuperClass没有？这里的意思就是说Enhancer生成的类是Car类的子类，Car类是生成类的父类。至于那个UseCache是什么意思，就先别管了。

既然Enhancer动态生成的类是Car的子类，那么是不是Car有的方法子类都有？所以子类是不是也有Car的run()方法？

答案是肯定的，但我们现在想要在调用子类的run()方法的时候做点手脚，如下面代码片段：

```java
enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                    if (method.getName().equals("run")) {
                        System.out.println("汽车启动之前，进行安全检测。。。。。");
                        return methodProxy.invokeSuper(o,objects);
                    } else {
                        return methodProxy.invokeSuper(o,objects);
                    }
                }
            });
```
这个片段的意思是：如果你调用子类对象的run()方法，会先被这里的MethodInterceptor拦截一下，拦截之后，各位看里面的代码，是不是判断了一下，如果你调用的Method是run方法，那么就先对汽车做一下安全检查。

安全检查做完之后，再通过“methodProxy.invokeSuper(o, objects);”调用父类Car的run()方法，去启动汽车，这行代码就会执行到Car类的run()方法里去了。

到此为止，我们就已经通过CGLIB的Enhancer生成了一个Car类的子类了，而且定义好了对这个子类调用继承自父类的run()方法的时候，先干点别的，再调用父类的run()方法。

这么一搞，是不是跟下面这种在IDE里手写一个Car的子类是类似的？

看看下面的手写版本的代码：
![](../../pic/2020-03-09-22-41-02.png)

看看上面那个SafeCar作为Car的子类，是不是干了一样的事？

但是这个类需要你用双手提前写出来代码，而CGLIB Enhancer那种模式可以在系统运行期间动态的创建一个Car的子类出来，实现一样的效果

看到这里，各位应该理解这个动态创建类了！

## 5、限制Metaspace大小看看内存溢出效果

接着我们可以设置一下这个程序的JVM参数，限制他的Metaspace区域比较小一点，如下所示，我们把这个程序的JVM中的Metaspace区域设置为仅仅10m：

-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m

接着我们可以在上述代码中做点手脚，大家看到上面的代码是有一个while循环的，所以他会不停的创建Car类的子类

我们在里面可以加入一个计数器，就是看看当前创建了多少个Car的子类了，如下所示：

![](../../pic/2020-03-09-22-42-58.png)

在while循环外面加一个计数器，然后打印出当前创建了多少个类了。

接着大家用上述JVM参数来运行这个程序即可，可以看到如下所示的打印输出：

目前创建了263个Car类的子类了

![](../../pic/2020-03-09-22-43-44.png)

大家注意一下上述异常日志的两个地方，一个是在创建了263个类之后，10M的Metaspace区域就被耗尽了，接着就会看到异常中有如下的一个：Caused by: java.lang.OutOfMemoryError: Metaspace。

这个OutOfMemoryError就是经典的内存溢出的问题，而且他明确告诉你，是Metaspace这块区域内存溢出了。

而且大家可以看到，一旦内存溢出，本来在运行的JVM进程直接会崩溃掉，你的程序会退出，这就是真实的内存溢出的日志。

## 自己试验

代码：
```java
public class MetaspaceOOM {


    public static void main(String[] args) {
        long count = 0;
        while (true) {
            System.out.println("当前创建car的子类个数："+count);
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(Car.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                    if (method.getName().equals("run")) {
                        System.out.println("汽车启动之前，进行安全检测。。。。。");
                        return methodProxy.invokeSuper(o,objects);
                    } else {
                        return methodProxy.invokeSuper(o,objects);
                    }
                }
            });

            Car car = (Car)enhancer.create();
            car.run();
            count++;
        }
    }

    static class Car{
        public void run() {
            System.out.println("汽车启动，开始行使。。。。。");
        }
    }
}

```

日志

```
当前创建car的子类个数：267
Exception in thread "main" net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException-->null
	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)
	at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)
	at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117)
	at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)
	at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)
	at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)
	at com.ls.jvm.MetaspaceOOM.main(MetaspaceOOM.java:35)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459)
	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:339)
	... 6 more
Caused by: java.lang.OutOfMemoryError: Metaspace
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	... 11 more
```




# 077、动手实验：自己模拟出JVM栈内存溢出的场景体验一下！

# 078、动手实验：自己模拟出JVM堆内存溢出的场景体验一下！

# 079、案例实战：一个超大数据量处理系统是如何不堪重负OOM的？

## 1、前文回顾

之前我们已经用代码给大家都演示过几种不同的内存溢出的场景了，但是光看代码演示可能大家还是找不到感觉。因此，我们同样也会用曾经遇到过的真实线上系统运行场景来让大家看看是如何触发堆内存溢出的。

## 2、还是那个超大数据量处理系统的案例

大家是否还记得我们不止一次提过的一个超大数据量的计算引擎系统？这个系统是我们自己研发的一个非常复杂的PB级数据计算系统，远比很多流行的开源技术要强悍，架构上也非常复杂，同时处理的数据量也特别大。

但是因为这个专栏并不是给大家讲这种具体的系统，因此我们还是用简化的案例场景来给大家解释当时遇到的线上OOM问题。

之前就用这个系统案例给大家分析过GC问题，但是因为他处理的数据量实在是很大，负载也过高，所以除了GC问题以外，还有OOM问题。

首先用最最简化的一张图给大家解释系统的工作流程。简单来说，就是不停的从数据存储中加载大量的数据到内存里来进行复杂的计算，如下图所示。

![](../../pic/2020-03-09-21-10-50.png)

这个系统会不停的加载数据到内存里来计算，每次少则加载几十万条数据，多则加载上百万条数据，所以系统的内存负载压力是非常大的。

另外这里给大家多讲一些之前案例中没提到过的这个系统的一些运行流程，因为他跟我们这次讲解的OOM场景是有关系的。

这个系统每次加载数据到内存里计算完毕之后，就需要将计算好的数据推送给另外一个系统，两个系统之间的数据推送和交互，最适合的就是基于消息中间件来做

因此当时就选择了将数据推送到Kafka，然后另外一个系统从Kafka里取数据，如下图。

![](../../pic/2020-03-09-21-12-23.png)

这就是系统完整的一个运行流程，加载数据、计算数据、推送数据。


## 3、针对Kafka故障设计的高可用场景

既然系统架构如此，那么大家思考一下，数据计算系统要推送计算结果到Kafka去，万一Kafka挂了怎么办？此时就必须设计一个针对Kafka的故障高可用机制

就当时而言，刚开始负责这块的工程师选择了一个思考欠佳的技术方案。一旦发现Kafka故障，就会将数据都留存在内存里，不停的重试，直到Kafka恢复才可以，大家看下图的示意。

![](../../pic/2020-03-09-21-13-34.png)

这个时候就有一个隐患了，万一真的遇上Kafka故障，那么一次计算对应的数据必须全部驻留内存，无法释放，一直重试等待Kafka恢复，这是绝对不合理的一个方案设计。

然后数据计算系统还在不停的加载数据到内存里来处理，每次计算完的数据还无法推送到Kafka，全部得留存在内存里等着，如此循环往复，必然导致内存里的数据越来越多。

## 4、无法释放的内存最终导致OOM

正是因为有这个机制的设计，所以有一次确实发生了Kafka的短暂临时故障，也因此导致了系统无法将计算后的数据推送给Kafka

然后所有数据全部驻留在内存里等待，并且还在不停的加载数据到内存里来计算。

内存里的数据必然越来越多，每次Eden区塞满之后，大量存活的对象必须转入老年代中，而且这些老年代里的对象还是无法释放掉的。

老年代最终一定会满，而且最终一定会有一次Eden区满之后，一大批对象要转移到老年代，结果老年代即使Full gc之后还是没有空间可以放的下，最终就会导致内存溢出。然后线上收到报警说内存溢出。

最后这个系统全线崩溃，无法正常运行。

如何对这个问题进行修复呢？

其实很简单，当时就临时直接取消了Kafka故障下的重试机制，一旦Kafka故障，直接丢弃掉本地计算结果，允许释放大量数据占用的内存。后续的话，将这个机制优化为一旦Kafka故障，则计算结果写本地磁盘，允许内存中的数据被回收。

这就是一个非常真实的线上系统设计不合理导致的内存溢出问题，想必大家看了这个案例后，一定对内存溢出问题感触更加深刻了。

后面我们还将有更多的各种各样奇形怪状的OOM案例带给大家，并且要给大家介绍很多解决OOM问题的技巧。


# 080、案例实战：两个新手工程师误写代码是如何导致OOM的？

## 1、前文回顾

上周五的文章给大家介绍了一个系统设计上的缺陷导致的极端场景下的OOM，让大家从较为真实的系统案例中感受一下OOM到底是如何发生的。

今天的文章就给大家说一说之前遇到过的团队里两个新手工程师误写代码导致的OOM的问题。

## 2、第一个案例：一时迷糊写出了一个无限循环调用

第一个案例是当时团队里招聘的一个实习生同学，写出了一个代码上的bug导致线上系统出现栈内存溢出的场景。

当时有一个非常重要的系统，我们设计了一个链路监控机制，也就是会在一个比较核心的链路节点，写一些重要的日志到Elasticsearch集群里去，事后会基于ELK进行核心链路日志的一些分析，如下图所示。

![](../../pic/2020-03-09-21-24-37.png)

同时我们对这个机制做了规定，如果在某个节点写日志时发生了某些异常，此时也必须将这个链路节点的异常写入ES集群里去，因为我们在分析的时候，需要知道系统运行到这里有一个异常。

因此当时那个实习生同学写出来的伪代码大致如下：

![](../../pic/2020-03-09-21-26-07.png)

不知道大家看了上面的代码是作何感想？当时这个同学居然在log()方法中一旦ES集群出现故障的时候再次调用了自己，继续尝试将日志写入ES集群。

因此在线上系统中，有一次ES集群短暂故障了一会儿，结果直接就导致log()方法中写ES集群每次都是失败的，都会抛异常。

而一旦抛异常进入了catch语句中，就会再次重新回过头来调用log()方法。

然后log()方法再次写ES集群发现不行，继续抛异常进入catch中，再次循环调用自己。

线上系统本来在ES集群故障的时候不该有什么问题的，因为核心业务逻辑都是可以运行的，最多不过就是无法把核心日志写入ES集群罢了。

但是因为这个bug，导致在ES故障时，所有系统全部在写日志的时候，陷入了一个无限循环调用log()方法的困境中。

之前给大家演示过，一旦无限循环调用方法自己，一定会在一定时间导致线程的栈内存溢出的，此时直接会导致JVM进程的崩溃

系统居然因为这么一个小问题崩溃了！这就是一次非常真实的线上案例。

后来针对此类问题，我们都是通过严格的持续集成+严格的Code Review标准来避免的

每个人每天都会写一点代码，这个代码必须是配套单元测试可以运行的，然后全部提交到持续集成服务器上去，代码集成到整体代码中，自动运行全部单元测试+集成测试。

在单元测试+集成测试中，我们都是要求针对一些try catch中可能走到catch的分支写一些测试的，因此一旦有这类代码，每天只要工程师提交到持续集成系统上去，立马就会自动运行测试触发这个问题，就可以立刻解决了。

而且每天这一点代码也必须交给指定的其他同事进行Code Review，别人会仔细看你今天写的每一行代码，做一个审查，一旦发现问题也会打回去重新修改代码。从此之后，这种低端的问题再也没有发生过。


## 3、第二个案例：没有缓存的动态代理

第二个案例同样是之前的一个新手工程师写的，这个并不是实习生，是一个校招生同学，在团队里工作了1年左右的时间。

但是确实因为经验不足，有一次在实现一块代码机制的时候，也是犯了一个很大的错误。

简单来说，当时这个同学想要实现一个动态代理机制，也就是说在系统运行的时候，针对已有的某个类，生成一个动态代理类，也就是动态生成类，然后对那个类的一些方法调用做一些额外的处理。

当时这个是一个我们自己研发的分布式事务框架，对于这个框架是有这位同学参与在里面的，因此在框架中有时候要对一些已经有的类实现动态代理，去实现分布式事务一些的复杂底层机制。

当时大概的一个伪代码其实跟之前给大家的代码是类似的：

![](../../pic/2020-03-09-21-31-55.png)

不知道大家发现类似这种代码里的一个问题没有？比如你用CGLIB的Enhancer针对某个类动态生成了一个子类，这个子类你完全可以缓存起来，下次直接用这个已经生成好的子类来创建对象就可以了

类似下面这样：

![](../../pic/2020-03-09-21-33-37.png)

其实这个类只要生成一次就可以了，下次来直接用这个动态生成的类创建一个对象就可以了。

但是当时那个工程师没有缓存这个动态生成的类，就是每次调用方法都生成一个类，这就闯祸了。

有一次线上系统负载很高的时候，因为这个框架直接导致瞬间创建了一大堆的类，塞满了Metaspace区域无法回收，进而导致Metaspace区域直接内存溢出，系统也崩溃了，这也是一个很大的问题。

后来对于这类问题，是严格要求每次上线必须走严格的自动化压力测试，通过高并发压力下系统是否正常运行支撑24小时，来判断是否可以上线。

这样类似于这类代码在上线之前就会被压力测试露出马脚，因为压力一大，瞬间会引发这个问题。

## 4、本文总结

这周的文章，我们带着大家感受了一下各种内存溢出发生的场景，同时给出了几个真实的线上生产案例是如何导致各个内存区域溢出的

相信大家对内存溢出这个问题，有了一个更加深刻的理解。

接下来我们会带着大家一起来学习如何对线上的OOM进行监控，同时在OOM时如何让JVM自动保留现场，同时结合几个案例和工具学习，发生OOM之后如何快速排查和定位到底代码哪里出现了OOM，以及如何进行解决。


# 081、如何对对线上系统的OOM异常进行监控和报警！

## 1、前文回顾

那么现在的一个核心问题就是一旦发生了各种场景下的OOM，我们到底应该如何处理呢？

所以本周将会从OOM问题的监控开始，给大家讲OOM的排查、定位和解决的一系列思路

然后下周开始再给大家分析多个各种场景下的奇怪的OOM案例，让大家去积累丰富的OOM问题解决经验。

## 2、最佳的解决方案

我们先给大家说一种最佳的OOM监控方案，其实说白了也很简单，之前一直给大家强调，公司最好是应该有一种监控平台，比如Zabbix、Open-Falcon之类的监控平台。

如果有监控平台的话，就可以接入系统异常的一些监控和报警，你可以设置一旦系统出现了OOM异常，就发送报警给对应的开发人员，通过邮件、短信或者钉钉之类的IM工具。

这个是中大型公司里最常用的一种方案了，一般来说我们都对线上系统有以下几个层面的监控：

- 机器（CPU、磁盘、内存、网络）资源的负载情况，JVM的GC频率和内存使用率，系统自身的业务指标，系统的异常报错。

这些东西都会基于监控平台接入对应的监控项，同时设定关键监控项的一些报警阈值。

下面我来分层给大家解释一下这个所谓的监控体系的思路，我们这个专栏虽然不是专门教大家做监控的，但是因为说到了系统的JVM监控，因此可以顺带给大家说一下思路，大家再结合自己公司的监控系统去考虑一下怎么做。

## 3、一个比较成熟的系统监控体系的建议

首先通过监控平台是可以看到你的所有线上系统所在的机器资源的负载情况的，比如CPU负载，这个可以看到现在你的CPU目前的使用率有多高，比如你的CPU使用率都达到100%了，此时一定有问题了，你得检查一下为什么CPU负载那么高。

而且可以看到你的机器上磁盘IO的一些负载，包括磁盘上发生了多少数据量的IO，一些IO的耗时等等。

当然一般的业务系统本身不会直接读写自己本地的磁盘IO，最多就是写一些本地日志而已。

但是你应该关注的是你本地磁盘的使用量和剩余空间，因为有的系统因为一些代码bug，可能会一直往本地磁盘写东西，万一把你的磁盘空间写满了就麻烦了，这样也会导致你的系统无法运行。

其次可以看到你机器上的内存使用量，这个是从机器整体层面去看的，看看机器对内存使用的一些变化。

当然内存这块，比较核心的还是JVM这块的监控，我们是可以看到JVM各个内存区域的使用量的一个变化的。

最后就是机器上的网络负载，就是通过网络IO读写了多少数据，一些耗时，等等。

还有一个比较关键的，就是JVM的Full GC的频率，这个一般会用一段时间内的Full GC次数来监控，比如5分钟内发生了几次Full GC。

其实线上机器最容易出问题的主要三大块，一个是CPU，必须要对CPU的使用率做一个监控，如果CPU负载过高，比如长期使用率超过90%，就得报警了；

一个是内存，同样得监控内存的使用率，如果机器内存长期使用率超过了一定的阈值，比如长期使用率超过90%，那肯定是有问题的，随时机器内存可能就不够了；

一个是JVM的Full GC问题，假设5分钟内发生了10次Full GC，那一定是频繁Full GC了。

所以建议大家去看看自己公司是否有监控平台，同时是否建立起来基本的监控体系， 对CPU、内存、Full GC等核心问题进行了监控和自动报警。

另外比较常见的就是对系统的业务指标的监控，比如你可以在每次系统创建一个订单就上报一次监控，然后监控系统会收集你1分钟内的订单数量。然后你可以设定一个阈值，比如1分钟内要是订单数量超过了100就报警。

因为可能订单过多涉及到了一些刷单之类的行为，这就是业务系统的指标监控，这个都是你自己去进行指标上报的。

最后一个，就是系统所有的try catch中的异常报错，必须要接入报警，一旦有异常，都需要上报到监控平台，然后监控平台会告诉你，最近有一次异常，只要系统报错，你立马可以收到报警。

因此非常核心的一点，就是要对线上系统的异常进行监控，一旦JVM有OOM之类的问题可以立马感知到。

## 4、一种比较Low的JVM OOM问题的被动发现方法

如果大家实在没有上述那种监控和报警的体系，那就没办法主动感知到JVM OOM问题了，此时只能用最Low的土办法就发现OOM了。

被动发现OOM问题，主要靠两个：

第一个是线上系统假设因为OOM突然挂掉，此时一定会导致用户无法使用，然后迅速反馈到客服，客服反馈给你，你就知道自己的系统挂掉了。

第二个就是你必须去检查一下系统的线上日志，一般来说，系统有异常的时候，必须通过log4j之类的日志框架写入本地日志文件，如果这个都不做，那实在是没办法说什么了。只要你检查日志，就会发现之前给大家演示过的OOM问题。

## 5、本文总结

大家可以思考一下，在自己的公司，到底应该怎么来做这个OOM的监控，只有你监控到OOM问题了，接着才能去分析到底为什么会发生这个问题。


# 082、一个关键问题：如何在JVM内存溢出的时候自动dump内存快照？

## 2、解决OOM问题的一个初步思路

首先第一个问题，假设发生OOM了，必然说明系统中某个区域的对象太多了，塞满了那个区域，而且一定是无法回收掉那些对象，最终才会导致内存溢出的。

既然是这个思路，要解决OOM的话，首先就得知道到底是什么对象太多了最终导致OOM的？

所以你想知道什么对象太多导致OOM的，就必须得有一份JVM发生OOM时的dump内存快照

只要有了那个dump内存快照，你就可以用之前介绍过的MAT之类的工具瞬间分析得到什么对象太多了。

那么现在一个关键问题来了，到底怎么做才可以在JVM内存溢出的时候自动dump出来一份内存快照呢？

## 3、在OOM的时候自动dump内存快照

看到这里，大家必须得对一个事情有个概念，大家可以思考一下，假设JVM发生OOM了，你觉得JVM是完全来不及处理然后突然进程就没了吗？也就是JVM是看起来非常突然的自己无法控制的就挂掉了吗？

其实不是的，只要之前对JVM OOM的各种情况原理有一定的了解，就会知道JVM本身在发生OOM之前都会尽可能的去进行GC腾出来一些内存空间

如果GC后还是没有空间，放不下对象， 才会触发内存溢出的。

所以JVM自己对OOM情况的发生是完全有把控权的，他知道什么时候会触发OOM，也是他自己感觉不行的时候才会去触发的

所以OOM的发生并不是大家想的那样，突然之间内存太多了，JVM自己都没反应过来就直接崩溃了，并非如此。

因此JVM如果知道要发生OOM了，此时完全可以让他做点事情

什么事情呢？

我们可以让他在OOM时dump一份内存快照，事后我们只要分析这个内存快照，一下就可以知道是哪些可恶的对象占用了所有的内存，并且还无法释放。

此时你就需要在JVM的启动参数中加入如下的一些参数：

-XX:+HeapDumpOnOutOfMemoryError  

-XX:HeapDumpPath=/usr/local/app/oom

第一个参数意思是在OOM的时候自动dump内存快照出来，第二个参数是说把内存快照放到哪儿去

只要你加入了这两个参数，在JVM OOM崩溃的时候，无论你是立马主动收到一个报警，还是被动让客服通知了你，立马就可以去找OOM时候的内存快照了。

## 4、迄今为止我们可以得出的一份JVM参数模板

在学习完这篇文章之后，我们最常用的一些JVM参数已经全部学习完了，而且可以总结一份JVM参数模板出来供大家进行参考，大家未来对自己的系统只要根据自己的情况去调整就可以了：

“-Xms4096M -Xmx4096M -Xmn3072M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+DisableExplicitGC -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/usr/local/app/oom”

这份JVM参数模板基本上涵盖了所有你需要的一些参数

首先是各个内存区域的大小分配，这个是需要你精心调优的

其次是两种垃圾回收器的指定，接着是一些常规性的CMS垃圾回收的参数，可以帮助优化偶尔发生的Full GC性能。

最重要的，就是平时要打印出来GC日志，GC日志可以配合你用jstat工具分析GC频率和性能的时候用，jstat可以分析出来GC的频率，但是对每次具体的GC情况，可以结合GC日志来看。

还有就是在OOM的时候需要自动dump内存快照，这样即使突然发生OOM，你只要得知了这个事，立马就可以去分析内存快照了。

接下来，我们会用三篇文章来依次带着大家用MAT工具来分析Metaspace、栈内存、堆内存三种内存溢出下的内存快照文件

同时结合GC日志，让大家更加清晰的理解每次发生内存溢出时候的具体过程和原理，以及解决内存溢出的排查过程。





# 083、动手实验：Metaspace区域内存溢出的时候，应该如何解决？

## 1、前文回顾

上一讲已经说了我们处理OOM需要的一些参数，今天我们来讲一下Metaspace区域内存溢出

我们先分析一下GC日志，然后再让JVM自动dump出来内存快照，最后用MAT来分析一下这份内存快照，从内存快照里去找到内存溢出的原因。

## 2、示例代码

首先我们先上之前的那段代码：

![](../../pic/2020-03-09-21-57-15.png)

我们还是用这段代码来说明，但是要记得需要在JVM参数中加入一些东西，因为我们想看一下GC日志和导出内存快照，如下所示：

```
-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC  -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=./
```

![](../../pic/2020-03-09-21-59-39.png)

大家要注意，上面那个HeapDumpPath参数我给调整为当前项目的根目录下了，这样我们看的时候方便一些。

## 3、分析GC日志

接着我们用上述JVM参数运行这段程序，会发现项目下面多了两个文件，一个是gc.log，还有一个是java_pid910.hprof

当然不同的机器运行这个hprof文件的名字是不太一样的，因为他会用你的PID进程id作为文件名字。

接着我们先来分析一下gc.log，也就是分析一下他是如何拼命往Metaspace区域里放入大量生成的类，然后触发Full GC，接着回收Metaspace区域，回收后还是无法放下更多的类，接着才会抛出内存溢出的异常。

然后我们再用MAT分析一下OOM的时候的内存快照，带着大家学习一下如何用MAT工具找到Metaspace内存溢出问题的原因。

先把我这里的GC日志给大家抛出来，同时我们就跟着GC日志一行一行分析，到底是怎么回事，大家紧紧跟着脚步来走。

0.716: [GC (Allocation Failure) 0.717: [ParNew: 139776K->2677K(157248K), 0.0038770 secs] 139776K->2677K(506816K), 0.0041376 secs] [Times: user=0.03 sys=0.01, real=0.00 secs]

大家看这行日志，这是第一次GC，他本身是一个Allocation Failure的问题

也就是说，他是在Eden区中分配对象时，发现Eden区内存不足了，于是就触发了一次ygc。

那么，这个对象到底是什么对象？

简单，还记得我们在代码里写的么？Enhancer本身是一个对象，他是用来生成类的，如下所示：Enhancer enhancer = new Enhancer()。

接着我们基于每次Enhancer生成的类还会生成那个类的对象，如下所示：Car car = (Car) enhancer.create()。

因此上述代码不光是动态生成类，本身他也是对应很多对象的，因此你在while(true)循环里不停的创建对象，当然会塞满Eden区了，大家看上述日志：[ParNew: 139776K->2677K(157248K), 0.0038770 secs] 

这就是说，在默认的内存分配策略下，年轻代一共可用空间是150MB左右，这里还包含了一点Survivor区域的大小

然后大概都用到140MB了，也就是Eden区都塞满了，此时就触发了Allocation Failure，没Eden区的空间分配对象了，此时就触发ygc。

这个倒没什么可说的，因为之前我们都讲过了。

0.771: [Full GC (Metadata GC Threshold) 0.771: [CMS: 0K->2161K(349568K), 0.0721349 secs] 20290K->2161K(506816K), [Metaspace: 9201K->9201K(1058816K)], 0.0722612 secs] [Times: user=0.12 sys=0.03, real=0.08 secs]

接着我们来看这次GC，这就是Full GC了，而且通过“Metadata GC Threshold”清晰看到，是Metaspace区域满了，所以触发了Full GC

这个时候看下面的日志，20290K->2161K(506816K)，这个就是说堆内存（年轻代+老年代）一共是500MB左右，然后有20MB左右的内存被使用了，这个必然是年轻代用的。

然后直接就把这些对象放入老年代，为什么呢，因为下面的日志：[CMS: 0K->2161K(349568K), 0.0721349 secs] 

这里明显说了，Full GC带着CMS进行了老年代的Old GC，结果人家本来是0KB，什么都没有，然后从年轻代转移来了2161KB的对象，所以老年代变成2161KB了。

接着看日志： [Metaspace: 9201K->9201K(1058816K)]

此时Metaspace区域已经使用了差不多9MB左右的内存了，此时明显是发现离我们限制的10MB内存很接近了，所以触发了Full GC，但是对Metaspace GC后发现类全部存活了，因此还是剩余9MB左右的类在Metaspace里。

0.843: [Full GC (Last ditch collection) 0.843: [CMS: 2161K->1217K(349568K), 0.0164047 secs] 2161K->1217K(506944K), [Metaspace: 9201K->9201K(1058816K)], 0.0165055 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]

接着又是这次Full GC，人家也说的很清晰了，Last ditch collection

就是说，最后一次拯救的机会了，因为之前Metaspace回收了一次但是没有类可以回收，所以新的类无法放入Metaspace了。

所以再最后试一试Full GC，能不能回收掉一些

结果如下：[Metaspace: 9201K->9201K(1058816K)], 0.0165055 secs]

Metaspace区域还是无法回收掉任何的类，几乎还是占满了我们设置的10MB左右。

![](../../pic/2020-03-09-22-12-00.png)

接着就直接JVM退出了，退出的时候就打印出了当前内存的一个情况，年轻代和老年代几乎没占用，但是Metaspace的capacity是10MB，使用了9MB左右，无法再继续使用了，所以触发了内存溢出。

此时就会在控制台打印出如下的一行东西：

![](../../pic/2020-03-09-22-12-34.png)

明确抛出异常，说OutOfMemoryError，原因就是Metaspace区域满了导致的。

因此假设是Metaspace内存溢出了，然后客服通知了我们，或者我们自己监控到了异常，此时直接去线上机器看一下GC日志和异常信息就可以了，通过上述分析立刻就知道了，系统是如何运行的，触发了几次GC之后引发了内存溢出。

## 4、分析内存快照

当我们知道是Metaspace引发的内存溢出之后，立马就可以把内存快照文件从线上机器拷回本地笔记本电脑，打开MAT工具进行分析，如下图所示：

![](../../pic/2020-03-09-22-14-13.png)

从这里可以看到实例最多的就是AppClassLoader

为啥有这么多的ClassLoader呢？一看就是CGLIB之类的东西在动态生成类的时候搞出来的，我们可以点击上图的Details进去看看。

![](../../pic/2020-03-09-22-15-02.png)

为什么这里有一大堆咱们自己的Demo1中动态生成出来的Car$$EnhancerByCGLIB的类呢？

看到这里就真相大白了，上图已经清晰告诉我们，是我们自己的哪个类里搞出来了一大堆的动态生成的类，所以填满了Metaspace区域。

所以此时直接去代码里排查动态生成类的代码即可。

解决这个问题的办法也很简单，直接对Enhancer做一个缓存，只有一个，不要无限制的去生成类就可以了。

## 5、本文总结

今天这篇文章，带着大家全程基于示例代码从GC日志到内存快照进行了一通分析

从GC日志我们知道系统是如何在多次GC之后无奈内存溢出的

从内存快照我们就知道到底是什么东西占据了太多的内存，然后代码里找到原因解决即可。

希望大家跟着文章，也在自己本地实战一把，这样才能真正消化这些内容，转化为自己的东西。


## 自己运行日志分析

```
Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for windows-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 04:01:33 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 7906508k(474264k free), swap 15811140k(2609628k free)
CommandLine flags: -XX:CompressedClassSpaceSize=2097152 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./ -XX:InitialHeapSize=126504128 -XX:MaxHeapSize=2024066048 -XX:MaxMetaspaceSize=10485760 -XX:MaxNewSize=348966912 -XX:MaxTenuringThreshold=6 -XX:MetaspaceSize=10485760 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
0.754: [GC (Allocation Failure) 0.869: [ParNew: 33280K->1862K(37440K), 0.0030784 secs] 33280K->1862K(120768K), 0.1182830 secs] [Times: user=0.03 sys=0.00, real=0.12 secs] 
1.086: [GC (Allocation Failure) 1.086: [ParNew: 35142K->1895K(37440K), 0.0017451 secs] 35142K->1895K(120768K), 0.0018633 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
1.295: [GC (Allocation Failure) 1.295: [ParNew: 35175K->2511K(37440K), 0.0125910 secs] 35175K->2511K(120768K), 0.0128507 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
1.486: [GC (Allocation Failure) 1.486: [ParNew: 35791K->3189K(37440K), 0.0022839 secs] 35791K->3189K(120768K), 0.0023410 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
1.533: [Full GC (Metadata GC Threshold) 1.533: [CMS: 0K->2421K(83328K), 0.0324876 secs] 11907K->2421K(120768K), [Metaspace: 9492K->9492K(1058816K)], 0.1370428 secs] [Times: user=0.09 sys=0.00, real=0.14 secs] 
1.671: [Full GC (Last ditch collection) 1.671: [CMS: 2421K->1466K(83328K), 0.0178166 secs] 2421K->1466K(120896K), [Metaspace: 9492K->9492K(1058816K)], 0.0179004 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
1.712: [Full GC (Metadata GC Threshold) 1.712: [CMS: 1466K->1466K(83328K), 0.0128893 secs] 1466K->1466K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0129753 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
1.725: [Full GC (Last ditch collection) 1.725: [CMS: 1466K->1466K(83328K), 0.0128141 secs] 1466K->1466K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0129398 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
1.739: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1466K(83328K)] 1466K(120896K), 0.0039985 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] 
1.743: [CMS-concurrent-mark-start]
1.743: [Full GC (Metadata GC Threshold) 1.743: [CMS1.754: [CMS-concurrent-mark: 0.010/0.010 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
 (concurrent mode failure): 1466K->1466K(83328K), 0.0226926 secs] 1466K->1466K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0228414 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 
1.766: [Full GC (Last ditch collection) 1.766: [CMS: 1466K->1466K(83328K), 0.0121956 secs] 1466K->1466K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0123116 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
1.780: [Full GC (Metadata GC Threshold) 1.780: [CMS: 1466K->1465K(83328K), 0.0128270 secs] 1466K->1465K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0129330 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
1.793: [Full GC (Last ditch collection) 1.793: [CMS: 1465K->1465K(83328K), 0.0114813 secs] 1465K->1465K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0115560 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
1.806: [Full GC (Metadata GC Threshold) 1.806: [CMS: 1465K->1465K(83328K), 0.0121787 secs] 1465K->1465K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0122814 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
1.818: [Full GC (Last ditch collection) 1.818: [CMS: 1465K->1465K(83328K), 0.0096459 secs] 1465K->1465K(120896K), [Metaspace: 9489K->9489K(1058816K)], 0.0097048 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 par new generation   total 37568K, used 996K [0x0000000087400000, 0x0000000089cc0000, 0x000000009c0c0000)
  eden space 33408K,   2% used [0x0000000087400000, 0x00000000874f92d0, 0x00000000894a0000)
  from space 4160K,   0% used [0x00000000894a0000, 0x00000000894a0000, 0x00000000898b0000)
  to   space 4160K,   0% used [0x00000000898b0000, 0x00000000898b0000, 0x0000000089cc0000)
 concurrent mark-sweep generation total 83328K, used 1465K [0x000000009c0c0000, 0x00000000a1220000, 0x0000000100000000)
 Metaspace       used 9521K, capacity 10186K, committed 10240K, reserved 1058816K
  class space    used 834K, capacity 881K, committed 896K, reserved 1048576K

```




# 084、动手实验：JVM栈内存溢出的时候，应该如何解决？

# 085、动手实验：JVM堆内存溢出的时候，应该如何解决？

086、案例实战：每秒仅仅上百请求的系统为什么会因为OOM而崩溃？

087、案例实战：Jetty 服务器的 NIO 机制是如何导致堆外内存溢出的？

088、案例实战：一次微服务架构下的RPC调用引发的OOM故障排查实践

089、案例实战：一次没有WHERE条件的SQL语句引发的OOM问题排查实践！

090、本周思考题

091、本周答疑问题汇总！

092、案例实战：每天10亿数据的日志分析系统的OOM问题排查实践！

093、案例实战：一次服务类加载器过多引发的OOM问题排查实践！

094、案例实战：一个数据同步系统频繁OOM内存溢出的排查实践

095、总复习：线上系统的JVM参数优化、GC问题定位排查、OOM分析解决

096、专栏彩蛋：面试中如何展现自己的JVM实战经验？