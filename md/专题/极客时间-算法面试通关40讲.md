
```
第一章：课程综述 (4讲)

01 | 合格程序员的第一步：算法与数据结构
02 | 如何事半功倍地学习算法与数据结构
03 | 如何计算算法的复杂度
04 | 如何通过LeetCode来进行算法题目练习


第二章：理论讲解+面试题实战 (53讲)

05 | 理论讲解：数组&链表
06 | 面试题：反转一个单链表&判断链表是否有环
07 | 理论讲解：堆栈&队列
08 | 面试题：判断括号字符串是否有效
09 | 面试题：用队列实现栈&用栈实现队列
10 | 理论讲解：优先队列
11 | 面试题：返回数据流中的第K大元素
12 | 面试题：返回滑动窗口中的最大值
13 | 理论讲解：哈希表
14 | 面试题：有效的字母异位词
15 | 面试题：两数之和
16 | 面试题：三数之和
17 | 理论讲解：树&二叉树&二叉搜索树
18 | 面试题：验证二叉搜索树
19 | 面试题：二叉树&二叉搜索树的最近公共祖先
20 | 理论讲解：二叉树遍历
21 | 理论讲解：递归&分治
22 | 面试题：Pow(x,n)
23 | 面试题：求众数
24 | 理论讲解：贪心算法
25 | 面试题：买卖股票的最佳时机
26 | 理论讲解：广度优先搜索
27 | 理论讲解：深度优先搜索
28 | 面试题：二叉树层次遍历
29 | 面试题：二叉树的最大和最小深度
30 | 面试题：生成有效括号组合
31 | 理论讲解：剪枝
32 | 面试题：N皇后问题
33 | 面试题：数独问题
34 | 理论讲解：二分查找
35 | 面试题：实现一个求解平方根的函数
36 | 理论讲解：字典树
37 | 面试题：实现一个字典树
38 | 面试题：二维网格中的单词搜索问题
39 | 理论讲解：位运算
40 | 面试题：统计位1的个数
41 | 面试题：2的幂次方问题&比特位计数问题
42 | 面试题：N皇后问题的另一种解法
43 | 理论理解：动态规划（上）
44 | 理论理解：动态规划（下）
45 | 面试题：爬楼梯
46 | 面试题：三角形的最小路径和
47 | 面试题：乘积最大子序列
48 | 面试题：股票买卖系列
49 | 面试题：最长上升子序列
50 | 面试题：零钱兑换
51 | 面试题：编辑距离
52 | 理论讲解：并查集
53 | 面试题：岛屿的个数&朋友圈（上）
54 | 面试题：岛屿的个数&朋友圈（下）
55 | 理论讲解： LRU Cache
56 | 面试题：设计和实现一个LRU Cache缓存机制
57 | 理论讲解：布隆过滤器

第三章：课程总结 (5讲)

58 | 课程重点回顾
59 | FAQ答疑&面试中切题四件套
60 | 回到起点：斐波拉契数列
61 | 白板实战番外篇：斐波拉契数列
62 | 最后的一些经验分享


```

<!-- TOC -->

- [01 | 合格程序员的第一步：算法与数据结构](#01--合格程序员的第一步算法与数据结构)
- [02 | 如何事半功倍地学习算法与数据结构](#02--如何事半功倍地学习算法与数据结构)
- [03 | 如何计算算法的复杂度](#03--如何计算算法的复杂度)
- [04 | 如何通过LeetCode来进行算法题目练习](#04--如何通过leetcode来进行算法题目练习)
- [05 | 理论讲解：数组&链表](#05--理论讲解数组链表)
- [06 | 面试题：反转一个单链表&判断链表是否有环](#06--面试题反转一个单链表判断链表是否有环)
- [07 | 理论讲解：堆栈&队列](#07--理论讲解堆栈队列)
- [08 | 面试题：判断括号字符串是否有效](#08--面试题判断括号字符串是否有效)
- [09 | 面试题：用队列实现栈&用栈实现队列](#09--面试题用队列实现栈用栈实现队列)
- [10 | 理论讲解：优先队列](#10--理论讲解优先队列)
- [11 | 面试题：返回数据流中的第K大元素](#11--面试题返回数据流中的第k大元素)
- [12 | 面试题：返回滑动窗口中的最大值](#12--面试题返回滑动窗口中的最大值)
- [13 | 理论讲解：哈希表](#13--理论讲解哈希表)
- [14 | 面试题：有效的字母异位词](#14--面试题有效的字母异位词)
- [15 | 面试题：两数之和](#15--面试题两数之和)
- [16 | 面试题：三数之和](#16--面试题三数之和)
- [17 | 理论讲解：树&二叉树&二叉搜索树](#17--理论讲解树二叉树二叉搜索树)
- [18 | 面试题：验证二叉搜索树](#18--面试题验证二叉搜索树)
- [19 | 面试题：二叉树&二叉搜索树的最近公共祖先](#19--面试题二叉树二叉搜索树的最近公共祖先)
- [20 | 理论讲解：二叉树遍历](#20--理论讲解二叉树遍历)
- [21 | 理论讲解：递归&分治](#21--理论讲解递归分治)
- [22 | 面试题：Pow(x,n)](#22--面试题powxn)
- [23 | 面试题：求众数](#23--面试题求众数)
- [24 | 理论讲解：贪心算法](#24--理论讲解贪心算法)
- [25 | 面试题：买卖股票的最佳时机](#25--面试题买卖股票的最佳时机)
- [26 | 理论讲解：广度优先搜索](#26--理论讲解广度优先搜索)
- [27 | 理论讲解：深度优先搜索](#27--理论讲解深度优先搜索)
- [28 | 面试题：二叉树层次遍历](#28--面试题二叉树层次遍历)
- [29 | 面试题：二叉树的最大和最小深度](#29--面试题二叉树的最大和最小深度)
- [30 | 面试题：生成有效括号组合](#30--面试题生成有效括号组合)
- [31 | 理论讲解：剪枝](#31--理论讲解剪枝)
- [32 | 面试题：N皇后问题](#32--面试题n皇后问题)
- [33 | 面试题：数独问题](#33--面试题数独问题)
- [34 | 理论讲解：二分查找](#34--理论讲解二分查找)
- [35 | 面试题：实现一个求解平方根的函数](#35--面试题实现一个求解平方根的函数)
- [36 | 理论讲解：字典树](#36--理论讲解字典树)
- [37 | 面试题：实现一个字典树](#37--面试题实现一个字典树)
- [38 | 面试题：二维网格中的单词搜索问题](#38--面试题二维网格中的单词搜索问题)
- [39 | 理论讲解：位运算](#39--理论讲解位运算)
- [40 | 面试题：统计位1的个数](#40--面试题统计位1的个数)
- [41 | 面试题：2的幂次方问题&比特位计数问题](#41--面试题2的幂次方问题比特位计数问题)
- [42 | 面试题：N皇后问题的另一种解法](#42--面试题n皇后问题的另一种解法)
- [43 | 理论理解：动态规划（上）](#43--理论理解动态规划上)
- [44 | 理论理解：动态规划（下）](#44--理论理解动态规划下)
- [45 | 面试题：爬楼梯](#45--面试题爬楼梯)
- [46 | 面试题：三角形的最小路径和](#46--面试题三角形的最小路径和)
- [47 | 面试题：乘积最大子序列](#47--面试题乘积最大子序列)
- [48 | 面试题：股票买卖系列](#48--面试题股票买卖系列)
- [49 | 面试题：最长上升子序列](#49--面试题最长上升子序列)
- [50 | 面试题：零钱兑换](#50--面试题零钱兑换)
- [51 | 面试题：编辑距离](#51--面试题编辑距离)
- [52 | 理论讲解：并查集](#52--理论讲解并查集)
- [53 | 面试题：岛屿的个数&朋友圈（上）](#53--面试题岛屿的个数朋友圈上)
- [54 | 面试题：岛屿的个数&朋友圈（下）](#54--面试题岛屿的个数朋友圈下)
- [55 | 理论讲解： LRU Cache](#55--理论讲解-lru-cache)
- [56 | 面试题：设计和实现一个LRU Cache缓存机制](#56--面试题设计和实现一个lru-cache缓存机制)
- [57 | 理论讲解：布隆过滤器](#57--理论讲解布隆过滤器)
- [58 | 课程重点回顾](#58--课程重点回顾)
- [59 | FAQ答疑&面试中切题四件套](#59--faq答疑面试中切题四件套)
- [60 | 回到起点：斐波拉契数列](#60--回到起点斐波拉契数列)
- [61 | 白板实战番外篇：斐波拉契数列](#61--白板实战番外篇斐波拉契数列)
- [62 | 最后的一些经验分享](#62--最后的一些经验分享)

<!-- /TOC -->



# 01 | 合格程序员的第一步：算法与数据结构

> 面试算法的公司

![面试算法的公司](../../pic/2019-10-09-09-51-17.png)

> 去美国公司工作的路线图

![去美国公司工作的路线图](../../pic/2019-10-09-09-53-03.png)

> 区域链用到的数据结构

链接+二叉树

![区域链用到的数据结构](../../pic/2019-10-09-09-56-14.png)


# 02 | 如何事半功倍地学习算法与数据结构

![](../../pic/2019-10-09-09-59-09.png)

![](../../pic/2019-10-09-10-00-43.png)


![](../../pic/2019-10-09-10-02-44.png)

![](../../pic/2019-10-09-10-03-03.png)

![](../../pic/2019-10-09-10-03-25.png)

![](../../pic/2019-10-09-10-07-36.png)



# 03 | 如何计算算法的复杂度


![](../../pic/2019-10-09-22-07-16.png)

![](../../pic/2019-10-09-22-07-42.png)

![](../../pic/2019-10-09-22-07-56.png)





![](../../pic/2019-10-09-10-09-25.png)

![](../../pic/2019-10-09-10-09-55.png)


递归如何计算复杂度

斐波那契数列的时间复杂度为2的N次方，而不是N。

![](../../pic/2019-10-09-10-19-43.png)

![](../../pic/2019-10-09-10-20-15.png)

常见的递归算法时间复杂度[主定律]

![](../../pic/2019-10-09-10-19-22.png)



# 04 | 如何通过LeetCode来进行算法题目练习

[LeetCode 英文站点](https://leetcode.com)

[LeetCode 英文站点](https://leetcode-cn.com)


[题目+分类+公司归档](https://leetcode.com/problemset/all)

> 做题步骤 

- 1、数据范围【参数的校验】
- 2、找到全部的解法，找出最好的
- 3、多写
- 4、测试用例


# 05 | 理论讲解：数组&链表

> 数组

硬件保证随机访问O（1）

![](../../pic/2019-10-09-10-38-04.png)

插入或者删除O（N）

![](../../pic/2019-10-09-10-39-04.png)

![](../../pic/2019-10-09-10-39-57.png)


> 链表【改善删除和插入效率，以及不知道元素个数的情况】

![](../../pic/2019-10-09-10-41-21.png)

![](../../pic/2019-10-09-10-42-16.png)

![](../../pic/2019-10-09-10-43-55.png)


# 06 | 面试题：反转一个单链表&判断链表是否有环

> 反转一个单链表：

英文版：https://leetcode.com/problems/reverse-linked-list/

中文版：https://leetcode-cn.com/problems/reverse-linked-list/

```java
//迭代
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode newhead = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = newhead;
            newhead = head;
            head = next;
        }
        return newhead;
    }
}
//递归，从后朝前思考，最后两个节点逆序理解
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = reverseList(head.next);
        head.next.next = head;//后一个节点指向前一个
        head.next = null;//断开之前的指向，不然就是循环指向
        return node;
    }
}

```


> 两两交换链表中的节点

英文版：https://leetcode.com/problems/swap-nodes-in-pairs

中文版：https://leetcode-cn.com/problems/swap-nodes-in-pairs/

```java
//思路：两两交换
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1);//主要为了便于返回头部节点增加的冗余节点
        ListNode newhead = dummy;//拼接节点的游标
        
        ListNode node1;//临时节点
        ListNode node2;
        
        while (head != null && head.next != null) {
            node1 = head;
            node2 = head.next;
            
            head = node2.next;//更新遍历游标
            newhead.next = node2;
            node2.next = node1;
            node1.next = null;
            newhead = node1;//更新拼接游标
        }
        newhead.next = head;//节点个数为奇数的情况
        
        return dummy.next;
    }
}


//递归
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode node = head.next;//第二个节点
        head.next = swapPairs(head.next.next);//第一个节点拼接上第三个节点翻转后的结果
        node.next = head;//第二个节点指向第一个节点
        return node;
    }
}

```

> 每 k 个节点一组翻转链表

英文版：https://leetcode.com/problems/reverse-nodes-in-k-group/

中文版：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/


```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (k < 2) return head;
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;
        while (head != null) {//直接遍历原链表进行处理
            ListNode start = head;//记录一段的开始,也是翻转后的尾部
            int i = 0;
            while (head != null && i < k - 1) {//找到尾部节点
                head = head.next; 
                i++;
            }
            if (head != null && i == k - 1) {//说明够K个一组翻转的
                ListNode next = head.next;//保存下一组的开始节点
                i = 0;//清空计数标记，开始下一组
                head.next = null;//断开链接
                current.next = reverse(start);//翻转拼接
                current = start;//更新拼接的游标
                head = next;//开启下一轮
            } else {
                current.next = start;//不够K个直接拼接
            }
        }
        return dummy.next;
    }
    
    public ListNode reverse(ListNode head) {//单链表翻转
        if (head == null || head.next == null) return head;
        ListNode newhead = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = newhead;
            newhead = head;
            head = next;
        }
        return newhead;
    }
    
}

```




> 判断链表是否有环：

英文版：https://leetcode.com/problems/linked-list-cycle

中文版：https://leetcode-cn.com/problems/linked-list-cycle/




```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
             if (slow == fast) {
                return true;
            }
            
        }
        return false;
    }
}

```

> 环形链表

英文版：https://leetcode.com/problems/linked-list-cycle-ii

中文版：https://leetcode-cn.com/problems/linked-list-cycle-ii/



```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {//在原有的判断是否有环的基础上进行二次操作
                while (slow != head) {
                    slow = slow.next;
                    head = head.next;
                }
                return head;
            }
        }
        return null;
    }
}

```




# 07 | 理论讲解：堆栈&队列

![](../../pic/2019-10-09-22-02-31.png)


![](../../pic/2019-10-09-22-03-14.png)





# 08 | 面试题：判断括号字符串是否有效

[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```java

//注意点：1、栈为空的判断；2、结束的时候需要判断栈内是否还有元素
class Solution {
    public boolean isValid(String s) {
        if (s == null) return true;
        Stack<Character> stack = new Stack<Character>();
        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == ')' 
                || chars[i] == '}' 
                || chars[i] == ']' ) {
                if (stack.isEmpty()) {
                    return false;
                }
                if (chars[i] == ')' && stack.pop() != '(') {
                    return false;
                }
                if (chars[i] == '}' && stack.pop() != '{') {
                    return false;
                }
                if (chars[i] == ']' && stack.pop() != '[') {
                    return false;
                }
            } else {
                stack.push(chars[i]);
            }
        }
        return stack.isEmpty() ;
    }
}

```

![这个时间复杂度有点高2的N次方](../../pic/2019-10-09-22-35-33.png)




![简化后的代码](../../pic/2019-10-09-22-45-57.png)

```java
class Solution {
    public boolean isValid(String s) {
        if (s == null) return true;
        Stack<Character> stack = new Stack<Character>();
        Map<Character,Character> map = new HashMap<>();
        map.put(')','(');
        map.put('}','{');
        map.put(']','[');
        for (int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))) {
                if (stack.isEmpty() || stack.pop() != map.get(s.charAt(i))) {
                    return false;
                } 
            } else {
                stack.push(s.charAt(i));
            }
        }
        return stack.isEmpty() ;
    }
}

```


# 09 | 面试题：用队列实现栈&用栈实现队列


# 10 | 理论讲解：优先队列


# 11 | 面试题：返回数据流中的第K大元素


# 12 | 面试题：返回滑动窗口中的最大值



# 13 | 理论讲解：哈希表


# 14 | 面试题：有效的字母异位词


# 15 | 面试题：两数之和


# 16 | 面试题：三数之和


# 17 | 理论讲解：树&二叉树&二叉搜索树
# 18 | 面试题：验证二叉搜索树
# 19 | 面试题：二叉树&二叉搜索树的最近公共祖先
# 20 | 理论讲解：二叉树遍历
# 21 | 理论讲解：递归&分治
# 22 | 面试题：Pow(x,n)
# 23 | 面试题：求众数
# 24 | 理论讲解：贪心算法
# 25 | 面试题：买卖股票的最佳时机
# 26 | 理论讲解：广度优先搜索
# 27 | 理论讲解：深度优先搜索
# 28 | 面试题：二叉树层次遍历
# 29 | 面试题：二叉树的最大和最小深度
# 30 | 面试题：生成有效括号组合
# 31 | 理论讲解：剪枝
# 32 | 面试题：N皇后问题
# 33 | 面试题：数独问题
# 34 | 理论讲解：二分查找
# 35 | 面试题：实现一个求解平方根的函数
# 36 | 理论讲解：字典树
# 37 | 面试题：实现一个字典树
# 38 | 面试题：二维网格中的单词搜索问题
# 39 | 理论讲解：位运算
# 40 | 面试题：统计位1的个数
# 41 | 面试题：2的幂次方问题&比特位计数问题
# 42 | 面试题：N皇后问题的另一种解法
# 43 | 理论理解：动态规划（上）
# 44 | 理论理解：动态规划（下）
# 45 | 面试题：爬楼梯
# 46 | 面试题：三角形的最小路径和
# 47 | 面试题：乘积最大子序列
# 48 | 面试题：股票买卖系列
# 49 | 面试题：最长上升子序列
# 50 | 面试题：零钱兑换
# 51 | 面试题：编辑距离
# 52 | 理论讲解：并查集
# 53 | 面试题：岛屿的个数&朋友圈（上）
# 54 | 面试题：岛屿的个数&朋友圈（下）
# 55 | 理论讲解： LRU Cache
# 56 | 面试题：设计和实现一个LRU Cache缓存机制
# 57 | 理论讲解：布隆过滤器
# 58 | 课程重点回顾
# 59 | FAQ答疑&面试中切题四件套
# 60 | 回到起点：斐波拉契数列
# 61 | 白板实战番外篇：斐波拉契数列
# 62 | 最后的一些经验分享
















