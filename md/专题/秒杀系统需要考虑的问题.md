

# 参考

- [spring-boot-seckill](https://gitee.com/52itstyle/spring-boot-seckill)

- [spring-boot-seckill自己分支](https://gitee.com/2016shuai/spring-boot-seckill/tree/20200101/)

- [miaosha](https://github.com/lishuai2016/miaosha/tree/b_f_master_20200101)


# 1、如何保证卖出指定数量的商品？不超卖？不少卖？

> 单机版解决思路

原始不加锁会出现超卖现象。

- 1、程序锁。通过在service上添加synchronized方法锁，代码块锁或者lock锁都会出现超卖现象？[好像事务+锁会有问题]使用ReentrantLock重入锁，由于事物提交和锁释放的先后顺序也会导致超卖。

- 2、aop锁。把锁放到aop自定义切面中正常。为什么把锁放到切面中就行了【正常】锁上移，事物提交后再释放锁，不会超卖。

- 3、内存阻塞队列BlockingQueue。【正常】

原理是通过队列的大小来限制卖出的数量，比如就100件商品，阻塞队列的大小就是100，后面的直接丢弃

- 4、DisruptorQueue队列。在没有指定大小的前提下也可以正常工作。【正常】



> 集群部署情况解决思路

一般情况，秒杀活动再高配置的机器也顶不住很大的访问量。因此一般秒杀活动需要分布式部署多台机器。

>> 思路1：分布式锁。

但是经过spring-boot-seckill项目测试，在service层方法添加事务+redis分布式锁会出现超卖问题[好像事务+锁会有问题]。貌似基于zookeeper的分布式锁可以。

>> 思路2：数据库悲观锁/乐观锁[version版本]

- 悲观锁1：SELECT number FROM seckill WHERE seckill_id=? FOR UPDATE   【正常】基于数据库悲观锁实现，更新加锁并判断剩余数量。

- 悲观锁2：UPDATE seckill  SET number=number-1 WHERE seckill_id=? AND number>0";//UPDATE锁表 【正常】

- 乐观锁：UPDATE seckill  SET number=number-?,version=version+1 WHERE seckill_id=? AND version = ?

基于数据库乐观锁实现，先查询商品版本号，然后根据版本号更新，判断更新数量。少量用户抢购的时候会出现 少买 的情况。

这里使用的乐观锁、可以自定义抢购数量、如果配置的抢购人数比较少、比如120:100(人数:商品) 会出现少买的情况。因为用户同时进入会出现更新失败的情况。简单测试了下，在人数：商品个数>4的情况下才不会出现少卖。


>> 思路3：Redis分布式队列-订阅监听


>> 思路4：Kafka分布式队列


>> 思路5：ActiveMQ分布式队列


> 总结

基本可以归纳为三类

- 1、锁；除了单机synchronized和lock锁以外，需要分布式锁，基于数据库、redis和zookeeper实现。

- 2、队列：保证只有指定个数的请求进入，其余的直接丢掉。



## 优化思路

- 分流、分流、分流，重要的事情说三遍，再牛逼的机器也抵挡不住高级别的并发。

- 限流、限流、限流，毕竟秒杀商品有限，防刷的前提下没有绝对的公平，根据每个服务的负载能力，设定流量极限。

- 缓存、缓存、缓存、尽量不要让大量请求穿透到DB层，活动开始前商品信息可以推送至分布式缓存。

- 异步、异步、异步，分析并识别出可以异步处理的逻辑，比如日志，缩短系统响应时间。

- 主备、主备、主备，如果有条件做好主备容灾方案也是非常有必要的(参考某年锤子的活动被攻击)。

- 最后，为了支撑更高的并发，追求更好的性能，可以对服务器的部署模型进行优化，部分请求走正常的秒杀流程，部分请求直接返回秒杀失败，缺点是开发部署时需要维护两套逻辑。


## 分层优化

- 前端优化：活动开始前生成静态商品页面推送缓存和CDN，静态文件(JS/CSS)请求推送至文件服务器和CDN。
- 网络优化：如果是全国用户，最好是BGP多线机房，减少网络延迟。
- 应用服务优化：Nginx最佳配置、Tomcat连接池优化、数据库配置优化、数据库连接池优化。



## 分布式锁应该具备哪些条件

- 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 
- 高可用的获取锁与释放锁； 
- 高性能的获取锁与释放锁； 
- 具备可重入特性； 
- 具备锁失效机制，防止死锁； 
- 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

## 分布式锁

- 基于数据库实现分布式锁； 
- 基于缓存（Redis等）实现分布式锁； 
- 基于Zookeeper实现分布式锁；

## 思考改进

- 如何防止单个用户重复秒杀下单？
- 如何防止恶意调用秒杀接口？
- 如果用户秒杀成功，一直不支付该怎么办？
- 消息队列处理完成后，如果异步通知给用户秒杀成功？
- 如何保障 Redis、Zookeeper 、Kafka 服务的正常运行(高可用)？
- 高并发下秒杀业务如何做到不影响其他业务(隔离性)？


# 2、如何防止单个用户重复秒杀下单？

思路1：通过用户的请求IP进行限流处理。