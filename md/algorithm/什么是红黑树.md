


<!-- TOC -->

- [1、二叉查找树存在的问题](#1二叉查找树存在的问题)
- [2、2-3树](#22-3树)
    - [1、定义](#1定义)
- [3、红黑树](#3红黑树)
    - [1、左旋转](#1左旋转)
    - [2、右旋转](#2右旋转)
- [4、红黑树插入和删除原理](#4红黑树插入和删除原理)
    - [1、插入节点](#1插入节点)
        - [1、为根节点或者父节点为黑色[没有冲突不需要处理]](#1为根节点或者父节点为黑色没有冲突不需要处理)
        - [2、若父节点和叔父节点都为红色[变色后递归处理，祖父节点]](#2若父节点和叔父节点都为红色变色后递归处理祖父节点)
        - [3、父亲节点为红色，叔父节点是黑色（若是空节点则默认为黑色）](#3父亲节点为红色叔父节点是黑色若是空节点则默认为黑色)
            - [3.1、n是p左子节点，p是g的左子节点](#31n是p左子节点p是g的左子节点)
            - [3.2、n是p右子节点，p是g的右子节点](#32n是p右子节点p是g的右子节点)
            - [3.3、n是p左子节点，p是g的右子节点](#33n是p左子节点p是g的右子节点)
            - [3.4、n是p右子节点，p是g的左子节点](#34n是p右子节点p是g的左子节点)
    - [2、删除节点](#2删除节点)
        - [1、无子节点（红色节点）](#1无子节点红色节点)
        - [2、有一个子节点](#2有一个子节点)
        - [3、有两个子节点](#3有两个子节点)
            - [3.1、N的兄弟节点W为红色](#31n的兄弟节点w为红色)
            - [3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。](#32n的兄弟w是黑色的且w的俩个孩子都是黑色的)
            - [3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。](#33n的兄弟w是黑色的w的左孩子是红色w的右孩子是黑色)
            - [3.4、N的兄弟w是黑色的，且w的右孩子时红色的。](#34n的兄弟w是黑色的且w的右孩子时红色的)
- [参考](#参考)

<!-- /TOC -->


备注：红黑树在treemap和treeset中用到以及jdk1.8的hashmap


# 1、二叉查找树存在的问题

二叉查找树（BST）具备什么特性呢？

- （1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- （3）左、右子树也分别为二叉排序树；
- （4）没有键值相等的结点。


下图中这棵树，就是一颗典型的二叉查找树：

![](../../pic/2020-04-06-09-04-49.png)

可以使用二分查找的思想，快速找到要查找的元素。不过在插入新节点的过程可能使得二叉查找树蜕化为链表。

红黑树就是为了解决二叉查找树多次插入新节点而导致的不平衡问题。


# 2、2-3树

2-3树是最简单的B-树（或-树）结构，其每个非叶节点都有两个或三个子女，而且所有叶都在统一层上。2-3树不是二叉树，其节点可拥有3个孩子。不过，2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。【百度百科】

## 1、定义

和二叉树不一样，2-3树每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：

- 1. 要么为空，要么：

- 2. 对于2节点，该节点保存一个key及对应value，以及两个左右节点，左节点也是一个2-3节点，所有的值都比key小，右节点也是一个2-3节点，所有的值比key要大。

- 3. 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。

如果中序遍历2-3查找树，就可以得到排好序的序列。在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。

![](../../pic/2020-04-06-10-21-42.png)




# 3、红黑树

红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

- 性质1. 节点是红色或黑色。

- 性质2. 根节点是黑色。

- 性质3 每个叶节点是黑色的。

- 性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

- 性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

要知道为什么这些特性确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。


考虑一棵黑色高度为3的红黑树：从根结点到叶结点的最短路径长度显然是2(黑-黑-黑)，最长路径为4(黑-红-黑-红-黑)。由于性质4，不可能在最长路经中加入更多的黑色 结点， 此外根据性质3，红色结点的子结点必须是黑色的，因此在同一简单路径中不允许有两个连续的红色结点。综上，我们能够建立的最长路经将是一个红黑交替的路径。

由此我们可以得出结论：对于给定的黑色高度为n的红黑树，从根到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)。

下图中这棵树，就是一颗典型的红黑树：

![](../../pic/2020-04-06-09-08-38.png)

当插入或者删除元素的时候，红黑树的规则有可能被破坏，这时候需要通过调整来保证我们的规则：

- 1、变色

- 2、左旋

- 3、右旋


## 1、左旋转

逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：

![](../../pic/2020-04-06-09-13-24.png)

图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。





## 2、右旋转

顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：

![](../../pic/2020-04-06-09-14-00.png)

图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。





# 4、红黑树插入和删除原理

性质：

- 1、每个节点都只能是红色或者黑色

- 2、根节点是黑色

- 3、每个叶节点（NIL节点，空节点）是黑色的。

- 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。

- 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。


## 1、插入节点

红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。

对于新节点的插入有如下三个关键地方：

- 1、插入新节点总是红色节点 。

- 2、如果插入节点的父节点是黑色, 能维持性质 。

- 3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。




### 1、为根节点或者父节点为黑色[没有冲突不需要处理]

假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。

![](../../pic/2020-04-06-10-47-27.png)

可能存在的2种没有插入冲突情况：

![](../../pic/2020-04-06-10-50-28.png)

> 为根节点

若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））

> 2、父节点为黑色

这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））

### 2、若父节点和叔父节点都为红色[变色后递归处理，祖父节点]

![](../../pic/2020-04-06-10-50-45.png)

对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G，所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。

### 3、父亲节点为红色，叔父节点是黑色（若是空节点则默认为黑色）

备注：下面的四个处理逻辑在treemap的方法fixAfterInsertion中体现。

![](../../pic/2020-04-06-14-08-04.png)

这种情况下通过旋转和变色操作可以使红黑树恢复平衡。但是考虑当前节点n和父节点p的位置又分为四种情况：

A、n是p左子节点，p是g的左子节点。

B、n是p右子节点，p是g的右子节点。

C、n是p左子节点，p是g的右子节点。

D、n是p右子节点，p是g的左子节点。

情况A，B统一称为外侧插入，C，D统一称为内侧插入。之所以这样分类是因为同类的插入方式的解决方式是对称的，可以通过镜像的方法相似完成。

#### 3.1、n是p左子节点，p是g的左子节点

针对该情况可以通过一次右旋转操作，并将p设为黑色，g设为红色完成重新平衡。

![](../../pic/2020-04-06-14-14-32.png)

右旋操作的步骤是：将p挂接在g节点原来的位置（如果g原是根节点，需要考虑边界条件），将p的右子树x挂到g的左子节点，再把g挂在p的右子节点上，完成右旋操作。这里将最终旋转结果的子树的根节点作为旋转轴（p节点），也就是说旋转轴在旋转结束后称为新子树的根节点！这里需要强调一下和STL的旋转操作的区别，STL的右旋操作的旋转轴视为旋转之前的子树根节点（g节点），不过这并不影响旋转操作的效果。

备注：jdk1.7treemap的右旋操作是将g节点（即插入节点的祖父节点作为操作对象进行的）


#### 3.2、n是p右子节点，p是g的右子节点

情况B则需要使用左单旋操作来解决平衡问题，方法和情况A类似。

![](../../pic/2020-04-06-14-21-15.png)


#### 3.3、n是p左子节点，p是g的右子节点

![](../../pic/2020-04-06-14-21-45.png)

右旋--->改变颜色--->左旋

备注：这里其实是先把右旋一次转化为3.2情况；

#### 3.4、n是p右子节点，p是g的左子节点

![](../../pic/2020-04-06-14-22-02.png)

左旋--->改变颜色--->右旋

备注：这里其实是先把右旋一次转化为3.1情况；

## 2、删除节点

同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。

![](../../pic/2020-04-06-13-05-11.png)


红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。

红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：

既然删除节点比较复杂，那么在这里我们就约定一下规则：

- 1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。

- 2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。

![](../../pic/2020-04-06-13-12-06.png)

### 1、无子节点（红色节点）

这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点-----如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。

### 2、有一个子节点

这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）

### 3、有两个子节点

这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。

#### 3.1、N的兄弟节点W为红色

#### 3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。

#### 3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。

#### 3.4、N的兄弟w是黑色的，且w的右孩子时红色的。


# 参考

- [漫画：什么是红黑树？](https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA)

- [浅谈算法和数据结构: 九 平衡查找树之红黑树](https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)


- [红黑树数据结构剖析](https://www.cnblogs.com/fanzhidongyzby/p/3187912.html)


这篇文章分析的很好
- [红黑树详细分析](https://segmentfault.com/a/1190000012728513?utm_source=tag-newest)

- [TreeMap 源码分析](https://cloud.tencent.com/developer/article/1113703)
