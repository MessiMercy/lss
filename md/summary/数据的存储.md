

<!-- TOC -->

- [00、前言](#00前言)
- [01、传统的关系数据库（MySQL）](#01传统的关系数据库mysql)
    - [9、问题解析](#9问题解析)
        - [00元数据信息如何存储？数据记录如何存储？](#00元数据信息如何存储数据记录如何存储)
        - [01使用什么样的数据结构存储数据？](#01使用什么样的数据结构存储数据)
        - [02是否为数据构建索引？索引的数据结构？](#02是否为数据构建索引索引的数据结构)
        - [03如何写入一条数据？](#03如何写入一条数据)
        - [04如何删除一条数据？](#04如何删除一条数据)
        - [05如何更新一条数据？](#05如何更新一条数据)
        - [06如何查询数据？支持的查询类型？（等值查询、范围查询、关键字搜索等）](#06如何查询数据支持的查询类型等值查询范围查询关键字搜索等)
        - [07是否支持事务？](#07是否支持事务)
        - [08是否支持数据的水平扩容来支持大数据量的数据？](#08是否支持数据的水平扩容来支持大数据量的数据)
        - [09是否支持宕机数据不丢失？如何实现的？](#09是否支持宕机数据不丢失如何实现的)
        - [10如何实现数据的容灾？](#10如何实现数据的容灾)
        - [11如果通过副本机制实现容灾备份，怎么保证数据一致性？（分布式一致性协议）](#11如果通过副本机制实现容灾备份怎么保证数据一致性分布式一致性协议)
        - [12元数据信息如何存储？](#12元数据信息如何存储)
- [02、分布式关系数据库（oceanbase）](#02分布式关系数据库oceanbase)
- [03、分布式非关系数据库（clickhouse）](#03分布式非关系数据库clickhouse)
- [04、消息队列MQ（kafka、rocketmq）](#04消息队列mqkafkarocketmq)
- [05、搜索引擎（ES）](#05搜索引擎es)
- [06、redis](#06redis)

<!-- /TOC -->



# 00、前言

数据存储组件需要考虑的两大问题：1、是如何保存数据；2、如何查找数据。保存数据的目的是为了查询，不然也没有什么实质意义。因此各种数据存储组件就是为了这两个问题进行设计的。

数据存储组件需要考虑的问题：

- 0、元数据信息如何存储？数据记录如何存储？

- 1、使用什么样的数据结构存储数据？

- 2、是否为数据构建索引？索引的数据结构？

- 3、如何写入一条数据？

- 4、如何删除一条数据？

- 5、如何更新一条数据？

- 6、如何查询数据？支持的查询类型？（等值查询、范围查询、关键字搜索等）

- 7、是否支持事务？

- 8、是否支持数据的水平扩容来支持大数据量的数据？

- 9、是否支持宕机数据不丢失？如何实现的？

- 10、如何实现数据的容灾？

- 11、如果通过副本机制实现容灾备份，怎么保证数据一致性？（分布式一致性协议）






# 01、传统的关系数据库（MySQL）

![MySQL 的逻辑架构图](../../pic/2020-02-29-13-20-33.png)

![应用程序发送SQL请求到MySQL服务中的处理流程](../../pic/2020-03-06-09-57-00.png)

![存储引擎内部执行过程](../../pic/2020-03-06-10-36-38.png)




## 9、问题解析

### 00元数据信息如何存储？数据记录如何存储？

表结构定义文件以 frm 结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为 .frm 文件。

MySQL 使用 InnoDB 存储表时，数据索引等信息存储在 .ibd 文件中。当打开 innodb_file_per_table 选项时，.ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。

![](../../pic/2020-03-05-12-05-32.png)


> 1、独立表空间和共享表空间的区别？

- 共享表空间：某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1(此文件，可以扩展成多个)。注意，在这种方式下，运维超级不方便。你看，所有数据都在一个文件里，要对单表维护，十分不方便。另外，你在做delete操作的时候，文件内会留下很多间隙，ibdata1文件不会自动收缩。换句话说，使用共享表空间来存储数据，会遭遇drop table之后，空间无法释放的问题。

- 独立表空间:每一个表都以独立方式来部署，每个表都有一个.frm表描述文件，还有一个.ibd文件。
    - .frm文件：保存了每个表的元数据，包括表结构的定义等，该文件与数据库引擎无关。
    - .ibd文件：保存了每个表的数据和索引的文件。
    
    注意，在这种方式下，每个表都有自已独立的表空间，这样运维起来方便，可以实现单表在不同数据库之间的移动。另外，在执行drop table操作的时候，是可以自动回收表空间。在执行delete操作后，可以通过alter table TableName engine=innodb可以整理碎片，回收部分表空间。

ps：my.cnf中的datadir就是用来设置数据存储目录

show variables like '%datadir%';

![](../../pic/2020-04-18-18-13-39.png)

在绝大部分情况下，运维一定会为mysql选择独立表空间的存储方式，因为采用独立表空间的方式，从性能优化和运维难易角度来说，实在强太多。

> 2、表空间下数据存储层级结构

InnoDB 存储引擎的逻辑存储结构是数据都被逻辑地存放在一个空间中，我们称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block），1 extent = 64 pages，InnoDB 存储引擎的逻辑存储结构大致如图所示：

![](../../pic/2020-03-05-11-16-44.png)

![](../../pic/2020-03-05-12-02-41.png)


一行记录最终以二进制的方式存储在文件里。记录在磁盘上是以数据页（默认16K）为单位向操作系统申请资源的（即使存储一条记录也要申请一个数据页的资源），一个数据页可以存储多条记录行，64个数据页组成一个区（大小为1M），256个区组成一个段（大小256M），数据行记录就是按照这个的格式存储在磁盘上的。

MySQL的基本存储结构是页(记录都存在页里边)

![](../../pic/2020-03-05-10-55-30.png)

![](../../pic/2020-03-05-10-55-56.png)

各个数据页可以组成一个双向链表，而且每个数据页中的记录又可以组成一个单向链表。


每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录；其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

![](../../pic/2020-04-18-19-24-23.png)

页目录里维护多个 slot ，一个 slot 包含多个行记录。每个 slot 占 2 个字节，记录这个 slot 里的行记录相对页初始位置的偏移量。由于索引只能定位到数据页，而定位到数据页内的行记录还需要在内存中进行二分查找，而这个二分查找就需要借助 slot 信息，先找到对应的 slot ，然后在 slot 内部通过数据行中记录头里的下一个记录地址进行遍历。每一个 slot 可以包含 4 到 8 个数据行。如果没有 slot 辅助，链表本身是无法进行二分查找的。

![](../../pic/2020-04-18-19-26-19.png)


>> 1、User Records

这个区域对我们插入的数据进行保存，需要说明的是原本这一块是不存在的，当我们插入数据的时候这块区域才会被划分出来。并且是从Free Space进行的划分。当我们的Free Space区域所有的空间都变成了UserRecords，那么这时候就是需要重新开辟一个储存页的时间了。

那么当我们把数据放在这个区域里面的时候，是不是就是说没有一点规则，随便进行摆放，其实想一想就知道了，当我们数据过于庞大的时候，我们随便摆放，查找会是多么的痛苦。所以接下来在我们知道数据保存在那个位置以后我们需要弄清楚的是数据在User Records里的情况。在这里我们假设插入了四条我们自己的记录：

两个虚拟的数据：我们可以看到下图所示，我们插入了四条记录的时候，但是在我们这个页中存在的是六条记录，也就是两条我们说的每个页中都会存在的虚拟记录：最大记录和最小记录。他们都存infumum_supremum里面，因为不是我们自己插入的记录所以是不在User_Record里面.最小记录默认在开始，最大记录在最末尾结束　　

![](../../pic/2020-04-18-20-47-03.png)

接下来我们再根据这六条记录描述一些问题：

- 1：我们在每条数据的记录头里面提到的Record_Type标记的是这条数据的类型，当时我们说的是有0普通数据，1叶子节点数据，2最小数据，3最大数据。我们可以看到的是上边最大和最小数据分别是3和2， 我们自己插入数据的记录头信息在Record_type这里都是0.

- 2：我们在记录头信息里面还可以看到的是delete_mask这个数据，表示的是数据是否被删除，0表示没有，1表示已经被删除，所以上边的数据都是0

- 3：heap_no我们讲过是标记该数据在页中的位置，我们可以看到插入数据分别是2，3，4，5。那么0和1去哪了，别着急，请看看最小记录和最大记录的该数据，是不是分别为0和1。我们插入的数据都会从2开始计数，虚拟数据会占用默认的0和1的位置。

- 4：插入数据的排列是否就是数据插入的顺序，那显然是不可能的，你没想错，数据会根据大小进行排列，那么数据用什么进行大小的排列？显然就是主键进行比较。

- 5：next_record记录的就是相对于本条数据，下一条数据的地址偏移量，就是通过这条数据往下查找这么多字节就可以找到下一条数据，没错。他就是使用的链表进行链接的。如下图：

![](../../pic/2020-04-18-20-51-19.png)

- 6：如果一条数据被删除，也就是它的delete_mask被标记为了1，那么这个会怎么进行改变？就是和链表一致，进行链接的切断就可以了。

![](../../pic/2020-04-18-20-52-44.png)

- 7：我们在进行数据查找的时候就是这么一条接一条的进行查找么？从最小记录开始根据next_record查找？那必然是耗时的一个活，显然是不可能的，所以在就出现了分组这个概念。

![](../../pic/2020-04-18-20-53-48.png)

![](../../pic/2020-04-18-20-54-27.png)

**分组：**

我们可以看到的是六条数据分成了两组，首先是最小的虚拟数据独自一组，然后剩下的五个数据再分成一组。在这里需要知道的就是MySql数据库在每个页中进行数据分组的时候默认的最小数据是第一组，它拥有一条数据，就是最小数据，不能在插入其他数据。最大数据是第二组，我们在进行数据插入的时候都是先插入最大数据组，当最大数据组满足的时候进行分裂，形成普通的分组，然后再进来的数据又插入最大数据组，如此循环往复，完成数据的分组。

**槽：**

我们还可以看到的是在分组的图里面出现了两个奇奇怪怪的东西，槽。每个分组数据的相对于页的地址偏移量就是一个槽数据，一个分组有一个槽，槽存在的位置就是页信息的Page Directory。在这里我需要强调的是在记录头信息中有个地址偏移量next_record，这个偏移量是本条数据相对于下一条数据位置，然后槽中的偏移量是分组最后一条数据相对于页的偏移量。

**寻找：**

有了分组以后，我们在进行数据查找的时候就是根据二分法确定对应数据所在的槽位置，然后在使用记录头信息的next_record一条条进行查找。

**n_owned：**

这个数据我们在记录头信息中一直看到，其实在这里就可以结束这个数据了。它表示的是该分组有多少条数据，存在于分组的最后一条信息中。我们可以看到的是每个分组的前面的数据　　　　　　　　n_owned都是0，只有在最后一条数据上它才有值。



>> 2、page_header

上边我们通过数据的方式介绍了User_Records,infumum_supremum,page_directory,Free spce这四块空间的使用情况，接下来需要进行解释的就是page_header,file_header,file tailer这三块空间。

首先说的就是page_header，这个地方储存的就是数据的一些信息：

![](../../pic/2020-04-18-20-59-49.png)


在上边我们需要说的就是PAGE_DIRECTION和PAGE_N_RECS这两个数据第一个指的是最后插入的方向，相对于上一条数据来说，我们新插入的比他大，就在右边，反之则在左边，这就是方　　　　　　　 向。当我们插入数据连续的都在右边或者是都在左边的时候就会记录下数量。当然如果改变方向的话这个数据会被清空从零开始计数。

>> 3、File_Header

上边讲的page_header就是对页储存记录的描述，那么这里的File_Header就是对页信息的描述：

![](../../pic/2020-04-18-21-02-10.png)

我们可以看到三个值，一个记录的是这个页的页号，上一个页，下一个页。针对上面我们讲的一个页中的数据是采用单向链表的形式进行连接，那么我们可以想到的是数据库中的页是采用的双向链表。

![](../../pic/2020-04-18-21-02-54.png)

我们在上面还可以看到的是　FIL_PAGE_TYPE这个值，描述的是这个页的类型，显然我们数据库不可能就只有一种数据页，上面我们讲的储存真实数据页就是数据页。FIL_PAGE_INDEX，也就是我们提到的B+树叶子节点。

>> 4、File Trailer

这玩意需要和上面File header中的FIL_PAGE_SPACE_OR_CHKSUM这个属性系统校验和一起说。我们都知道的是页是一块16kb的储存空间，不管是内存刷新到数据库取用都是一次操作16kb。那么如果在中途产生停电等不可抗拒的因素，这时候这里就起作用了。File Header位于页的开始，它会计算一个校验和，这个校验和你可以这么理解，当我们需要一个很复杂的字符串的时候，往往会将它按照一定的算法进行计算出一个整数值，当和其它字符串进行比较的时候就用这个值。所以校验和也是这个道理，File Trailer是位于页尾部的，他也会储存一个校验和。如果数据不完整，那么两个校验和不可能一致，那么就可以判定这个数据页是损坏的。


> 3、一行记录格式（行格式存储Compact）

行格式：我们把数据库储存数据的格式称之为行格式或者是记录格式，我们现在所使用的行格式有Compact，Redundant，Dynamic，Compressed。

- [MySQL数据库储存引擎Inoodb一--记录储存结构](https://www.cnblogs.com/zslli/p/8855634.html)
- [从根儿上理解MySQL：10年老DBA告诉你1条记录在表中是如何存储的](https://baijiahao.baidu.com/s?id=1644888989326529522&wfr=spider&for=pc)

创建语法：我们会在数据库中创建一个表，test，方便我们接下来对于储存结构的演示。如下所示，设置行格式我们直接使用ROW_FORMAT=行格式名称 。我们同时也对编码格式进行了设置为ASCII，这个编码格式只能是储存空格，字母，标点符号，不可见字符，数字。所以汉字是不可以储存进来的！

![](../../pic/2020-04-18-19-54-53.png)

你可以在建表的时候，就指定一个行存储的格式，也可以后续修改行存储的格式。这里指定了一个COMPACT行存储格式，在这种格式下，每一行数据他实际存储的时候，大概格式类似下面这样：

![](../../pic/2020-04-18-19-13-07.png)

对于每一行数据，他其实存储的时候都会有一些头字段对这行数据进行一定的描述，然后再放上他这一行数据每一列的具体的值，这就是所谓的行格式。除了COMPACT以外，还有其他几种行存储格式，基本都大同小异。

**为什么要有数据行格式？**因为数据是按照二进制的字节存在磁盘，如果没有一定的格式限定就没法确定一行数据的边界，也可以理解为断句。对连续的二进制流进行切分，切分成逻辑上的一行行记录。

>> 1、变长字段列表（每个字段使用一个字节或者两个字节表示一个变长字段的真实长度）

因为是变长没法确切字段这个字段到底存储多长的数据（比如一个varchar字段，里面可能存储了hello、hi），因此需要有个地方标识这个字段真实存储的数据长度有多大。如果有多个变长字段，那么这个列表逆序存储各个变长字段所占用的真实长度。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放。每一个变长字段的最大值为65535（最大使用2字节存储一个字段的真实长度。这也很好地解释了为什么MySQL中varchar的最大长度为65 535，因为2个字节为16位，即216=1=65 535）


在这里保存每一列的信息的时候怎么判断是使用的一个字节还是两个字节呢？三个因素：

- 1、字符集储存一个字符使用字节M（我们采用的ASCII是1，UTF-8是3，GBK是2）

- 2、可以储存的位数W(VARCHAR(W))

- 3、真实储存的位数L

规则：

- （1）当M * W < 256使用一个字节

- （2）当M * W > 256：L小于128使用一个字节，L大于128使用两个字节。

![第一行记录的存储格式](../../pic/2020-04-18-19-55-38.png)



>> 2、null值列表

我们知道表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，它的处理过程是这样的：

- 1.首先统计表中允许存储NULL的列有哪些。

我们前边说过，主键列、被NOT NULL修饰的列都是不可以存储NULL值的，所以在统计的时候不会把这些列算进去。比方说表test的3个列c1、c3、c4都是允许存储NULL值的，而c2列是被NOT NULL修饰，不允许存储NULL值。

- 2.如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：

二进制位的值为1时，代表该列的值为NULL。

二进制位的值为0时，代表该列的值不为NULL。

因为表test有3个值允许为NULL的列，所以这3个列和二进制位的对应关系就是这样：

![](../../pic/2020-04-18-19-58-42.png)

再一次强调，二进制位按照列的顺序逆序排列，所以第一个列c1和最后一个二进制位对应。

- 3.MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。

表test只有3个值允许为NULL的列，对应3个二进制位，不足一个字节，所以在字节的高位补0，效果就是这样：

![](../../pic/2020-04-18-20-00-17.png)

以此类推，如果一个表中有9个允许为NULL，那这个记录的NULL值列表部分就需要2个字节来表示了。因为一个二进制是占8个格子，一个字段占用一个格子。

知道了规则之后，我们再返回头看表test中的两条记录中的NULL值列表应该怎么储存。因为只有c1、c3、c4这3个列允许存储NULL值，所以所有记录的NULL值列表只需要一个字节。

对于第一条记录来说，c1、c3、c4这3个列的值都不为NULL，所以它们对应的二进制位都是0，画个图就是这样：

![](../../pic/2020-04-18-20-00-57.png)

所以第一条记录的NULL值列表用十六进制表示就是：0x00。

对于第二条记录来说，c1、c3、c4这3个列中c3和c4的值都为NULL，所以这3个列对应的二进制位的情况就是：

![](../../pic/2020-04-18-20-01-08.png)

所以第二条记录的NULL值列表用十六进制表示就是：0x06。

所以这两条记录在填充了NULL值列表后的示意图就是这样：

![](../../pic/2020-04-18-20-01-21.png)

>> 3、记录头信息

它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思，如图：

![](../../pic/2020-04-18-20-02-23.png)

这些二进制位代表的详细信息如下表：

![](../../pic/2020-04-18-20-03-20.png)

两条记录的头信息分别是什么：

![](../../pic/2020-04-18-20-04-59.png)


>> 4、隐藏列

记录的真实数据除了我们插入的那些数据列之外，MySQL数据库还会帮我们自动生成三个列，也称之为隐藏列。

![](../../pic/2020-04-18-20-06-48.png)

注意：行id不是必须有的，是在我们没有进行主键指定的时候才生成的。我们的事务id和回滚指针才是每一条数据都会帮助我们进行添加的。我们不需要关心这三个列的数据添加，因为是MySQL自动帮我们进行添加的。

我们看看加上真实数据以后，我们添加的两条记录的储存完整格式是什么情况：

![](../../pic/2020-04-18-20-09-04.png)

注意：

- 1、在第一条数据中的C3列虽然真实储存的是 ‘cc’ 但是我们定义的数据类型是char，所以需要进行完整的表示它定义的十个字符空间，剩下的八个用空格字符（20）进行填充。

- 2、我们在第二条数据中看到的是C3，C4两个列是没有在真实数据中进行保存的，因为它们已经在NULL列表里面已经进行了储存声明，所以是不需要重复进行储存的。

- 3、上边的数据储存因为我们采用的是ASCII字符集，当然如果采用其他的字符集是会不一致的。

- 4、使用的是ascii字符集，所以0x61616161就表示字符串'aaaa'，0x626262就表示字符串'bbb'，以此类推。注意第1条记录中c3列的值，它是CHAR(10)类型的，它实际存储的字符串是：'cc'，而ascii字符集中的字节表示是'0x6363'，虽然表示这个字符串只占用了2个字节，但整个c3列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在ascii字符集的表示就是0x20。

>> 4、Redundant

这个行格式是MySQL5.0之前的版本使用的行格式，非常古老，但是我们还是介绍一下。直接进行和Compact行格式比较，结构示意图：

![](../../pic/2020-04-18-20-23-54.png)

从结构示意图我们可以看出以下区别：

- 1、变长字段长度列表变成了-->字段长度偏移列表
- 2、少了NULL值列表

数据完整信息：

![](../../pic/2020-04-18-20-24-47.png)

区别：

- 1、Redundant会把所有列都在字段长度偏移列表进行储存，包括隐藏列，当然顺序依然是逆序。

- 2、Redundant采用偏移量也就是相邻两列的差值进行储存。

第一列：row_id 六个字节  0x06

第二列：transaction_id 六个字节 0x0c - 0x06 = 0x06

第三列：roll_pointer  七个字节  0x13 - 0x0c = 0x07
　　　　　　　　　　　　　　
以此类推我们就可以获取完整的储存信息

- 3、我们在第二条数据可以看到，在真实数据的位置我们是对空值的列进行了相应的用00进行替代保存。在Compact行格式里面我们是不会进行保存的。

**记录头信息：**

- 预留位1  一：没有进行使用

- 预留位2  一：没有进行使用

- delete_mask   一：是否被删除

- min_rec_mask  一：该记录是否为B+树中非叶子节点的最小记录

- n_owned  四： 当前嘈管理的记录数

- heap_no 十三：当前数据在记录堆的位置

- n_field    十： 表示记录中列的数量

- 1byte_offs_flag  一：标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的

- next_record  十六：下一条记录的相对位置

区别：

- 1、少了record_type这个属性

- 2、多了n_field和1byte_offs_flag这两个属性

**行溢出数据：**

我们在前面提到过一个问题，那就是我们MySQL数据库是采用页作为磁盘和内存的中间交换，一页可以储存16k的数据，那么如果我们的一条数据超过了这个内存大小，又会发生什么样的情况呢？其实在这里我觉得是没有必要关心多大的数据会发生行溢出的，如果有兴趣可以自行百度。在Compact行格式和Redundant中，对于这种特别大的数据的处理方式就是在真实数据的储存地方留下20个字节的内存用来储存指向下一页的地址。意思就是用几页进行储存，这些页之间的联系是使用20个字节内存进行维护。

![](../../pic/2020-04-18-20-31-59.png)
　　　　　　

**Dynamic和Compressed：**

这两个行格式和Compact是非常相似的，它们的区别就在于对于上面提出的行溢出的处理。Dynamic是使用所有的真实数据储存空间进行储存其它页面的地址，把所有的真实数据都储存在其它页面中。

![](../../pic/2020-04-18-20-36-28.png)

相比于Dynamic来说，Compressed行格式的处理仅仅是加上了压缩算法进行压缩，节省空间。

**CHAR类型数据储存：**

我们在前面使用Compact行格式的提到过，比如我们的第一条数据的C3列因为是CHAR的数据类型，所以在变长数据长度列表里面是不进行储存的。但是在最后需要提出一点就是在那里我们采用的是定长的字符集ASCII，但是如果我们把字符集换成UTF8的话这一列数据还是会在变长数据长度列表里面进行储存的。



### 01使用什么样的数据结构存储数据？

以innodb存储引擎为例，依据主键id构建了一颗B+树，每一行的记录按照主键id顺序把数据插入到这个树中。（innodb表如果在创建表的时候指定主键索引就使用指定的；如果没有看是否设置了唯一索引，设置唯一索引则用唯一索引作为主键索引构建B+树；如果主键和唯一索引都没设置则系统默认创建一个隐式的主键索引，所以innodb主键是必须存在的）


### 02是否为数据构建索引？索引的数据结构？

以innodb存储引擎为例，存储数据本身依照主键的顺序构造了一个B+树，如果使用主键查询数据，直接查找这个B+树即可。

![主键索引树](../../pic/2020-03-12-22-32-19.png)

上半部分是由主键形成的B+树，下半部分就是磁盘上真实的数据！

![辅助索引树](../../pic/2020-03-12-22-41-46.png)

会根据你的索引字段生成一颗新的B+树。因此， 我们每加一个索引，就会增加表的体积，占用磁盘存储空间。注意看叶子节点，非聚簇索引的叶子节点并不是真实数据，它的叶子节点依然是索引节点，存放的是该索引字段的值以及对应的主键索引(聚簇索引)。


> 1、索引的构建过程

- [MySQL数据库索引（上）](https://www.cnblogs.com/zslli/p/8932371.html)

1.数据页由七部分组成，包括File Header(描述页的信息)、Page Header（描述数据的信息）、Infimum + Supremum（页中的虚拟数据最大值和最小值）、User Records（用户真实数据储存的部分）、Free Space（真实数据增加划分的部分空间）、Page Directory（页中记录相对位置，槽储存的位置）、File Trailer（检验16kb大小的数据页是否完整）。

2.每一个页中的数据都是单向链表，由数据的记录头信息next_record进行维护，记录的是相对于本数据下一条数据的距离字节数。内存中的页是双向链表的数据结构，由页信息的本页号码，上一页号码，下一页号码进行维护。

3.页中的数据都会进行分组，虚拟最小数据是一组，最大数据组最多存在8条数据，满额是二分成普通分组数据。每个分组的最后一条数据相对于页的偏移量就是槽的数据。本页中数据的查找采用的就是二分法，通过槽确定数据所在的分组，然后在进行搜索。

![](../../pic/2020-04-18-21-21-15.png)


**没有索引的查找：**

- 1、在一个页中：

如果数据在一个页中，采用的是以主键为条件，那么我们就可以采用二分法的方式进行寻找，我们通过上一篇文章可以知道的是每一个页中的数据都会进行分组，然后在页信息的Page Diractory部分进行储存槽的信息，通过槽定位到数据所在的分组，然后在开始进行数据的搜索。

如果我们采用的不是主键作为搜索的条件，那么我们通过二分法寻找的方法必然是行不通的了，这时候我们只能很苦逼的一条一条数据慢慢的检索。

- 2、在很多数据页中：

如果我们要在很多数据页中进行没有索引的数据寻找那就更是不幸运了，只有一条数据的挨着进行搜索，假如我们数据库里有上亿的数据那么就是很苦逼而且不现实的一种方式。

**索引的实现：**

1：首先我们先创建一个今天需要使用到的表格：

![](../../pic/2020-04-18-21-23-00.png)


2：我们进行数据的插入：

![](../../pic/2020-04-18-21-23-19.png)

 

3：我们用简化的图示展示一下这些数据储存的状态信息：

![](../../pic/2020-04-18-21-23-36.png)

数据的有序性。我们可以从上图看出一点端倪，那就是所有的数据都是以主键的大小值进行排列的。

4：假设我们一页只能储存下三条数据，这是假设，一页可以储存很多条数据，但是我们在这里为了方便演示就假设只能储存三条数据，然后我们在新加入一数据：

![](../../pic/2020-04-18-21-24-58.png)

我们可以看到的是我们新插入的数据分了新的一页，但是很奇怪的一点就是上一个页的号码是10，为什么下一页就是28了？所以我们必须要清楚一点，页号码是不连续的，我们页的双向链表才是维护页秩序的连接，在前面我们也提到过这个问题，使用的是File Header进行储存页码，上一页码，下一页码。我们在前面提到过一个问题那就是数据具有一定的顺序，需要根据主键的大小进行排序，所以应该如下图所示：

![](../../pic/2020-04-18-21-25-38.png)

5：我们现在搞清楚了数据的排布，那我们在连续插入多条数据在直观的看一下数据：

![](../../pic/2020-04-18-21-26-03.png)

是不是发现了问题，我们如果数据库里还有很多这样的数据，就算是每一页都是有槽的存在，可以帮助我们快速在同一页中定位到数据所在。那么，如果不在一页我们是不是只有按照页的双向链表进行遍历？答案很显然不是，所以我们需要对每个页创建新的东西。

6：目录项：

![](../../pic/2020-04-18-21-26-31.png)

我们可以看到的是我们是不是创建了四个新的东西，这是啥？这就是目录项，一个页对应一个目录项，目录项里面储存的是页码+当前页主键最小的值。到这里是不是就有想法了？这玩意儿和我们自己的数据是不是着实很像。还记得我们在前面提过在数据的记录头信息的record_type这个属性么，0表示普通数据，1表示非叶子节点数据，2表示虚拟最小数据，3表示虚拟最大数据。所以，我们自己的数据和这个目录项数据的区分就是靠着这个属性区分的。除了这个我们的目录项是没有数据库自动添加的三个列的。所以，我们这时候是需要给这些目录项分配一个页，让他们进行储存：

![](../../pic/2020-04-18-21-27-37.png)

7：到了这里的时候我们大概就能很清楚索引的结构了吧，那么问题又来了，我们的目录项页多了以后怎么办？那还能怎么办，继续再建造上一层目录项页呗。使用当前目录项的页码和当前页最小目录项的主键。

![](../../pic/2020-04-18-21-28-07.png)

8：索引的查找就是通过一层一层的定位来实现的，最上层的页我们称之为根节点，中间的我们称之为内节点，最底层的我们称之为叶子节点。我们就是通过页中的槽二分法快速的定位数据所在页或者组中，我们在进行遍历查找。最后说一点这玩意儿就是我们说的B+树，也没多大点东西。

**总结：**

上面我们讲的就是Innodb储存引擎为每个表都会创建的用主键进行构造的聚簇索引，聚簇索引就是所有数据都在叶子节点的索引。

**二级索引：**

讲完聚簇索引我们就来讲一下什么叫二级索引，二级索引顾名思义就是我们自己创建的索引。有时候我们的业务所需要，我们要根据某个或者是某些字段进行查找，排序，分组等，这时候我们为了加快速度，那么最好的方案就是创建这些列的索引：

![](../../pic/2020-04-18-21-29-36.png)

我们首先看叶子节点，它的构成就是通过的我们需要使用的列+主键列构成，我们以需要使用的列作为排序的依据。然后我们再看目录项，是用我们需要使用的列+页码组成。以此类推，我们可以得出的结论就是：

- 1.二级索引和聚簇索引的区别就是叶子节点不包括完整的数据

- 2.二级索引储存的只是我们需要使用到的列和主键，如果要其它列的数据怎么办？回表：就是通过二级索引获取到的主键然后到聚簇索引里面去进行查找。

**联合索引：**

上面我们看了一下聚簇索引和二级索引，接下来我们再看一下什么叫联合索引，其实我们可以看出来就是联合指的就是多列进行组合：我们用c2和c3创建

![](../../pic/2020-04-18-21-30-52.png)

我们可以看到的是联合索引就是用多个字段进行创建索引，然后根据对应列顺序进行排序。比如上图我们使用的就是c2和c3两个列，所以我们就是现根据c2进行排序，如果c2相同的情况下我们再根据c3进行排序。在这里提前说一个注意点：联合索引的使用务必要从最左边也就是最先开始排序的列开始使用。


总结：

1.一个索引对应一颗B+树，所有的真实记录都是存在叶子节点里面的，所有的项目录都存在内节点或者说根节点上。

2.innodb会为我们的表格主键添加一个聚簇索引，如果没有主键的话数据库是会为我们自动添加row_id这一列的。聚簇索引的叶子节点包含完整的用户记录。

3.我们是可以为自己感兴趣的列添加二级索引的，二级索引的叶子节点没有用户完整的信息，只是拥有对应列和主键的信息，如果想要拥有完整的信息是需要进行回表操作用二级索引找到的主键去聚簇索引寻找完整信息。

4.B+树的每一层节点都是按照索引列的大小信息进行排序而组成的双向链表，每个页里里面的记录也是按照索引列大小信息组成的单向链表。如果是联合索引的话，先按照前面的列进行排序，如果是相同的情况下再根据其他的列进行排序。

5.每个索引的搜索都是从根节点进行的，由于每个页面都按照索引列的值建立了Page Directory，所以在确定了具体页面信息的情况下是可以根据二分法进行快速的定位的。



索引的代价：

1.空间上的代价：每一个索引对应的都是一颗B+树，B+树的每一个节点都对应的是一个16kb大小的数据页，如果是一个很大的数据库的话那么占用的内存还是很大的。

2.时间上的代价：我们在上面讲过，每层节点都是按照数据的大小顺序进行排列的单向链表，每个页也是按照大小排列的双向链表。那么我们在对数据进行操作的时候必然避免不了的就是数据的迁移，数据页的删除，回收，分裂等等，如果我们创建的索引过多的话那么对应的问题就是频繁的需要对这些东西进行操作。那就是浪费时间，给性能拖后腿。


索引的挑选：

- [MySQL数据库索引（中）](https://www.cnblogs.com/zslli/p/8946145.html)

1>必须条件：只为我们使用到的查询条件，分组，排序列创建索引。查询列表里面的列我们没有必要建立索引。

2>基数考虑：如果一个列的差异数据不是很多，我们称之为基数小的列。也就是说所有数据的这个列的数据大部分都相同，那么就是基数小，这种列没必要创建索引。

3>数据类型：我们知道的是索引列可以有很多的数据类型，比如说整形数据我们就有TINYINT、MEDIUMINT、INT、BIGINT，它们所占用的空间内存肯定是不一样的，所以我们挑选数据类型小的类型作为索引列的数据类型，可以有效的节约空间，储存更多的数据，那么我们在进行数据取用的时候一次可以加载更多的数据进入内存，减小IO损耗，同时在CPU层次来说，数据类型越小，查询处理的速度是越快的。

4>索引字符串的前缀：我们在使用索引的时候是可以的，那么在创建索引的时候当然也是可以的，这样可以减少很多的内存空间，而且我们在做字符串比较的时候如果我们使用的是前缀那么比较的时间也是可以大大进行缩短的。


5>尽量使用联合索引：因为我们的每一个索引对应的都是一颗B+树，需要使用时间和空间进行维护的，我们文章开始就说了索引需要付出的代价。我们使用联合索引，是可以满足很多字段的索引条件的。

6>主键插入的顺序：记不记得我们在上边说的，索引的一个目录项对应的是一个页，我们的数据都是有序的进行单向链表的维护，那么如果我们的主键在后期插入中间的话就涉及到了位置的移动，目录项的修改，页面分裂，数据迁移等等问题。所以我们建议的是让数据库给主键进行自增生成。

7>避免冗余重复的索引：不要为一个列重复的添加多个索引，这样是不好的，他对效率的提升没有半点的帮助，但是对空间的消耗确实实打实的。

8>覆盖索引：所以我们查询的列最好都是我们索引的列，也就是说我们是鼓励把需要查询的列明确进行书写的。





### 03如何写入一条数据？

### 04如何删除一条数据？

### 05如何更新一条数据？

update T set c=c+1 where ID=2;

以InnoDB引擎在执行这个简单的 update 语句时的内部流程。

- 1、执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存（以数据页为单位），然后再返回。

- 2、执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

- 3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

- 4、执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

- 5、执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

这里给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![update 语句执行流程](../../pic/2020-02-29-14-01-49.png)


你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

### 06如何查询数据？支持的查询类型？（等值查询、范围查询、关键字搜索等）

如果我们写select * from user where id = '8'这样没有进行任何优化的sql语句，默认会这样做：

- 1、定位到记录所在的页：需要遍历双向链表，找到所在的页；
- 2、从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了；

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：

![](../../pic/2020-03-05-10-59-49.png)

要找到id为8的记录简要步骤：

![](../../pic/2020-03-05-11-00-45.png)


B+树的叶子节点是使用双休链表链接当定位到一个值的时候可以朝前、朝后进行遍历直到查找到第一个不满足条件的记录即可结束。




### 07是否支持事务？

### 08是否支持数据的水平扩容来支持大数据量的数据？

### 09是否支持宕机数据不丢失？如何实现的？

### 10如何实现数据的容灾？

### 11如果通过副本机制实现容灾备份，怎么保证数据一致性？（分布式一致性协议）

### 12元数据信息如何存储？

# 02、分布式关系数据库（oceanbase）


# 03、分布式非关系数据库（clickhouse）


# 04、消息队列MQ（kafka、rocketmq）


# 05、搜索引擎（ES）


# 06、redis


















