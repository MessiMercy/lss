
比较知名的rpc框架

- 1、dubbo
- 2、Google的grpc
- 3、Apache thrift
- 4、微博的motan
- 5、soft-rpc
- 6、xxl-rpc




基于netty构建的rpc通信核心点梳理：

> 1、消费端

- 1、消费端的动态代理发送请求到服务提供者（动态代理的生成，服务提供者建立的长连接等）；如果是你spring应用，一般在一个类中，通过注解标识那些是rpc调用的消费者代理，需要在spring构建bean对象的时候把这些属性替换为动态代理对象。

- 2、基于netty构建的网络模型为异步，发送完请求后并不会阻塞等待结果，这里需要在异步模型上实现同步调用（java中的阻塞来实现，比如future）；基于请求id和响应id一致来匹配请求和响应；

- 3、如何处理没有响应返回的请求id？一直阻塞请求线程？？？


> 2、服务提供端

- 1、服务提供者基于请求参数中的接口全限定名称\方法名称\参数数组\参数类型数组，查询本地对应的服务，基于反射进行调用。

- 2、服务提供端io线程和业务线程由谁来处理请求。合理的划分；

- 3、服务提供者处理完业务逻辑，如何把数据发送给请求端，如何写channel以及如何把请求和响应对应起来；

- 4、一般在netty中的channelhandler的接收到请求端的请求时，封装成一个任务提交到业务线程池去执行，执行完毕ctx.writeAndFlush(xxlRpcResponse);//写会响应结果；


- 5、在服务端启动的过程中，一般会把标记为暴露服务的接口搜集到一个map缓存起来，当用户请求到来的时候，查这个map找对应的处理来进行处理；map<接口，实现类>；如果是spring应用，可以在容器启动的时候通过扫描对应的服务提供者注解标识进行解析，获取这个map对象；

- 6、服务注册到注册中心，更新上一步的map<接口，实现类>注册服务，具体到注册中心上的个数为<接口，list<服务提供者id>>，有可能存在一个接口对应多个服务提供者；


> 3、公用的

- 1、发送消息的序列化和反序列化；













# 参考

- [RPC 的概念模型与实现解析](https://www.cnblogs.com/mindwind/p/5518145.html)

- [HTTP协议中的短轮询、长轮询、长连接和短连接](https://www.cnblogs.com/knowledgesea/p/6813832.html)

- [京东咚咚架构演进](https://www.cnblogs.com/mindwind/p/5017591.html)
