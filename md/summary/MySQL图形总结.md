
<!-- TOC -->

- [00、MySQL 的逻辑架构图](#00mysql-的逻辑架构图)
- [01、一条SQL的运行过程](#01一条sql的运行过程)
- [02、执行器调用存储引擎过程](#02执行器调用存储引擎过程)
- [03、buffer pool的内部结构](#03buffer-pool的内部结构)
- [04、一条记录磁盘上的存储格式](#04一条记录磁盘上的存储格式)
- [05、update执行过程](#05update执行过程)
- [06、事务](#06事务)
    - [1、事务的特性（ACID）](#1事务的特性acid)
    - [2、Mysql怎么保证一致性的？](#2mysql怎么保证一致性的)
    - [3、Mysql怎么保证原子性的？](#3mysql怎么保证原子性的)
    - [4、Mysql怎么保证持久性的？](#4mysql怎么保证持久性的)
    - [5、Mysql怎么保证隔离性的？](#5mysql怎么保证隔离性的)
    - [6、事务隔离级别的含义](#6事务隔离级别的含义)
- [07、mvcc](#07mvcc)
- [08、select加锁分析(Mysql的innodb引擎)](#08select加锁分析mysql的innodb引擎)
    - [1、锁类型](#1锁类型)
    - [2、加锁算法](#2加锁算法)
    - [3、快照读和当前读](#3快照读和当前读)
    - [4、加的是表锁还是行锁呢？](#4加的是表锁还是行锁呢)
    - [5、分析说明](#5分析说明)
        - [1、隔离级别为RC/RU](#1隔离级别为rcru)
        - [2、隔离级别为RR/Serializable](#2隔离级别为rrserializable)
- [09、什么叫快照读\当前读？](#09什么叫快照读\当前读)
    - [1、快照读](#1快照读)
    - [2、当前读](#2当前读)
    - [3、快照读是怎么实现的](#3快照读是怎么实现的)
- [10、MySQL索引](#10mysql索引)
    - [1、聚族索引的结构](#1聚族索引的结构)
    - [2、非聚族索引的结构](#2非聚族索引的结构)
    - [3、索引覆盖场景](#3索引覆盖场景)
- [11、binlog日志](#11binlog日志)
    - [1、定义](#1定义)
    - [2、文件格式](#2文件格式)
    - [3、用途](#3用途)
- [12、独立表空间和共享表空间的区别](#12独立表空间和共享表空间的区别)
- [13、mysql中set autocommit=0与start transaction区别](#13mysql中set-autocommit0与start-transaction区别)
- [14、InnoDB存储引擎工作原理](#14innodb存储引擎工作原理)
    - [0、体系架构](#0体系架构)
        - [1、线程](#1线程)
        - [2、内存](#2内存)
    - [1、innodb存储结构](#1innodb存储结构)
    - [2、如何存储表](#2如何存储表)
        - [.frm 文件](#frm-文件)
        - [.ibd 文件](#ibd-文件)
    - [3、如何存储记录](#3如何存储记录)
- [15、drop、truncate和delete的区别](#15droptruncate和delete的区别)
- [97、InnoDB一棵B+树可以存放多少行数据？](#97innodb一棵b树可以存放多少行数据)
- [98、线上配置相关问题](#98线上配置相关问题)
    - [1、根据什么来决定MySQL数据库的配置---核数、CPU、磁盘大小](#1根据什么来决定mysql数据库的配置---核数cpu磁盘大小)
    - [2、如何设计表的字段？如何评估一条记录占用的磁盘空间大小？误差会有多少？](#2如何设计表的字段如何评估一条记录占用的磁盘空间大小误差会有多少)
- [99、问题汇总](#99问题汇总)

<!-- /TOC -->


# 00、MySQL 的逻辑架构图

![MySQL 的逻辑架构图](../../pic/2020-02-29-13-20-33.png)


# 01、一条SQL的运行过程

DML(Update、Insert、Delete),DDL(表结构修改),DCL(权限操作),DQL(Select)操作.

![](../../pic/2020-03-06-09-57-00.png)


![](../../pic/2020-03-12-23-46-10.png)


总结：优先进行筛选条件join-condition和where-condition，然后对返回的列字段进行筛选，最后对返回数据进行排序并限制返回的条数。


MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。


![](../../pic/mysql执行顺序.png)


下面我们来具体分析一下查询处理的每一个阶段
- FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1

- ON: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。（即内连接查询，完全匹配）

- JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。

- WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。

- GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.

- CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.

- HAVING： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。

- SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。

- DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.

- ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.

- LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。

> 参考

- [MySQL查询语句执行顺序](https://blog.csdn.net/l1394049664/article/details/81603013)

- [如何写优雅的SQL原生语句？](https://segmentfault.com/a/1190000019831135)

- [我是一条DQL](https://www.cnblogs.com/rjzheng/p/10668894.html)

- [一条SQL语句在MySQL中如何执行的](https://segmentfault.com/a/1190000018812808)

- [MySql之sql执行过程](https://segmentfault.com/a/1190000017049385)

# 02、执行器调用存储引擎过程

![](../../pic/2020-03-06-10-36-38.png)



例如：select * from user where id=1

![](../../pic/2020-03-07-20-50-12.png)



到这里Mysql已经知道你想要做什么了，优化器也帮你优化了知道该怎么做了，那么就开始执行语句吧。
执行语句需要：

- 1、判断你是否有查询权限有就继续执行没有就返回权限错误；

- 2、执行器根据表的引擎定义去调用引擎接口（例：InnoDB）；
    - 2.1、无索引：
        - 1、调用innoDB引擎接口取出这个表的第一行，判断ID是否等于1，如果不是则跳过，如果是则将这行存在结果集中；
        - 2、调用引擎接口取 ‘下一行’ 执行相同判断逻辑，直到取到表的最后一行；
        - 3、执行器将所有满足条件的行 组成的记录作为结果集返回给客户端；
    - 2.2、有索引
        - 与无索引逻辑差不多，第一次调用的是“取满足条件的第一行”这个接口，之后循环的是“满足条件的下一行”这个几口，接口在引擎中已经定义好。




# 03、buffer pool的内部结构

![](../../pic/2020-03-07-10-48-24.png)

优化LRU，采用冷热数据分离的方式，而且并非访问过的数据就立刻移动到表头而是有个1分钟之后再次被访问的门限判断

![](../../pic/2020-03-07-18-22-59.png)

# 04、一条记录磁盘上的存储格式

数据页的格式：

![](../../pic/2020-03-07-18-22-11.png)

段、区、页层级结构

![](../../pic/2020-03-07-18-30-57.png)



# 05、update执行过程

update T set c=c+1 where ID=2;

看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。

- 1、执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

- 2、执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

- 3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

- 4、执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

- 5、执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

这里给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![update 语句执行流程](../../pic/2020-02-29-14-01-49.png)


你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。




# 06、事务


## 1、事务的特性（ACID）

- 原子性：要么都成功，要么都失败。保证不了就会出现数据不一致；

- 一致性：

- 隔离性：本事务的操作结果对其它事务的可见性；

- 持久性：事务提交了，对数据库的改变就是永久的，Mysql通过Redo日志保证，在一个事务中的每一次SQL更新操作之后都会写一个redo log到buffer中，在最后commit时，必须先将该事务的所有日志写入到redo log file进行持久化（顺序写，保证性能）

## 2、Mysql怎么保证一致性的？

从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。

## 3、Mysql怎么保证原子性的？

是利用Innodb的undo log实现的。undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。例如

- (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

## 4、Mysql怎么保证持久性的？

是利用Innodb的redo log。更新数据时，Mysql是先把磁盘上的数据以数据页为单位加载到内存中的缓存页中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。

怎么解决这个问题？简单啊，事务提交前直接把数据写入磁盘就行啊。

这么做有什么问题？

- 1、只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。

- 2、毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。

采用redo log的好处？

其实好处就是将redo log进行刷盘比对数据页刷盘效率高，具体表现如下

- 1、redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。

- 2、redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。


## 5、Mysql怎么保证隔离性的？

利用的是锁和MVCC机制。

至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在undo log中。

如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。

由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同.

但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。

> 参考

- [Mysql中事务ACID实现原理](https://www.cnblogs.com/rjzheng/p/10841031.html)


## 6、事务隔离级别的含义

根据事务的隔离级别不同，会有三种情况发生。即脏读、不可重复读、幻读。

![](../../pic/2020-03-12-23-32-01.png)

那么，这张图怎么理解呢？即，如果发生了脏读，那么不可重复读和幻读是一定发生的。因为拿脏读的现象，用不可重复读，幻读的定义也能解释的通。但是反过来，拿不可重复读的现象，用脏读的定义就不一定解释的通了！



```
隔离级别	                脏读	不可重复读	幻读
读未提交	                是	是	是
不可重复读(也称读提交)	否	是	是
可重复读	                否	否	是
串行化	                否	否	否

```


- 1、Read Uncommitted（RU）读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。[检索操作出来的数据是不可靠的，是可以被另一个未提交的事务修改的！]

- 2、Read Committed（RC）读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。[一个查询语句检索数据，随后又有一个查询语句在同一个事务中检索数据，两个数据应该是一样的，但是实际情况返回了不同的结果。]

- 3、Read Repeatable（RR）可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。[在一次查询的结果集里出现了某一行数据，但是该数据并未出现在更早的查询结果集里。例如，在一次事务里进行了两次查询，同时另一个事务插入某一行或更新某一行数据后(该数据符合查询语句里where后的条件)，并提交了]

**InnoDB默认用了REPEATABLE READ。在这种情况下，使用next-key locks解决幻读问题**

- 4、串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。[在该隔离级别下，所有的select语句后都自动加上lock in share mode。因此，在该隔离级别下，无论你如何进行查询，都会使用next-key locks。所有的select操作均为当前读!]


在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

> 参考

- [新说Mysql事务隔离级别](https://www.cnblogs.com/rjzheng/p/9955395.html)

# 07、mvcc

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

事务的可重复读的能力是怎么实现的？

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；

- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。


# 08、select加锁分析(Mysql的innodb引擎)

```sql
select * from table where id = ?
select * from table where id < ?
select * from table where id = ? lock in share mode
select * from table where id < ? lock in share mode
select * from table where id = ? for update
select * from table where id < ? for update
```
这六句sql在不同的事务隔离级别下，是否加锁，加的是共享锁还是排他锁，是否存在间隙锁?

要回答这个问题，先问自己三个问题

- 1、当前事务隔离级别是什么
- 2、id列是否存在索引
- 3、如果存在索引是聚簇索引还是非聚簇索引呢？



mysql的RR不是完全基于mvcc的Snapshot Isolation，而是mvcc+lock混合实现的，比如有范围查询，mysql会上gap lock，如果有unindexed row update，即使只有一个row行匹配，RR模式下update也会持有多个lock，直到事务结束。

## 1、锁类型

- 共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。
- 排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。

我们通过update、delete等语句加上的锁都是行级别的锁。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。

- 意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。
- 意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。

意向锁存在的目的?

假设事务T1，用X锁来锁住了表上的几条记录，那么此时表上存在IX锁，即意向排他锁。那么此时事务T2要进行LOCK TABLE … WRITE的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突。


## 2、加锁算法

- [官方文档](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)

存在以下三种锁：

- Record Locks：简单翻译为行锁吧。注意了，该锁是对索引记录进行加锁！锁是在加索引上而不是行上的。注意了，innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上！

- Gap Locks：简单翻译为间隙锁，是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在Read Committed隔离级别下，不会使用间隙锁。这里我对官网补充一下，隔离级别比Read Committed低的情况下，也不会使用间隙锁，如隔离级别为Read Uncommited时，也不存在间隙锁。当隔离级别为Repeatable Read和Serializable时，就会存在间隙锁。

- Next-Key Locks：这个理解为Record Lock+索引前面的Gap Lock。记住了，锁住的是索引前面的间隙！比如一个索引包含值，10，11，13和20。那么，Next-Key Locks的范围如下

```
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```

## 3、快照读和当前读

在mysql中select分为快照读和当前读，执行下面的语句

select * from table where id = ?;

执行的是快照读，读的是数据库记录的快照版本，是不加锁的。（这种说法在隔离级别为Serializable中不成立，后面我会补充。）
那么，执行

select * from table where id = ? lock in share mode;

会对读取记录加S锁 (共享锁)，执行

select * from table where id = ? for update

会对读取记录加X锁 (排他锁)，那么

## 4、加的是表锁还是行锁呢？

针对这点，我们先回忆一下事务的四个隔离级别，他们由弱到强如下所示:

- Read Uncommited(RU)：读未提交，一个事务可以读到另一个事务未提交的数据！
- Read Committed (RC)：读已提交，一个事务可以读到另一个事务已提交的数据!
- Repeatable Read (RR):可重复读，加入间隙锁，一定程度上避免了幻读的产生！注意了，只是一定程度上，并没有完全避免!我会在下一篇文章说明!另外就是记住从该级别才开始加入间隙锁(这句话记下来，后面有用到)!
- Serializable：串行化，该级别下读写串行化，且所有的select语句后都自动加上lock in share mode，即使用了共享锁。因此在该隔离级别下，使用的是当前读，而不是快照读。

那么关于是表锁还是行锁，大家可以看到网上最流传的一个说法是这样的，

InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。 InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！这句话本身有两处错误！

- 错误一:并不是用表锁来实现锁表的操作，而是利用了Next-Key Locks，也可以理解为是用了行锁+间隙锁来实现锁表的操作!

为了便于说明，我来个例子，假设有表数据如下，pId为主键索引

```
pId(int)	name(varchar)	num(int)
1	aaa	100
2	bbb	200
7	ccc	200
```

执行语句(name列无索引)

select * from table where name = `aaa` for update

那么此时在pId=1,2,7这三条记录上存在行锁(把行锁住了)。另外，在(-∞,1)(1,2)(2,7)(7,+∞)上存在间隙锁(把间隙锁住了)。因此，给人一种整个表锁住的错觉！

ps:对该结论有疑问的，可自行执行show engine innodb status;语句进行分析。

- 错误二:所有文章都不提隔离级别！

注意我上面说的，之所以能够锁表，是通过行锁+间隙锁来实现的。那么，RU和RC都不存在间隙锁，这种说法在RU和RC中还能成立么？

因此，该说法只在RR和Serializable中是成立的。如果隔离级别为RU和RC，无论条件列上是否有索引，都不会锁表，只锁行！

## 5、分析说明

前提说明：

- 快照查询：一般的select
- 前读查询[select ... lock in share mode/select ... for update]


### 1、隔离级别为RC/RU

- 1、条件列非索引

- 2、条件列是聚簇索引

- 3、条件列是非聚簇索引

为什么条件列加不加索引，加锁情况是一样的？[即1和2对应的情况]

其实是不一样的。在RC/RU隔离级别中，MySQL Server做了优化。在条件列没有索引的情况下，尽管通过聚簇索引来扫描全表，进行全表加锁。但是，MySQL Server层会进行过滤并把不符合条件的锁当即释放掉，因此你看起来最终结果是一样的。但是RC/RU+条件列非索引比直接使用聚族索引多了一个释放不符合条件的锁的过程！

针对情况3，首先会在非聚族索引B+树上锁住指定的非聚族索引，然后到聚族索引上锁住对应的聚族索引行。

> 总结

- 1、针对快照读，不加任何锁；
- 2、针对当前读查询，这两个隔离级别不存在间隙锁，不会出现锁表，只会锁住符合条件的行。

### 2、隔离级别为RR/Serializable



- 1、条件列非索引：RR级别需要多考虑的就是gap lock，他的加锁特征在于，无论你怎么查都是锁全表
    - 1、快照读：RR级别不加锁；Serializable级别，主键索引锁+间隙锁=锁表；
    - 2、当前读：全部主键索引锁+间隙锁=锁表；

- 2、条件列是聚簇索引：该情况的加锁特征在于，如果where后的条件为精确查询(=的情况)，那么只存在record lock。如果where后的条件为范围查询(>或<的情况)，那么存在的是record lock+gap lock
    - 1、快照读：RR级别不加锁；Serializable级别，等值查询主键索引锁，范围查询主键索引锁+间隙锁=锁表；
    - 2、当前读：等值查询存在加主键索引锁，不存在在符合条件的主键索引上加间隙锁；

- 3、条件列是非聚簇索引：这里非聚簇索引，需要区分是否为唯一索引。因为如果是非唯一索引，间隙锁的加锁方式是有区别的。
    - 1、先说一下，唯一索引的情况。如果是唯一索引，情况和RR/Serializable+条件列是聚簇索引类似，唯一有区别的是:这个时候有两棵索引树，加锁是加在对应的非聚簇索引树和聚簇索引树上！
    - 2、非聚簇索引是非唯一索引的情况，他和唯一索引的区别就是通过索引进行精确查询以后，不仅存在record lock，还存在gap lock。而通过唯一索引进行精确查询后，只存在record lock，不存在gap lock。

> 参考

- [select加锁分析(Mysql)](https://www.cnblogs.com/rjzheng/p/9950951.html)

# 09、什么叫快照读\当前读？

## 1、快照读

select id,name from student t where t.name = '张三';

这种普通的select查询就叫快照读（Mysql的RC和RR隔离级别下普通的select查询都是快照读），无须加锁，即使有别的事务在修改本条数据也不影响，提升读取速度.不过RC和RR隔离级别下快照的定义有所区别：

- RR和RC隔离级别的差别是创建snapshot时机不同， RR隔离级别是在事务开始时，确切地说是第一个读操作时创建read view的（所以此后所有的读都是同样的数据）

- RC隔离级别是在每个语句开始时创建read view的（每次读获取的比较事务数组都是最新的，所以能拿到最新的commit数据）。



## 2、当前读

select id,name from student t where t.name = '张三' lock in share mode;

select id,name from student t where t.name = '张三' for update;

上面的两条语句加了共享读锁和排它写锁，就成了当前读，要和其他事务竞争锁了。

除了上面这两种select，insert/update/delete也是当前读，需要加锁，有锁就有竞争，为了保证同步，设计一般会采用顺序（如队列）或者加锁（多线程）的方式，加锁的话，粒度要尽可能的小

Mysql（InnoDB）有行锁、表锁、间隙锁、NEXT-KEY锁、意向锁等，具体使用哪种锁和具体的语句是否包含索引（聚簇索引、非聚簇索引、insert时是否有自增主键）以及事务隔离级别有关


- [Select查询是否需要主动处理事务](https://www.jianshu.com/p/76c6176321fc)

## 3、快照读是怎么实现的

快照读并不是将所有数据复制了一份，那数据库容量很快就不够了，而且设计复杂度也更高。快照读是记录了当前活跃的事务集合，用于查询数据时判断是否能够看到该条记录：也就是在某一时刻给事务系统trx_sys打snapshot（快照），把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断事务可见性。

我能知道哪些事务比我早了，但怎么就能持续读到一样的数据呢？

- InnoDB中通过undo log实现了数据的多版本，undo log除了实现MVCC外，还用于事务的回滚

- InnoDB行记录中除了rowid外，还包含trx_id和db_roll_ptr字段, trx_id表示最近修改的事务的id（trx_id能够代表事务开始的先后顺序）

![](../../pic/2020-03-13-10-10-53.png)

- db_roll_ptr指向最近一次更新所创建的回滚段，每条undo log也会指向更早版本的undo log，从而形成一条更新链，通过这个更新链，不同事务可以找到其对应版本的undo log，根据之前创建的快照，就可以判断出来哪条最新数据可读，也就实现了MVCC


# 10、MySQL索引

针对innodb引擎的表存在唯一并且必须的一个聚族索引，并且也是主键索引。这个索引会存在以下三种可能：

- 1、用户创建表的时候设置了主键，这个主键就是聚族索引；
- 2、用户没有设置主键，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引；
- 3、如果没有这样的索引，InnoDB会隐式定义一个自增主键来作为聚簇索引；

所以说针对innodb肯定存在一个主键索引，并且根据这个主键构造一个B+树来存储整个表的数据。

创建的非主键索引，如复合索引、前缀索引、唯一索引，都是属于非聚簇索引，又称为辅助索引(secondary index)，其数据结构也是B+树。设置了几个索引就会多存在几个B+树，索引的增多会增加数据插入、更新、删除的维护成本。


## 1、聚族索引的结构

先来一张带主键的表，如下所示，pId是主键

```sql
pId	name	birthday
5	zhangsan	2016-10-02
8	lisi	2015-10-04
11	wangwu	2016-09-02
13	zhaoliu	2015-10-07
```
![](../../pic/2020-03-12-22-32-19.png)

上半部分是由主键形成的B+树，下半部分就是磁盘上真实的数据！

语句执行过程：select * from table where pId='11'

![](../../pic/2020-03-12-22-33-31.png)


如上图所示，从根开始，经过3次查找，就可以找到真实数据。如果不使用索引，那就要在磁盘上，进行逐行扫描，直到找到数据位置。显然，使用索引速度会快。但是在写入数据的时候，需要维护这颗B+树的结构，因此写入性能会下降！


## 2、非聚族索引的结构

create index index_name on table(name);在name字段上创建一个非聚族索引

![](../../pic/2020-03-12-22-41-46.png)

会根据你的索引字段生成一颗新的B+树。因此， 我们每加一个索引，就会增加表的体积， 占用磁盘存储空间。然而，注意看叶子节点，非聚簇索引的叶子节点并不是真实数据，它的叶子节点依然是索引节点，存放的是该索引字段的值以及对应的主键索引(聚簇索引)。

非聚族索引的执行过程：select * from table where name='lisi'

![](../../pic/2020-03-12-22-43-40.png)

通过上图红线可以看出，先从非聚簇索引树开始查找，然后找到聚簇索引后。根据聚簇索引，在聚簇索引的B+树上，找到完整的数据！这里经历了一次回表查询过程。

注意：多加一个索引，就会多生成一颗非聚簇索引树。

## 3、索引覆盖场景

select name from table where name='lisi'

非聚族索引包含我们查找的全部字段

![](../../pic/2020-03-12-22-46-12.png)

如上图红线所示，如果在非聚簇索引树上找到了想要的值，就不会去聚簇索引树上查询。


> 参考

- [MySQL(Innodb)索引的原理](https://www.cnblogs.com/rjzheng/p/9915754.html)



# 11、binlog日志

## 1、定义

binlog是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。[如果update操作没有造成数据变化，也是会记入binlog]

binlog不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看MySQL执行过的所有语句。

## 2、文件格式

> 1、这个二进制日志包括两类文件：

- 索引文件（文件名后缀为.index）用于记录哪些日志文件正在被使用

- 日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。


> 2、binlog常见格式

![](../../pic/2020-03-13-09-13-10.png)

业内目前推荐使用的是row模式，准确性高，虽然说文件大，但是现在有SSD和万兆光纤网络，这些磁盘IO和网络IO都是可以接受的。

> 3、怎么查看binlog

binlog本身是一类二进制文件。二进制文件更省空间，写入速度更快，是无法直接打开来查看的。因此mysql提供了命令mysqlbinlog进行查看。

一般的statement格式的二进制文件，用下面命令就可以

mysqlbinlog mysql-bin.000001 

如果是row格式，加上-v或者-vv参数就行，如

mysqlbinlog -vv mysql-bin.000001 

> 4、怎么删binlog

删binlog的方法很多，有三种是常见的

- (1) 使用reset master,该命令将会删除所有日志，并让日志文件重新从000001开始。

- (2) 使用命令

PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr }
例如

purge master logs to "binlog_name.00000X" 

将会清空00000X之前的所有日志文件.

- (3) 使用--expire_logs_days=N选项指定过了多少天日志自动过期清空。

> 5、binlog常见参数

![](../../pic/2020-03-13-09-17-14.png)


> 6、binlog的结构

文件头由一个四字节Magic Number构成，其值为1852400382，在内存中就是"0xfe,0x62,0x69,0x6e"。这个Magic Number就是来验证这个binlog文件是否有效 。

在文件头之后，跟随的是一个一个事件依次排列。其分为三个部分:通用事件头（common-header）、私有事件头（post-header）和事件体（event-body）。

![](../../pic/2020-03-13-09-22-52.png)


## 3、用途

分别为恢复、复制、审计。

- 1、恢复：这里网上有大把的文章指导你，如何利用binlog日志恢复数据库数据。如果你真的觉得自己很有时间，就自己去创建个库，然后删了，再去恢复一下数据，练练手吧。

- 2、复制: 如图所示。主库有一个log dump线程，将binlog传给从库。从库有两个线程，一个I/O线程，一个SQL线程，I/O线程读取主库传过来的binlog内容并写入到relay log,SQL线程从relay log里面读取内容，写入从库的数据库。

![](../../pic/2020-03-13-09-10-54.png)


- 3、审计：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。

> 参考

- [研发应该懂的binlog知识(上)](https://www.cnblogs.com/rjzheng/p/9721765.html)

- [研发应该懂的binlog知识(下)](https://www.cnblogs.com/rjzheng/p/9745551.html)

- [binlog二进制文件解析](https://mp.weixin.qq.com/s/j987HNc74gRYHl6au24XSg)



# 12、独立表空间和共享表空间的区别

MySQL5.6.7之后默认开启独立表空间。

也就是在my.cnf中，有这么一条配置：innodb_file_per_table = 1

查看表空间状态，用下面的命令：show variables like '%per_table'; 

- 如果innodb_file_per_table的value值为OFF，代表采用的是共享表空间。

- 如果innodb_file_per_table的value值为ON ，代表采用的是独立表空间。

独立表空间和共享表空间的区别？

- 共享表空间：某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1(此文件，可以扩展成多个)。注意，在这种方式下，运维超级不方便。你看，所有数据都在一个文件里，要对单表维护，十分不方便。另外，你在做delete操作的时候，文件内会留下很多间隙，ibdata1文件不会自动收缩。换句话说，使用共享表空间来存储数据，会遭遇drop table之后，空间无法释放的问题。

- 独立表空间:每一个表都以独立方式来部署，每个表都有一个.frm表描述文件，还有一个.ibd文件。
    - .frm文件：保存了每个表的元数据，包括表结构的定义等，该文件与数据库引擎无关。
    - .ibd文件：保存了每个表的数据和索引的文件。
    
    注意，在这种方式下，每个表都有自已独立的表空间，这样运维起来方便，可以实现单表在不同数据库之间的移动。另外，在执行drop table操作的时候，是可以自动回收表空间。在执行delete操作后，可以通过alter table TableName engine=innodb可以整理碎片，回收部分表空间。

ps：my.cnf中的datadir就是用来设置数据存储目录

在绝大部分情况下，运维一定会为mysql选择独立表空间的存储方式，因为采用独立表空间的方式，从性能优化和运维难易角度来说，实在强太多。

> 参考

- [Innodb中mysql如何快速删除2T的大表](https://www.cnblogs.com/rjzheng/p/9497109.html)


# 13、mysql中set autocommit=0与start transaction区别

- set autocommit=0,当前session禁用自动提交事物，自此句执行以后，每个SQL语句或者语句块所在的事务都需要显示"commit"才能提交事务。

- start transaction指的是启动一个新事务。

    在默认的情况下，MySQL从自动提交（autocommit）模式运行，这种模式会在每条语句执行完毕后把它作出的修改立刻提交给数据库并使之永久化。事实上，这相当于把每一条语句都隐含地当做一个事务来执行。如果你想明确地执行事务，需要禁用自动提交模式并告诉MySQL你想让它在何时提交或回滚有关的修改。

    执行事务的常用办法是发出一条START TRANSACTION（或BEGIN）语句挂起自动提交模式，然后执行构成本次事务的各条语句，最后用一条 COMMIT语句结束事务并把它们作出的修改永久性地记入数据库。万一在事务过程中发生错误，用一条ROLLBACK语句撤销事务并把数据库恢复到事务开 始之前的状态。

    START TRANSACTION语句"挂起"自动提交模式的含义是：在事务被提交或回滚之后，该模式将恢复到开始本次事务的 START TRANSACTION语句被执行之前的状态。（如果自动提交模式原来是激活的，结束事务将让你回到自动提交模式；如果它原来是禁用的，结束 当前事务将开始下一个事务。）
    
如果是autocommit模式  ，autocommit的值应该为 1 ，不autocommit 的值是 0 ；请在试验前 确定autocommit 的模式是否开启


> 参考

- [参考官方文档](http://dev.mysql.com/doc/refman/5.7/en/commit.html)


# 14、InnoDB存储引擎工作原理


## 0、体系架构

InnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。

![](../../pic/2020-03-05-11-11-01.png)


### 1、线程

InnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务

- Master Thread
Master Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。

- IO Thread
在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。

- Purge Thread
事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。InnoDB支持多个Purge Thread, 这样做可以加快UNDO页的回收，提高CPU的使用率以及提升存储引擎的性能。

- Page Cleaner Thread
Page Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，其目的是减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。


默认情况下，InnoDB 的后台线程有 7 个，其中 4 个 IO thread, 1 个 Master thread, 1 个 Lock monitor thread, 一个 Error monitor thread。InnoDB 的主要工作都是在一个单独的 Master 线程里完成的。Master 线程的优先级最高，它主要分为以下几个循环：主循环（loop）、后台循环（background loop）、刷新循环（flush loop）、暂停循环（suspend loop）。

![](../../pic/2020-03-05-11-18-09.png)

其中主循环的伪代码如下：

```
void master_thread() (
    loop:
    for (int i =0; i <10; i++){
        do thing once per second
        sleep 1 second if necessary
    }
    do things once per ten seconds
    goto loop;
}
```

- 其中每秒一次的操作包括：刷新日志缓冲区（总是），合并插入缓冲（可能），至多刷新 100 个脏数据页（可能），如果没有当前用户活动，切换至 background loop （可能）。

- 其中每 10 秒一次的操作包括：合并至多 5 个插入缓冲（总是），刷新日志缓冲（总是），刷新 100 个或 10 个脏页到磁盘（总是），产生一个检查点（总是），删除无用 Undo 页 （总是）。

- 后台循环，若当前没有用户活动或数据库关闭时，会切换至该循环执行以下操作：删除无用的 undo 页（总是），合并 20 个插入缓冲（总是），跳回到主循环（总是），不断刷新 100 个页，直到符合条件跳转到 flush loop（可能）。

- 如果 flush loop 中也没有什么事情可做，边切换到 suspend loop，将 master 线程挂起。


### 2、内存

![](../../pic/2020-03-05-11-13-29.png)

![](../../pic/2020-03-05-11-14-11.png)


nnoDB 的内存主要有以下几个部分组成：缓冲池 (buffer pool)、重做日志缓冲池(redo log buffer）以及额外的内存池（additional memory pool），如图所示：

其中缓冲池占最大块内存，用来缓存各自数据，数据文件按页（每页 16K）读取到缓冲池，按最近最少使用算法（LRU）保留缓存数据。缓冲池缓冲的数据类型有：数据页、索引页、插入缓冲、自适应哈希索引、锁信息、数据字典信息等，其中数据页和索引页占了绝大部分内存。日志缓冲将重做日志信息先放入这个缓冲区，然后按一定频率（默认为 1s）将其刷新至重做日志文件。

InnoDB 通过一些列后台线程将相关操作进行异步处理，同时借助缓冲池来减小 CPU 和磁盘速度上的差异。当查询的时候会先通过索引定位到对应的数据页，然后检测数据页是否在缓冲池内，如果在就直接返回，如果不在就去聚簇索引中通过磁盘 IO 读取对应的数据页并放入缓冲池。一个数据页会包含多个数据行。缓存池通过 LRU 算法对数据页进行管理，也就是最频繁使用的数据页排在列表前面，不经常使用的排在队尾，当缓冲池满了的时候会淘汰掉队尾的数据页。从磁盘新读取到的数据页并不会放在队列头部而是放在中间位置，这个中间位置可以通过参数进行修。缓冲池也可以设置多个实例，数据页根据哈希算法决定放在哪个缓冲池。



## 1、innodb存储结构

InnoDB 存储引擎的逻辑存储结构和 Oracle 大致相同，所有数据都被逻辑地存放在一个空间中，我们称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block），1 extent = 64 pages，InnoDB 存储引擎的逻辑存储结构大致如图所示：

![](../../pic/2020-03-05-11-16-44.png)

![](../../pic/2020-03-05-12-02-41.png)

表空间作为存储结构的最高层，所有数据都存放在表空间中，默认情况下用一个共享表空间 ibdata1 ，如果开启了 innodb_file_per_table 则每张表的数据将存储在单独的表空间中，也就是每张表都会有一个文件，

表空间由各个段构成，InnoDB 存储引擎由索引组织的，而索引中的叶子节点用来记录数据，存储在数据段，而非叶子节点用来构建索引，存储在索引段。区是由连续的页组成，任何情况下一个区都是 1MB，一个区中可以有多个页，每个页默认为 16KB ，所以默认情况下一个区中可以包含 64 个连续的页，页的大小是可以通过 innodb_page_size 设置，页中存储的是具体的行记录。一行记录最终以二进制的方式存储在文件里。

从物理意义上来看，InnoDB 表由共享表空间、日志文件组（更准确地说，应该是 Redo 文件组）、表结构定义文件组成。若将 innodb_file_per_table 设置为 on，则每个表将独立地产生一个表空间文件，以 ibd 结尾，数据、索引、表的内部数据字典信息都将保存在这个单独的表空间文件中。表结构定义文件以 frm 结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为 .frm 文件。



同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 innodb_page_size 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同：

![](../../pic/2020-03-05-12-03-18.png)

从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。



MySQL的基本存储结构是页(记录都存在页里边)

![](../../pic/2020-03-05-10-55-30.png)

![](../../pic/2020-03-05-10-55-56.png)

各个数据页可以组成一个双向链表

每个数据页中的记录又可以组成一个单向链表

- 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

- 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。


所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

- 1、定位到记录所在的页：需要遍历双向链表，找到所在的页；
- 2、从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了；

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：

![](../../pic/2020-03-05-10-59-49.png)

要找到id为8的记录简要步骤：

![](../../pic/2020-03-05-11-00-45.png)

[自己理解]

- 1、针对innodb引擎来说，如果使用主键索引查找，自己根据主键id去B+树查询；

- 2、使用辅助索引，先在辅助索引的B+树查找得到主键id，然后回表，剩下的步骤同1；

- 3、没有任何索引可用，直接遍历全表，遍历全表的页，页内的记录；






## 2、如何存储表

MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。

![](../../pic/2020-03-05-12-05-32.png)


### .frm 文件

无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义；.frm 文件的格式在不同的平台上都是相同的。

```sql
CREATE TABLE test_frm(
    column1 CHAR(5), 
    column2 INTEGER
);
```

当我们使用上面的代码创建表时，会在磁盘上的 datadir 文件夹中生成一个 test_frm.frm 的文件.


### .ibd 文件

InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。

当打开 innodb_file_per_table 选项时，.ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。

## 3、如何存储记录

与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-200 行的记录。

当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：

![](../../pic/2020-03-05-12-12-36.png)

Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。


两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：

![](../../pic/2020-03-05-12-13-14.png)

Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。


> 参考

- [『浅入浅出』MySQL 和 InnoDB](https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247486871&idx=1&sn=df2adfad945bd34d27dee557537a0782&chksm=ebf6d5e8dc815cfee8b282b31580ba8504f76b052f3ac9431b26f4f7e057a0cff5f57dfbead6&mpshare=1&scene=24&srcid=0128P4c2FcNE0OHu310gHh61##)

- [MySQL InnoDB 存储引擎探秘](https://segmentfault.com/a/1190000018229752)

- [MySQL 索引的原理与应用：索引类型，存储结构与锁](https://segmentfault.com/a/1190000019366328)

- [从根儿上理解MySQL：10年老DBA告诉你1条记录在表中是如何存储的](https://baijiahao.baidu.com/s?id=1644888989326529522&wfr=spider&for=pc)


# 15、drop、truncate和delete的区别



> 参考

- [drop、truncate和delete的区别](https://www.cnblogs.com/zhizhao/p/7825469.html)




# 97、InnoDB一棵B+树可以存放多少行数据？

**在InnoDB的表空间文件中，约定page number为3的代表主键索引的根页，而在根页偏移量为64的地方存放了该B+树的page level。如果page level为1，树高为2，page level为2，则树高为3。即B+树的高度=page level+1；**


InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。为什么是这么多呢？因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。

我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k，而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。

在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置：show variables like 'innodb_page_size';

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。

如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，用B+树的方式组织这些数据。如图所示：

![](../../pic/2020-03-14-14-55-22.png)

我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多），除了存放数据的页以外，还有存放键值+指针的页，如图中page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。现在来看下，要查找一条数据，怎么查？

如select * from user where id=5;

这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明），找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录：

现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下：

- 1、InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。

- 2、索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；

那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？

这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。

上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。

那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。

根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。


> 参考

- [InnoDB一棵B+树可以存放多少行数据？](https://www.cnblogs.com/leefreeman/p/8315844.html)


# 98、线上配置相关问题

## 1、根据什么来决定MySQL数据库的配置---核数、CPU、磁盘大小

简单来说如何根据数据量的大小来决定MySQL数据库的配置合理？

## 2、如何设计表的字段？如何评估一条记录占用的磁盘空间大小？误差会有多少？





# 99、问题汇总

- [杂谈自增主键用完了怎么办](https://www.cnblogs.com/rjzheng/p/10669043.html)

- [讲讲mysql表设计要注意啥](https://www.cnblogs.com/rjzheng/p/11174714.html)

- [为什么Mongodb索引用B树，而Mysql用B+树?](https://www.cnblogs.com/rjzheng/p/12316685.html)

- [数据库优化的几个阶段](https://www.cnblogs.com/rjzheng/p/9619855.html)

思路：优化sql和索引-->搭建缓存--->读写分离--->垂直拆分--->水平拆分

- [分库分表后如何部署上线](https://www.cnblogs.com/rjzheng/p/9597810.html)

- [数据库中为什么不推荐使用外键约束](https://www.cnblogs.com/rjzheng/p/9907304.html)

原因：性能问题；并发问题；扩展性问题；技术问题

- [Mysql中select的正确姿势](https://www.cnblogs.com/rjzheng/p/9902911.html)

- [MySQL 优化实施方案](https://www.cnblogs.com/clsn/p/8214048.html)

- [数据库介绍](http://www.cnblogs.com/clsn/p/8038964.html#_label6)

- [MySQL在并发场景下的问题及解决思路](https://www.cnblogs.com/leefreeman/p/8286550.html)

- [何登成的技术博客](http://hedengcheng.com/?cat=6)

- [使用binlog2sql做数据恢复的简单示例](https://www.cnblogs.com/leefreeman/p/7680953.html)



