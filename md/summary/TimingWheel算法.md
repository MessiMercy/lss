# 99、TimingWheel(时间轮算法)

- [基于java的TimingWheel(时间轮算法)分布式任务调度系统](https://blog.csdn.net/ericlyn/article/details/80624521)

- [Spring -- 定时任务调度的发展](https://mrdear.cn/posts/framework-spring-schedule.html)

- [时间轮算法（TimingWheel）是如何实现的？]https://www.cnblogs.com/luozhiyun/p/12075326.html()

- [Timing Wheel 定时轮算法](https://blog.csdn.net/mindfloating/article/details/8033340)






关于TimingWheel(时间轮)算法的任务定时器网上有很多文章，但是却找不到基于java成系统的文章，所以今天把我在公司做的且稳定运行半年多的TimingWheel系统分享给大家。

## 1、TimingWheel基本原理

    众所周知寻常的定时器大概有两种，一种是开阻塞线程，另一种是开一个任务队列然后定期扫描。显而易见这两种方式的弊端很明显，前者对线程消耗过大，后者对时间消耗过大（很多未到时间的任务会被多次重复扫描消耗性能）

为了解决以上两个问题就可以使用TimingWheel数据结构。

![](../../pic/2020-04-04-19-25-15.png)

很明显时间轮算法是基于循环链表数据结构。那么他的工作原理具体是怎样的呢？

    能看到图中有个指针，我们假设指针没跳动一下需要10秒，然后现在我们有一个50秒后执行的任务A，由此推断在当前指针指向2的时候，任务A会被存放在槽格7中。当指针跳动到7后取出槽格中的任务队列，此时任务A将会被执行。但是当如果有100秒后的任务需要执行，依然超出了槽格数量是该怎么办呢？很简单，我们为任务实例添加一个属性“圈数”就可以解决。就是说每次装载任务时算出此任务需要指针转动几圈才能够被执行。

以上就是时间轮算法的最基本的原理了，此外还有升级版复合时间轮算法用来解决巨大量的定时任务的一种解决方案。